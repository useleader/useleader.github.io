<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.warmfire.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="从基础概念开始学习！">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp学习日志">
<meta property="og:url" content="http://www.warmfire.com/2023/09/23/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/index.html">
<meta property="og:site_name" content="WarmFire">
<meta property="og:description" content="从基础概念开始学习！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231009203842470.png">
<meta property="og:image" content="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231010230712173.png">
<meta property="article:published_time" content="2023-09-23T01:36:53.000Z">
<meta property="article:modified_time" content="2023-10-11T03:25:11.175Z">
<meta property="article:author" content="Yan Zhimin">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231009203842470.png">

<link rel="canonical" href="http://www.warmfire.com/2023/09/23/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>cpp学习日志 | WarmFire</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="WarmFire" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WarmFire</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.warmfire.com/2023/09/23/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yan Zhimin">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WarmFire">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cpp学习日志
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-23 09:36:53" itemprop="dateCreated datePublished" datetime="2023-09-23T09:36:53+08:00">2023-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-11 11:25:11" itemprop="dateModified" datetime="2023-10-11T11:25:11+08:00">2023-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/C-%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">C++学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">从基础概念开始学习！</div>

          
          
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>参考主教程：<a target="_blank" rel="noopener" href="https://light-city.github.io/">C++那些事 (light-city.github.io)</a></p>
</blockquote>
<h1><span id="基础进阶部分">基础进阶部分</span></h1><h2><span id="const那些事">const那些事</span></h2><ol>
<li><p>含义：const说明的类型叫做常类型，常类型的变量或对象的值是不能被更新的</p>
</li>
<li><p>作用：</p>
<ol>
<li><p>可以定义常量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型检查</p>
<p>const常量与#define宏定义的常量区别： const 常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，知识简单的字符串替换，不能进行安全检查。</p>
<p><code>const</code>定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。</p>
</li>
<li><p>防止修改，起保护作用，加强Robustness</p>
</li>
<li><p>节省空间，避免不必要的内存分配</p>
<p>const只是给出了对应的内存地址，而不是像#define一样给出的立即数，const在程序运行过程中一份copy，而#define有若干个copy</p>
</li>
</ol>
</li>
<li><p>const对象默认为文件局部变量</p>
<font color="red">非const变量默认为extern， 要使const变量能够在其他文件中访问，必须在文件中显性指定它为extern</font>
</li>
<li><p>定义常量</p>
<ol>
<li>常量不可更改</li>
<li>常量必须初始化</li>
</ol>
</li>
<li><p>指针与const</p>
<ol>
<li><p>四种相关的const</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *a;  <span class="comment">//指向const对象的指针或者说指向常量的指针</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *a; <span class="comment">//同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向类型对象的const指针，或者说常指针、const指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针</span></span><br></pre></td></tr></table></figure>
<p><strong>允许把非const对象的地址赋给指向const对象的指针</strong></p>
<p>这时无法通过该指针来修改变量的值，即使指向的是非const对象，也不能通过<code>void *</code> 指针来保存const对象的地址，必须使用从const void * 类型的指针保存const对象的地址</p>
</li>
<li><p>常指针</p>
<p>const指针必须初始化，且指针的值不能修改</p>
</li>
<li><p>指向常量的常指针</p>
</li>
</ol>
</li>
<li><p>函数中使用const</p>
<ol>
<li><blockquote>
<p>const 修饰函数返回值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> * <span class="title">func</span><span class="params">()</span> <span class="comment">// 指针所指不可变</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="type">const</span> <span class="title">func</span><span class="params">()</span> <span class="comment">//指针不可变</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><blockquote>
<p>const 修饰函数参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(const int var) // 传递过来的参数不可变</span><br><span class="line">void func(int *const var) //指针不可变7</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>类中使用const</p>
<ul>
<li><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型，如果在编写const成员函数时，不慎修改数据成员，或者调用了其他非const成员函数，编译器将指出错误，提高程序健壮性。</p>
</li>
<li><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，否能不能操作常对象</p>
</li>
<li><p>对于类中的const成员变量必须通过初始化列表进行初始化</p>
</li>
<li><p>```cpp<br>class Apple<br>{<br>private:<br> int people[100];<br>public:<br> Apple(int i);<br> const int apple_number;<br>};</p>
</li>
</ul>
<p>Apple::Apple(int i):apple_number(i)<br>{</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">- ```cpp</span><br><span class="line">  //apple.cpp</span><br><span class="line">  class Apple</span><br><span class="line">  &#123;</span><br><span class="line">  private:</span><br><span class="line">      int people[100];</span><br><span class="line">  public:</span><br><span class="line">      Apple(int i); </span><br><span class="line">      const int apple_number;</span><br><span class="line">      void take(int num) const;</span><br><span class="line">      int add(int num);</span><br><span class="line">      int add(int num) const;</span><br><span class="line">      int getCount() const;</span><br><span class="line">  </span><br><span class="line">  &#125;;</span><br><span class="line">  //main.cpp</span><br><span class="line">  #include&lt;iostream&gt;</span><br><span class="line">  #include&quot;apple.cpp&quot;</span><br><span class="line">  using namespace std;</span><br><span class="line">  </span><br><span class="line">  Apple::Apple(int i):apple_number(i)</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::add(int num)&#123;</span><br><span class="line">      take(num);</span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::add(int num) const&#123;</span><br><span class="line">      take(num);</span><br><span class="line">  &#125;</span><br><span class="line">  void Apple::take(int num) const</span><br><span class="line">  &#123;</span><br><span class="line">      cout&lt;&lt;&quot;take func &quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::getCount() const</span><br><span class="line">  &#123;</span><br><span class="line">      take(1);</span><br><span class="line">  //    add(); //error</span><br><span class="line">      return apple_number;</span><br><span class="line">  &#125;</span><br><span class="line">  int main()&#123;</span><br><span class="line">      Apple a(2);</span><br><span class="line">      cout&lt;&lt;a.getCount()&lt;&lt;endl;</span><br><span class="line">      a.add(10);</span><br><span class="line">      const Apple b(3);</span><br><span class="line">      b.add(100);</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  //编译： g++ -o main main.cpp apple.cpp</span><br><span class="line">  //结果</span><br><span class="line">  take func 1</span><br><span class="line">  2</span><br><span class="line">  take func 10</span><br><span class="line">  take func 100</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<ul>
<li><p>getCount()中调用的add方法由于其非const修饰，所以会导致运行报错，即const对象只能访问const成员函数</p>
</li>
<li><p>而add调用了const修饰的take，证明了非ocnst对象可以访问任意的成员函数，包括const成员函数</p>
</li>
<li><p>add的一个重载函数，也输出了两个结果，说明const对象默认调用const成员函数</p>
</li>
</ul>
<p>还有其他方法能够初始化const常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line"><span class="comment">// 将常量定义与static结合</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<hr>
<h2><span id="static-那些事">static 那些事</span></h2><p>当与不同类型一起使用时，static含义不同：</p>
<ul>
<li>静态变量：函数中的变量，类中的变量</li>
<li>静态类的成员：类对象和类中的函数（类的实例是类对象）</li>
</ul>
<p>具体用法：</p>
<h3><span id="静态变量">静态变量</span></h3><h4><span id="1-函数中的静态变量">1 函数中的静态变量</span></h4><p>当变量声明为static时，空间将在<strong>程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。这对于在C/C++或需要存储先前函数状态的任何其他应用程序非常有用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// static variable </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// value is updated and </span></span><br><span class="line">    <span class="comment">// will be carried to next </span></span><br><span class="line">    <span class="comment">// function calls </span></span><br><span class="line">    count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)  </span><br><span class="line">        <span class="built_in">demo</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output： 0 1 2 3 4 </span></span><br></pre></td></tr></table></figure>
<p>可以看出static变量的值是通过函数调用来传递。每次调用的时候不会对该变量进行初始化。</p>
<h4><span id="2-类中的静态变量">2 类中的静态变量</span></h4><p>由于声明为static的变量只被初始化一次，因为他们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>，对于不同的对象，不能有相同静态变量的多个副本。因此，静态变量不能使用构造函数初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Apple</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">Apple obj1; </span><br><span class="line">Apple obj2; </span><br><span class="line">obj1.i =<span class="number">2</span>; </span><br><span class="line">obj2.i = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// prints value of i </span></span><br><span class="line">cout &lt;&lt; obj1.i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;obj2.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这个无法通过编译，因为i并没有初始化。因此，类中的静态变量应由用户使用的类外的类名和范围解析运算符显示初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">class Apple </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">    static int i; </span><br><span class="line"></span><br><span class="line">    Apple() </span><br><span class="line">    &#123; </span><br><span class="line">        // Do nothing </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line">int Apple::i = 0; // 显式初始化静态变量</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    Apple obj1; </span><br><span class="line">    Apple obj2; </span><br><span class="line"></span><br><span class="line">    // 对静态变量进行赋值</span><br><span class="line">    Apple::i = 2; </span><br><span class="line"></span><br><span class="line">    // 输出静态变量的值</span><br><span class="line">    cout &lt;&lt; Apple::i &lt;&lt; endl; // 输出: 2</span><br><span class="line">    cout &lt;&lt; obj1.i &lt;&lt; endl;    // 输出: 2</span><br><span class="line">    cout &lt;&lt; obj2.i &lt;&lt; endl;    // 输出: 2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="静态成员">静态成员</span></h3><h4><span id="类对象为静态">类对象为静态</span></h4><p>就像变量一样，对象也在声明为static时具有范围，知道程序的生命周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">Apple</span>() </span><br><span class="line">        &#123; </span><br><span class="line">            i = <span class="number">0</span>; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside Constructor\n&quot;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">Apple</span>() </span><br><span class="line">        &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside Destructor\n&quot;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        Apple obj; </span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>其中Apple()为构造函数，在对象创建时被调用，用于初始化对象的成员变量，分配资源等操作</li>
<li>~Apple()为析构函数，在对象被销毁时自动调用，用于清理对象使用的资源，释放内存等。</li>
<li>对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用</li>
</ul>
<p>如果改为了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">static</span> Apple obj; </span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>则析构函数的输出坏在main结束后调用析构函数。</p>
<h4><span id="类中的静态函数">类中的静态函数</span></h4><p>类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和 <code>.</code> 来调用静态用户函数。</p>
<p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，他们无法访问类的非静态数据成员或成员函数</p>
<hr>
<h2><span id="this-指针那些事">this 指针那些事</span></h2><p>python里的self类比到c++中就是this指针。</p>
<p>this 指针的用处：</p>
<ol>
<li>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(object)的结果</li>
<li>this作用域是在类内部，在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使没有写上this指针，编译器在编译时也是加上this的，他作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</li>
</ol>
<p>其次，使用如下：</p>
<ol>
<li>在类的非静态成员函数中返回类对象本身的时候，直接使用 <code>return *this</code></li>
<li>当参数与成员变量名相同时，如 <code>this-&gt;n = n</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">        BOY = <span class="number">0</span>, </span><br><span class="line">        GIRL </span><br><span class="line">    &#125;SexType;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">char</span> *n, <span class="type">int</span> a,SexType s)&#123;</span><br><span class="line">        name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name,n);</span><br><span class="line">        age=a;</span><br><span class="line">        sex=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">add_age</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        age+=a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    SexType sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">20</span>,Person::BOY)</span></span>; </span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">get_age</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">add_age</span>(<span class="number">10</span>).<span class="built_in">get_age</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在类中，与类名相同的函数是构造函数，例子中的Person(char *n, int a,SexType s)就是构造函数</li>
<li><code>&amp;</code>符号用于声明引用，它允许我们在不复制对象的情况下对对象进行操作。<code>p.add_age(10).get_age()</code>就是很好的例子</li>
<li><code>public</code>与 <code>private</code>是用于控制类成员访问权限的关键字<ul>
<li><code>public</code>意味着这些成员可以在类的外部和内部访问</li>
<li><code>private</code>的成员只能在类的内部访问</li>
</ul>
</li>
<li>通过断点查看，发现编译器会为我们的this指针自动加上 <code>A* const</code> 而不是 <code>A const *</code>，即指向A对象的常指针，这样限定了指针的地址无法变化。</li>
<li>如果是const函数，则会将this指针变为 <code>const A* const</code></li>
</ul>
<h2><span id="inline-那些事">inline 那些事</span></h2><h3><span id="类中关联">类中关联</span></h3><p>头文件中声明方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param x</span></span><br><span class="line"><span class="comment">     * @param y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">///&lt; 定义即隐式内联函数！</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">///&lt; 声明后，要想成为内联函数，必须在定义处加inline关键字。  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Foo()函数被声明在类内部，没有显示使用 <code>inline</code>关键字来修饰，这种情况下被视为隐式内联函数。</li>
<li>隐式内联函数与由<code>inline</code>声明的显示内联函数的区别在于编辑器是否强制内联函数的决定权。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @param y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">// 函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处加inline关键字，推荐这种写法！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::f1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">Foo</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译器对 inline 函数的处理步骤</span></span><br><span class="line"><span class="comment"> * 将 inline 函数体复制到 inline 函数调用点处；</span></span><br><span class="line"><span class="comment"> * 为所用 inline 函数中的局部变量分配内存空间；</span></span><br><span class="line"><span class="comment"> * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</span></span><br><span class="line"><span class="comment"> * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>内联能提高函数效率，但并不是所有函数都定义成内联函数！内联是以代码膨胀为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p>
<ul>
<li>如果执行函数内代码的时间相比于函数调用的开销较大，那么效率的收获会更少</li>
<li>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大， 消耗更多的内存空间。</li>
</ul>
<p>以下情况不宜用内联：</p>
<ul>
<li>如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高</li>
<li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>
<li>比较复杂的函数或者某些情况下（递归函数）可能无法内联展开</li>
</ul>
<blockquote>
<p>GOTO 是一种在编程中用于控制程序流程的语句，允许将程序跳转到指定的位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string userInput;</span><br><span class="line">    </span><br><span class="line">    start:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Do you want to continue? (yes/no): &quot;</span>;</span><br><span class="line">    cin &gt;&gt; userInput;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userInput == <span class="string">&quot;yes&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Continuing...\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 执行相关操作</span></span><br><span class="line">        <span class="keyword">goto</span> start; <span class="comment">// 跳转到标签 start 处</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userInput == <span class="string">&quot;no&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Exiting...\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid input. Please enter &#x27;yes&#x27; or &#x27;no&#x27;.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> start; <span class="comment">// 如果输入不是 &#x27;yes&#x27; 或 &#x27;no&#x27;，重新询问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用GOTO容易导致程序的逻辑难以理解和维护，实际编程中，尽量少使。。。</p>
<h2><span id="虚函数-virtual-可以是-内联函数-inline-吗">虚函数 virtual 可以是 内联函数 inline 吗？</span></h2><blockquote>
<p>虚函数 virtual function </p>
<p>是一种特殊的成员函数，它可以在派生类中被重写（覆盖）以提供特定于派生类的实现。虚函数通过在基类中使用关键字‘virtual’来声明，而在派生类中使用相同的函数签名来重写。</p>
<p>虚函数的存在使得在基类指针或引用指向派生类对象时，可以根据实际指向的对象类型来调用相应的函数实现，而不是根据指针或引用的静态类型来确定调用哪个函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;obj1;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Base class</span></span><br><span class="line"></span><br><span class="line">    ptr = &amp;obj2;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>虚函数可以是内联函数，内联时可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行调用哪个代码，因此虚函数表现为多态性时不可以内联</li>
<li><code>inline virtual</code>唯一可以内联的时候是：编译器知道所调用的是哪个类，这只有编译器具有实际对象而不是对象的指针或引用时才会发生</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2><span id="sizeof-那些事">Sizeof 那些事</span></h2><ul>
<li>空类的大小为1byte</li>
<li>一个class中，virtual function 、成员函数、静态数据成员都是不占用类对象的存储空间</li>
<li>对于包含虚函数的类，不管有多少虚函数，只有一个虚指针， vptr的大小</li>
<li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li>
<li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。32位 4byte; 64bit 8byte</li>
<li>虚继承，继承基类的vptr</li>
</ul>
<blockquote>
<p>具体的代码实例先不展示，对于密码学竞赛的帮助应该不是特别大</p>
</blockquote>
<h2><span id="纯虚函数和抽象类那些事">纯虚函数和抽象类那些事</span></h2><h3><span id="纯虚函数与抽象类">纯虚函数与抽象类</span></h3><p>C++中的纯虚函数或抽象函数是我们没有实现的虚函数，我们只需声明他。通过声明中赋值0来声明纯虚函数！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供了 draw() 的具体实现</span></span><br><span class="line">        <span class="comment">// 这里是绘制一个圆的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供了 draw() 的具体实现</span></span><br><span class="line">        <span class="comment">// 这里是绘制一个正方形的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中Shape是一个抽象类，draw()是一个纯虚函数，因此Shape不能被实例化，只能被用作派生类的基类</li>
<li>如果它的派生类不是抽象类，则必须提供纯虚函数的实现</li>
<li></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file pure_virtual.cpp</span></span><br><span class="line"><span class="comment"> * @brief 纯虚函数：没有函数体的虚函数</span></span><br><span class="line"><span class="comment"> * 抽象类：包含纯虚函数的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 1. 抽象类只能作为基类来派生新类使用</span></span><br><span class="line"><span class="comment">   * 2. 抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  A a; <span class="comment">// error 抽象类，不能创建对象</span></span><br><span class="line"></span><br><span class="line">  A *a1; <span class="comment">// ok 可以定义抽象类的指针</span></span><br><span class="line"></span><br><span class="line">  A *a2 = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// error, A是抽象类，不能创建对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="实现抽象类">实现抽象类</span></h3><p>抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。</p>
<p>如果一个类从抽象类派生而来，他必须实现了基类中的<strong>所有</strong>纯虚函数，才能成为非抽象类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file abstract.cpp</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * 抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数</span></span><br><span class="line"><span class="comment"> * 如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">f</span>(); &#125;</span><br><span class="line">  <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B:f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">g</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="重要点">重要点</span></h3><ul>
<li>纯虚函数使一个类变成抽象类</li>
<li>抽象类类型的指引和引用</li>
<li>如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类</li>
<li>抽象类可以有构造函数</li>
<li>构造函数不能是虚函数，而析构函数可以是虚析构函数</li>
</ul>
<p>当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。如果析构函数不是虚拟的，则只能调用基类析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file derived_full.cpp</span></span><br><span class="line"><span class="comment"> * @brief 完整示例！抽象类由派生类继承实现！</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun() called&quot;</span>; &#125; <span class="comment">// 实现了fun()函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  Derived d;</span><br><span class="line">  d.<span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="vptr与vtable那些事">Vptr与vtable那些事</span></h2><h3><span id="基础理论">基础理论</span></h3><p>为了实现虚函数，C++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表时用于解决在动态/后期绑定方法的函数调用函数的查找表。虚拟表有时会使用其他名称，例如’vtable’，’虚函数表’，’虚方法表’，’调度表’</p>
<p>虚拟表实际上非常简单，虽然用文字描述有点复杂。</p>
<p>首先，每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p>
<p>其次，编译器还会添加一个隐藏指向基类的指针，称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。</p>
<p>因此，它使每个类对象的分配大一个指针的大小。这意味着vptr由派生类继承。</p>
<h3><span id="实现与内部结构">实现与内部结构</span></h3><p>调用图：</p>
<p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231009203842470.png" alt="image-20231009203842470"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file vptr1.cpp</span></span><br><span class="line"><span class="comment"> * @brief C++虚函数vptr和vtable</span></span><br><span class="line"><span class="comment"> * 编译：g++ -g -o vptr vptr1.cpp -std=c++11</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 派生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Derived::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DerivedClass::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取vptr地址与func地址,vptr指向的是一块内存，这块内存存放的是虚函数地址，这块内存就是我们所说的虚表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> * @param offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Fun <span class="title">getAddr</span><span class="params">(<span class="type">void</span>* obj,<span class="type">unsigned</span> <span class="type">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">void</span>* vptr_addr = (<span class="type">void</span> *)*(<span class="type">unsigned</span> <span class="type">long</span> *)obj;  <span class="comment">//64位操作系统，占8字节，通过*(unsigned long *)obj取出前8字节，即vptr指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vptr_addr:%p\n&quot;</span>,vptr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通过vptr指针访问virtual table，因为虚表中每个元素(虚函数指针)在64位编译器下是8个字节，因此通过*(unsigned long *)vptr_addr取出前8字节，</span></span><br><span class="line"><span class="comment">     * 后面加上偏移量就是每个函数的地址！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>* func_addr = (<span class="type">void</span> *)*((<span class="type">unsigned</span> <span class="type">long</span> *)vptr_addr+offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func_addr:%p\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="keyword">return</span> (Fun)func_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base ptr;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pt = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类实例</span></span><br><span class="line">    Base &amp;pp = ptr; <span class="comment">// 基类引用指向基类实例</span></span><br><span class="line">    Base &amp;p = d; <span class="comment">// 基类引用指向派生类实例</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象直接调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ptr.<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象调用基类实例&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pp.<span class="built_in">fun1</span>(); </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类指针指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pt-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类引用指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动查找vptr 和 vtable</span></span><br><span class="line">    Fun f1 = <span class="built_in">getAddr</span>(pt, <span class="number">0</span>);</span><br><span class="line">    (*f1)();</span><br><span class="line">    Fun f2 = <span class="built_in">getAddr</span>(pt, <span class="number">1</span>);</span><br><span class="line">    (*f2)();</span><br><span class="line">    <span class="keyword">delete</span> pt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>纯虚函数与虚函数的区别</p>
<ol>
<li>定义：<ul>
<li>虚函数是在基类中声明并被定义的函数，它可以在派生类中被重写以提供特定于派生类的实现</li>
<li>纯虚函数是在基类中声明但没有提供具体实现的函数，它以 <code>=0</code>结尾，要求派生类必须提供自己的实现</li>
</ul>
</li>
<li>实现：<ul>
<li>虚函数在基类中可以有一个默认的实现，纯虚函数没有</li>
</ul>
</li>
<li>基类实例化：<ul>
<li>虚函数对应的基类可以实例化，纯虚函数的不可以</li>
</ul>
</li>
<li>派生类实现：<ul>
<li>虚函数可以选择是否在派生类中重写</li>
<li>纯虚函数必须重写，否则派生类也为抽象类</li>
</ul>
</li>
<li>多继承<ul>
<li>如果一个类继承自多个含有同名虚函数的基类，他将继承所有这些虚函数，但只有一个实现会被调用，具体实现哪个取决于编译器和程序的实际实现          </li>
<li>纯虚函数，如果一个类继承自多个含有同名纯虚函数的基类，它必须提供所有这些纯虚函数的实现</li>
</ul>
</li>
</ol>
</blockquote>
<p>函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*ptr)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 声明一个函数指针 ptr，该指针指向一个接受两个整数参数并返回整数的函数</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">基类对象直接调用</span><br><span class="line">Base::fun1()</span><br><span class="line">基类引用指向派生类实例</span><br><span class="line">Base::fun1()</span><br><span class="line">基类指针指向派生类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">基类引用指向基类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x401130</span><br><span class="line">func_addr:0x400ea8</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x401130</span><br><span class="line">func_addr:0x400ed4</span><br><span class="line">DerivedClass::fun2()</span><br></pre></td></tr></table></figure>
<p>c++的动态多态性使通过虚函数来实现的，通过virtual函数，指向子类的基类指针可以调用子类的函数。</p>
<p>过程解析：首先程序识别出fun1()是个虚函数，其次程序使用pt-&gt;vptr来获取Derived的虚拟表。第三，他查找Derived虚拟表中调用哪个版本的fun1()。</p>
<blockquote>
<p>gdb调试的方式要进行加强。</p>
</blockquote>
<h2><span id="virtual那些事">virtual那些事</span></h2><h3><span id="虚函数与运行多态">虚函数与运行多态</span></h3><p>虚函数的调用取决于指向或者引用的对象的类型，而不是指针或自身的类型。</p>
<h3><span id="虚函数中默认参数">虚函数中默认参数</span></h3><p>默认参数是静态绑定的，虚函数是动态绑定的，默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x = <span class="number">20</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    Base* ptr1 = &amp;obj1;</span><br><span class="line">    Base* ptr2 = &amp;obj2;</span><br><span class="line"></span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Base class: 10</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived class: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>override</code> 用于显式告诉编译器，某个成员函数是意图覆盖基类中的虚函数。</p>
</blockquote>
<ol>
<li><p>静态函数不可以声明为虚函数，同时也不能被const volatile关键字修饰</p>
<ul>
<li>static成员函数不属于任何类对象或类实例</li>
</ul>
</li>
<li><p>构造函数不可以声明为虚函数，除了inline explicit之外，构造函数不允许任何关键字</p>
</li>
<li><p>析构函数可以为虚函数</p>
<ul>
<li>如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。</li>
</ul>
</li>
<li><p>虚函数</p>
<blockquote>
<ol>
<li>基类和继承类的访问控制：<ul>
<li>基类和继承类的访问控制可以分为 <code>public</code>、 <code>protected</code> 、<code>private</code>。这些访问修饰符决定了类的成员对于类的外部的可见性。</li>
<li>如果将基类声明为 <code>public</code> 继承，派生类继承了基类的 <code>public</code>成员，但这些成员在派生类中的访问权限保持不变</li>
<li>如果将基类声明为 <code>private</code>继承，也同样</li>
</ul>
</li>
<li>友元函数：<ul>
<li>友元函数是一个不属于类的成员函数，但他可以访问该类的私有成员。通常情况下，友元函数会在类的外部进行声明</li>
<li>如果在 <code>base</code>类中声明 <code>int main()</code>为友元函数，那就意味着 <code>main</code>可以访问 <code>base</code>的私有成员</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>通过基类指针或者引用调用的虚函数不能被内联，实体对象</p>
</li>
</ol>
<h4><span id="未完待续">未完待续</span></h4><hr>
<h2><span id="volatile-那些事">volatile 那些事</span></h2><p>被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。这些可观测的副作用时由程序之外的因素决定的。</p>
<h3><span id="volatile应用">volatile应用</span></h3><h4><span id="未完待续">未完待续</span></h4><hr>
<h2><span id="assert-那些事">assert 那些事</span></h2><p>断言，是宏，而非函数。</p>
<p>assert作用是如果它的条件返回错误，则终止程序执行。</p>
<p>可以通过定义NDEBUG来关闭assert，但是需要在源代码的开头，include之前。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(<span class="type">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>
<h3><span id="断言与正常错误处理">断言与正常错误处理</span></h3><p>断言主要用于检查逻辑上不可能的情况。他们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用</p>
<p>在代码开头加上</p>
<blockquote>
<h1><span id="define-ndebug-加上这行则-assert-不可用">define NDEBUG   // 加上这行，则 assert 不可用</span></h1></blockquote>
<h2><span id="位域那些事">位域那些事</span></h2><p><code>bit field</code>是一种数据结构，可以把数据以位的形式紧凑的存储，并允许程序员对此结构的位进行操作。</p>
<p>优点：</p>
<ol>
<li>可以是数据单元节省储存空间</li>
<li>bit field 可以很方便的访问一个整数值的部分内容从而简化源代码。</li>
</ol>
<p>缺点：</p>
<ul>
<li>实现以来具体的机器和系统，本质上不可移植</li>
</ul>
<h4><span id="未完待续">未完待续</span></h4><hr>
<h2><span id="extern-那些事">extern 那些事</span></h2><blockquote>
<p>允许在同一作用域中的某个函数和运算符指定多个定义，分别成为函数重载和运算符重载</p>
</blockquote>
<p>在同一个作用域中，可以声明几个功能相似的同名函数，但是这些同名函数的<strong>形式参数必须不同</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="type">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字operator和其后要重载的运算符符号构成的。重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>
<p>大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果是非成员函数，则需要传递两个参数。</p>
<h3><span id="可重载运算符">可重载运算符</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231010230712173.png" alt="image-20231010230712173"></p>
<h3><span id="c调用c函数">C++调用C函数</span></h3><p>引用C的头文件时，需要加 <code>extern &quot;C&quot;</code></p>
<p>编译的时候要注意，先通过gcc将.c文件生成中间文件.o</p>
<p>然后通过g++进行编译</p>
<h3><span id="c中调用c">C中调用C++</span></h3><h4><span id="未完待续">未完待续</span></h4><hr>
<h2><span id="struct-那些事">struct 那些事</span></h2><h3><span id="c中的struct">C中的struct</span></h3><ul>
<li>C中struct只单纯的用作数据的复合类型，结构体声明中只能够将数据成员放在其中，而函数不能</li>
<li>C结构体声明中不能使用C++访问修饰符，public protected private</li>
<li>C的结构体不能继承</li>
<li>若结构体的名字与函数名相同，可以正常运行且正常的调用</li>
</ul>
<h3><span id="c中的struct">C++中的struct</span></h3><ul>
<li>可以定义数据与函数</li>
<li>可以使用修饰符</li>
<li>使用可以不带struct</li>
<li>c++继承</li>
<li>若结构体名字与函数名相同，可以正常运行且正常的调用，定义结构体变量时只用带struct的</li>
</ul>
<ol>
<li>使用typedef定义结构体别名时函数与别名不能相同</li>
<li></li>
</ol>
<h2><span id="实现多态那些事">实现多态那些事</span></h2><ul>
<li>封装：使用函数指针把属性和方法封装到结构体中</li>
</ul>
<h2><span id="explicit-那些事">explicit 那些事</span></h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4600295/what-is-the-meaning-of-operator-bool-const">https://stackoverflow.com/questions/4600295/what-is-the-meaning-of-operator-bool-const</a></p>
<h2><span id="friend那些事">friend那些事</span></h2><h2><span id="模板那些事">模板那些事</span></h2><blockquote>
<p>教程：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/70ca94872418">C++类模板，你看我就够了 - 简书 (jianshu.com)</a></p>
</blockquote>
<h3><span id="基础的类模板">基础的类模板</span></h3><p>类模板，可以定义相同的操作，拥有不同数据类型的成员属性。</p>
<p>通常使用 <code>template</code> 来声明，告诉编译器，碰到 <code>T</code> 不要报错，表示一种泛型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    Complex&lt;T&gt; <span class="keyword">operator</span>+(Complex &amp;c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a+c.a, <span class="keyword">this</span>-&gt;b+c.b)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对象的定义，必须声明模板类型，因为要分配内容</span></span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;  </span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    Complex&lt;<span class="type">int</span>&gt; c = a + b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Yan Zhimin 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yan Zhimin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.warmfire.com/2023/09/23/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" title="cpp学习日志">http://www.warmfire.com/2023/09/23/cpp学习日志/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag"># 编程语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" rel="prev" title="数据库第三周学习日志">
      <i class="fa fa-chevron-left"></i> 数据库第三周学习日志
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/23/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" rel="next" title="工科数学分析第二章——数列极限">
      工科数学分析第二章——数列极限 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  
  <div>
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  </div>
 



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81OTAxMy8zNTQ3NQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">基础进阶部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">const那些事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">static 那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.1.</span> <span class="nav-text">静态变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1 函数中的静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2 类中的静态变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.2.</span> <span class="nav-text">静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">类对象为静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">类中的静态函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">this 指针那些事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">inline 那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.4.1.</span> <span class="nav-text">类中关联</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.5.</span> <span class="nav-text">虚函数 virtual 可以是 内联函数 inline 吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.6.</span> <span class="nav-text">Sizeof 那些事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.7.</span> <span class="nav-text">纯虚函数和抽象类那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.7.1.</span> <span class="nav-text">纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.7.2.</span> <span class="nav-text">实现抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.7.3.</span> <span class="nav-text">重要点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.8.</span> <span class="nav-text">Vptr与vtable那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.8.1.</span> <span class="nav-text">基础理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.8.2.</span> <span class="nav-text">实现与内部结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.9.</span> <span class="nav-text">virtual那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.9.1.</span> <span class="nav-text">虚函数与运行多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.9.2.</span> <span class="nav-text">虚函数中默认参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">未完待续</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.10.</span> <span class="nav-text">volatile 那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.10.1.</span> <span class="nav-text">volatile应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">未完待续</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.11.</span> <span class="nav-text">assert 那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.11.1.</span> <span class="nav-text">断言与正常错误处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">define NDEBUG   &#x2F;&#x2F; 加上这行，则 assert 不可用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">位域那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">未完待续</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">extern 那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.1.</span> <span class="nav-text">可重载运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.2.</span> <span class="nav-text">C++调用C函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.3.</span> <span class="nav-text">C中调用C++</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">未完待续</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">struct 那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.3.1.</span> <span class="nav-text">C中的struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.3.2.</span> <span class="nav-text">C++中的struct</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.4.</span> <span class="nav-text">实现多态那些事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.5.</span> <span class="nav-text">explicit 那些事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.6.</span> <span class="nav-text">friend那些事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.7.</span> <span class="nav-text">模板那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.7.1.</span> <span class="nav-text">基础的类模板</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yan Zhimin"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yan Zhimin</p>
  <div class="site-description" itemprop="description">不忘初心，方得始终</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-09 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yan Zhimin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>