<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>WarmFire</title>
    <link>http://www.warmfire.com/</link>
    
    <atom:link href="http://www.warmfire.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>不忘初心，方得始终</description>
    <pubDate>Sat, 25 Nov 2023 09:42:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>数分第13周学习日志</title>
      <link>http://www.warmfire.com/2023/11/25/%E6%95%B0%E5%88%86%E7%AC%AC13%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
      <guid>http://www.warmfire.com/2023/11/25/%E6%95%B0%E5%88%86%E7%AC%AC13%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Sat, 25 Nov 2023 00:17:29 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;不定积分&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>不定积分</p><span id="more"></span><h2><span id="0x01-不定积分定义与基本性质">0x01 不定积分定义与基本性质</span></h2><h3><span id="不定积分的定义">不定积分的定义</span></h3><ul><li>定义：如果存在函数 $F(x),F’(x)=f(x),\forall x\in I,$则称 $F(x)$为 $f(x)$在集合I上原函数</li><li>定义：函数 $f(x)$在集合I上所有原函数，称为 $f(x)$在集合I上的不定积分。</li><li>$\int{f(x)dx}=F(x)+c$<ul><li>$\int$ 积分符号</li><li>$x$ 积分变量</li><li>$f(x)$ 被积函数</li><li>$f(x)dx$被积表达式</li></ul></li></ul><h3><span id="基本性质">基本性质</span></h3><ol><li>若函数 $f(x)$的原函数存在，则 $kf(x)$存在原函数，且有 $\int kfdx = k\int fdx, \forall k\in R$</li><li>若函数 $f(x)$和 $g(x)$的原函数存在，则 $f(x)\pm g(x)$存在原函数，且 $\int(f\pm g)dx=\int fdx+\int gdx$</li><li>$\frac{d}{dx}[\int f(x)dx]=f(x); d[\int f(x)dx]=f(x)dx;\int dF(x)=F(x)+c;$</li><li>微分运算与积分运算互逆</li></ol><h3><span id="积分表">积分表</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125100925999.png" alt="image-20231125100925999"></p><p>要注意 $\ln|x| $</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125100939645.png" alt="image-20231125100939645"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125100953784.png" alt="image-20231125100953784"></p><p>含有第一类间断点的函数没有原函数。</p><h2><span id="0x02-第一类换元公式及应用">0x02 第一类换元公式及应用</span></h2><h3><span id="换元公式">换元公式</span></h3><p>若 $f(u)$在区间I上有原函数 $F(u),\phi(x)$在J上可导，$\{u|u=\phi(x),\forall x\in J\}$，则 $F(\phi(x))$是 $f(\phi(x))\phi’(x)$在区间J上的原函数，即有：$\int f(\phi(x))\phi’(x)dx=\int f(u)du = F(u)+C = F(\phi(x))+C$</p><h3><span id="应用">应用</span></h3><h4><span id="积分表">积分表</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125113508778.png" alt="image-20231125113508778"></p><h2><span id="0x03-分部积分公式及应用">0x03 分部积分公式及应用</span></h2><ul><li>$(uv)’=u’v+uv’, uv’=(uv)’-u’v$</li><li>$\int u(x)v’(x)dx = u(x)v(x)-\int u’(x)v(x)dx$</li><li>$\int vdu$ easier than $\int udv$</li><li>有递推关系的可以设为 $I_n$</li><li>三角函数相关的部分很有可能有周期性</li></ul><h2><span id="0x04-第二类换元公式及应用">0x04 第二类换元公式及应用</span></h2><h3><span id="定义">定义</span></h3><ul><li>设 $x=\psi(t)$是在区间上J单调可导的函数，并且 $\psi’(t)\neq 0$，又 $f(\psi(t))\psi’(t)$在区间J上存在原函数，则在J上有换元公式 $\int f(x)dx = \int f(\psi(t))\psi’(t)dt|_{t=\psi^{-1}(x)}$，其中 $t=\psi^{-1}(x)$为 $x=\psi(t)$的反函数</li><li>第一类换元是将多项凑成一项合并，定义域没有变化，第二类换元是将被积函数进行变量替换分解，注意其自身定义域的变化</li><li>一定要根据定义域进行讨论</li><li>常用三角代换的方式，目的是化解其中的根式</li></ul><h3><span id="积分表">积分表</span></h3><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125145048519.png" alt="image-20231125145048519"></li></ul><p>当分母阶较高时，可以采用倒代换</p><h2><span id="0x05-有理函数及有理三角函数的不定积分">0x05 有理函数及有理三角函数的不定积分</span></h2><h3><span id="有理函数">有理函数</span></h3><ul><li>定义：形如 $R(x)=\frac{P(x)}{Q(x)}$的函数，称为有理函数，其中 $P(x),Q(x)$分别是多项式。</li><li>若 $P(x)$的次数大于 $Q(x)$的次数，R(x)为假分式，类比于假分数</li></ul><h3><span id="有理函数分解定理">有理函数分解定理</span></h3><p>设 $R(x)=\frac{P(x)}{Q(x)}$为一个真分式，分母有分解式 $Q(x)=(x-a)^{n_1}\cdots(x-b)^{n_k}(x^2+px+q)^{m_1}\cdots(x^2+rx+s)^{m_i}$，所有二次式没有实根。</p><ul><li>注1：$f(x)=(x-a)^kg(x),g(a)\neq 0$，则 $x=a$为f(x)的k重根</li><li>注2：$x=a$为k重根 $\Leftrightarrow f^{(i)}(a)=0,i=0,1\cdots,k-1, f^{(k)}(a)\neq 0$</li></ul><h3><span id="三角函数有理式">三角函数有理式</span></h3><p>利用万能公式转换为有理函数的形式</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125173828993.png" alt="image-20231125173828993"></p><h3><span id="无理根式的不定积分">无理根式的不定积分</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125174213069.png" alt="image-20231125174213069"></p><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/11/25/%E6%95%B0%E5%88%86%E7%AC%AC13%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CE Log</title>
      <link>http://www.warmfire.com/2023/11/22/CE-Log/</link>
      <guid>http://www.warmfire.com/2023/11/22/CE-Log/</guid>
      <pubDate>Wed, 22 Nov 2023 13:45:14 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;记录学习内容&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>记录学习内容</p><span id="more"></span><h2><span id="0x01-教程部分">0x01  教程部分</span></h2><h3><span id="步骤9注入">步骤9：注入++</span></h3><p>在分析结构的过程中要想明白，比如我们查找的血量，很有可能是一个结构体的实例的一个属性值，因此内存空间上其他属性的分布极有可能是连续的，因此直接分析改变值对应的地址很可能猜出来其结构</p><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/11/22/CE-Log/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>可证明安全第12周学习日志</title>
      <link>http://www.warmfire.com/2023/11/21/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
      <guid>http://www.warmfire.com/2023/11/21/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Tue, 21 Nov 2023 00:58:47 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;Message Authentication Code&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>Message Authentication Code</p><span id="more"></span><h2><span id="0x01-definition-and-security-of-mac">0x01  Definition and Security of MAC</span></h2><h3><span id="integrity">Integrity</span></h3><ul><li>ensuring that a received message originated from the intended party, and was not modified</li><li>even if an attacker controls the channel</li><li>use message authentication code</li></ul><h3><span id="definition-of-mac">Definition of MAC</span></h3><p>A message authentication code is defined by three PPT algorithms (Gen, Mac, Vrfy):</p><ul><li>Gen: takes as input $1^n$; outputs $k$. (Assume $|k|\geq n$)</li><li>Mac: takes as input key $k$ and message $m\in\{0,1\}^*$; outputs tag $t$, $t:= Mac_k(m)$</li><li>Vrfy: takes key $k$, message $m$, and tag $t$ as input; outputs 1 or 0</li></ul><h3><span id="security">Security</span></h3><h4><span id="threat-model">Threat model</span></h4><ul><li>adaptive chosen-message attack</li><li>assume the attacker can induce the sender to authenticate messages of the attacker’s choice</li></ul><h4><span id="security-goal">Security goal</span></h4><ul><li>existential unforgeability</li><li>attacker should be unable to forge a valid tag on any message not previously authenticated by the sender</li></ul><h3><span id="formal-definition">Formal Definition</span></h3><h4><span id="def-42-security-definition-of-mac">Def. 4.2 Security Definition of Mac</span></h4><ul><li>Fix $\mathcal{A},\Pi$</li><li>Define randomized experiment $Forge_{\mathcal{A},\Pi}(n)$:<ol><li>$k \leftarrow Gen(1^n)$</li><li>$\mathcal{A}$ interacts with an oracle $Mac_k(\cdot)$; let $\mathcal{Q}$ be the set of messages submitted to this oracle</li><li>$(m,t)\leftarrow \mathcal{A}$</li><li>$\mathcal{A}$ succeeds, and the experiment evaluates to 1,  if $Vrfy_k(m,t)=1$ and $m \not\in \mathcal{Q}$</li></ol></li><li>A message authentication code $\Pi = (Gen, Mac, Vrfy)$ is existentially unforgeable under an adaptive chosen-message attack if for all PPT attackers $\mathcal{A}$, there is a negligible function $\epsilon$ that $\Pr[Mac-Forge_{\mathcal{A},\Pi}=1]\leq \epsilon(n)$</li></ul><h3><span id="replay-attacks">Replay Attacks</span></h3><ul><li>no stateless mechanism can prevent them</li><li></li></ul><h2><span id="0x02-a-fixed-length-mac">0x02 A fixed-length MAC</span></h2><h3><span id="construction">Construction</span></h3><h4><span id="definition-46-secure-mac">Definition 4.6 Secure Mac</span></h4><ul><li>if F is a pseudomrandom function, then the above is a secure fixed-length MAC for message of length n.</li><li></li></ul><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/11/21/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数分第11周学习日志</title>
      <link>http://www.warmfire.com/2023/11/19/%E6%95%B0%E5%88%86%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
      <guid>http://www.warmfire.com/2023/11/19/%E6%95%B0%E5%88%86%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Sun, 19 Nov 2023 06:34:01 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;泰勒公式&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>泰勒公式</p><span id="more"></span><h2><span id="0x01-微分的定义与计算">0x01  微分的定义与计算</span></h2><h3><span id="1-微分的定义">1 微分的定义</span></h3><h4><span id="定义">定义</span></h4><p>设函数 $y=f(x)$定义在 $U(x_0;\delta),x_0+\Delta x\in (x_0;\delta)$，如果成立：$\Delta y=f(x_0+\Delta x)-f(x_0)=A\cdot\Delta x+o(\Delta x)$，其中A是与 $\Delta x$无关的常熟，则称函数在点 $x_0$可微，$A\cdot\Delta x$称为函数在该点相应于自变量增量的微分，记作：$dy|_{x=x_0}=A\cdot\Delta x, or \ df(x_0)=A\cdot\Delta x$</p><h4><span id="等价定义">等价定义</span></h4><p>$\Delta y = f(x_0+\Delta x)-f(x_0)=A\cdot\Delta x+o(\Delta x)$</p><ul><li>$f(x)-(f(x_0)+A(x-x_0))=o(x-x_0)$</li></ul><h4><span id="可微条件">可微条件</span></h4><ul><li>定理：函数 $f(x)$在点 $x_0$可微的充要条件是函数 $f(x)$在点 $x_0$可导，且 $A=f’(x_0)$</li><li>注1：函数 $f(x)$在 $\forall x\in U(x_0;\delta)$ 可微，记为 $dy \ or \ df(x),i.t. dy=f’(x)\Delta x$</li><li>注2：自变量x的增量 $\Delta x$视为自变量的微分</li></ul><h4><span id="运算法则">运算法则</span></h4><p>与求导的法则相似</p><h4><span id="高阶微分">高阶微分</span></h4><p>$dx^n=(dx)^n,f^{(n)}(x)=\frac{d^nf(x)}{dx^n}$</p><h4><span id="微分形式的不变性">微分形式的不变性</span></h4><p>复合函数二阶微分不变，高阶变</p><h2><span id="0x02-微分的计算">0x02 微分的计算</span></h2><h3><span id="1-基本初等函数的微分公式">1 基本初等函数的微分公式</span></h3><p>与求导相似，带了一个 $dx$</p><h3><span id="应用近似公式">应用：近似公式</span></h3><h2><span id="0x03-带有peano余项的泰勒公式">0x03 带有Peano余项的泰勒公式</span></h2><h3><span id="1-带有peano余项的泰勒公式证明">1 带有Peano余项的泰勒公式证明</span></h3><h3><span id="2-带有peano余项的泰勒公式">2 带有Peano余项的泰勒公式</span></h3><p>$f(x)=p_n(x)+o[(x-x_0)^n]$ —- ①</p><p>$p_n(x)=\sum^n_{k=0}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k$</p><p>当 $x_0=0$，称为麦克劳林公式</p><h3><span id="3-常用函数展开">3 常用函数展开</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222204635.png" alt="image-20231119222204635"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222218627.png" alt="image-20231119222218627"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222437511.png" alt="image-20231119222437511"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222501948.png" alt="image-20231119222501948"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222644899.png" alt="image-20231119222644899"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222659182.png" alt="image-20231119222659182"></p><h2><span id="0x04-带拉格朗日余项的泰勒公式">0x04 带拉格朗日余项的泰勒公式</span></h2><p>利用Cauchy中值定理进行证明余项原因</p><h3><span id="公式表示">公式表示</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225543780.png" alt="image-20231119225543780"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225619413.png" alt="image-20231119225619413"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225626803.png" alt="image-20231119225626803"></p><h3><span id="常用函数">常用函数</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225652984.png" alt="image-20231119225652984"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225716179.png" alt="image-20231119225716179"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225804737.png" alt="image-20231119225804737"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225901342.png" alt="image-20231119225901342"></p><h3><span id="应用">应用</span></h3><h4><span id="1-极值问题">1 极值问题</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231120085838499.png" alt="image-20231120085838499"></p><h4><span id="2-求函数极限">2 求函数极限</span></h4><p>用多项式替换复杂函数</p><h3><span id="典型例题">典型例题</span></h3><p>两种余项定理条件不同，一个n阶导，一个n+1阶导</p><p>Taylor公式可以将函数与其导函数联系到一起</p><p>多利用奇偶性的不同来实现除去特定项</p><h2><span id="提高课">提高课</span></h2><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/11/19/%E6%95%B0%E5%88%86%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库第12周学习日志</title>
      <link>http://www.warmfire.com/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
      <guid>http://www.warmfire.com/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Fri, 17 Nov 2023 03:28:32 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;关系数据库理论&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>关系数据库理论</p><span id="more"></span><h2><span id="0x01-问题的提出">0x01  问题的提出</span></h2><ul><li><p>把关系模式看作一个三元组 $R<u,f>$</u,f></p></li><li><p>作为一个二维表，关系要符合一个最基本的条件：</p><ul><li><p>每个分量必须是不可分的数据项</p></li><li><p>满足了这个条件的关系模式属于<strong>第一范式（1NF）</strong></p></li></ul></li><li><p>数据依赖</p><ul><li>一个关系内部属性之间的一种约束关系</li><li>数据内在的性质，语义的体现</li><li>设计关系模式时，除给出属性全集外，还需给出数据依赖集合</li><li>分为两类：函数依赖（FD）、多值依赖（MVD）</li></ul></li><li><p>$R(U,F)$中存在的问题</p><ul><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常</li><li>原因：模式中某些数据依赖引起的</li><li>解决：用规范化理论改造关系模式消除其中不合适的数据依赖</li><li></li></ul></li></ul><h2><span id="0x02-规范化">0x02 规范化</span></h2><h3><span id="1-函数依赖">1 函数依赖</span></h3><h4><span id="函数依赖">函数依赖</span></h4><ul><li>定义：设 $R(U)$时一个属性集U上的关系模式，$X,Y$是U的子集。若对于 $R(U)$的<strong>任意一个可能关系r</strong>，r中不可能<strong>存在两个元组</strong>在X上的属性值相等，而在Y上的属性值不等，则称 <code>X函数确定Y</code>或 <code>Y函数依赖于X</code>，记作 $X\rightarrow Y$</li><li>$X\rightarrow Y,Y\rightarrow X \Longrightarrow X \leftarrow\rightarrow Y$</li><li>若Y不函数依赖于X，则记为 $X\not\rightarrow Y$</li><li>函数依赖是R的所有关系实例均要满足的约束条件</li><li>语义概念，只能根据数据的语义来确定一个函数依赖</li><li>本质上是对属性间取值的一种约束，是一种数据依赖，是问题域业务规则的体现</li></ul><h4><span id="平凡函数依赖与非平凡函数依赖">平凡函数依赖与非平凡函数依赖</span></h4><ul><li>$X\rightarrow Y , but\ Y \not\subseteq X,then \ X\rightarrow Y$是非平凡的函数依赖</li><li>$X\rightarrow Y , and\ Y \subseteq X,then \ X\rightarrow Y$是平凡的函数依赖</li><li>平凡函数依赖必然成立</li><li>$X\rightarrow Y$，则称X为这个函数依赖的决定因素</li></ul><h4><span id="完全函数依赖与部分函数依赖">完全函数依赖与部分函数依赖</span></h4><ul><li>在 $R(U)$中，如果 $X\rightarrow Y$，并且对于X的任何一个真子集 $X’$，都有 $X’\not\rightarrow Y$，则称Y对X完全函数依赖，记作 $X\overset{F}{\rightarrow}Y$</li><li>若 $X\rightarrow Y$​，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作$X\overset{P}{\rightarrow}Y$</li></ul><h4><span id="传递函数依赖">传递函数依赖</span></h4><ul><li>定义：在 $R(U)$中，如果 $X\rightarrow Y , Y \not\subseteq X,Y\not{\rightarrow}X, Y\rightarrow Z , Z \not\subseteq Y$，则称Z对X传递函数依赖，记为 $X\overset{传递}{\rightarrow}Z$</li><li>如果 $Y\rightarrow X$则Z直接依赖于X，而不是传递依赖</li><li>存在非受控冗余</li></ul><h3><span id="2-码键">2 码/键</span></h3><ul><li>定义：设K为 $R<u,f>$中的属性或属性组合，若 $K\overset{F}{\rightarrow}U$，则K称为R的一个候选键/码</u,f></li><li>部分依赖则成为超键</li><li>候选键是最小的超码</li><li>多个候选码选定一个为主码</li><li>定义：关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则X是R的外部码</li><li>定义：对于满足一组函数依赖F的关系模式 $R<u,f>$，其中任何一个关系r，若函数依赖 $X\rightarrow Y$成立，则称F逻辑蕴涵 $X\rightarrow Y$</u,f></li><li>Armstrong公理系统<ul><li>设<em>U</em>为属性集总体，<em>F</em>是<em>U</em>上的一组函数依赖， 于是有关系模式<em>R</em> &lt;<em>U</em>,<em>F</em> &gt;。对<em>R</em> &lt;<em>U</em>,<em>F</em>&gt; 来说有以下的推理规则：</li><li>A1 自反律：若 $Y\subseteq X\subseteq U$，则F逻辑蕴涵 $X\rightarrow Y$</li><li>A2 增广律：若 F逻辑蕴涵 $X\rightarrow Y$，且 $Z\subseteq U$，则F逻辑蕴涵 $XZ\rightarrow YZ$</li><li>A3 传递律：若F逻辑蕴涵 $X\rightarrow Y$与$Y\rightarrow Z$，则F逻辑蕴涵 $X\rightarrow Z$</li><li>三条推理规则：<ul><li>合并规则：由<em>X</em>→<em>Y</em>，<em>X</em>→<em>Z</em>，有<em>X</em>→<em>YZ</em>。</li><li>伪传递规则：由<em>X</em>→<em>Y</em>，<em>WY</em>→<em>Z</em>，有<em>XW</em>→<em>Z</em>。</li><li>分解规则：$X\rightarrow Y, Z\subseteq Y$,有 $X\rightarrow Z$</li></ul></li></ul></li></ul><h3><span id="3-范式-nf">3 范式 NF</span></h3><ul><li>符合某一种级别的关系模式的集合</li><li>种类<ul><li>第一范式(1NF)</li><li>第二范式(2NF)</li><li>第三范式(3NF)</li><li>BC范式(BCNF)</li><li>第四范式(4NF)</li><li>第五范式(5NF)</li></ul></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231117152439523.png" alt="image-20231117152439523"></li><li>一个低一级范式的关系模式，通过模式分解，可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化</li></ul><h3><span id="4-2nf">4 2NF</span></h3><ul><li>定义：若关系模式 $R\in 1NF$，且每个非主属性都完全函数依赖于任何一个候选码，则 $R\in2NF$</li><li>关系模式不属于2NF，会产生以下问题：<ul><li>插入异常</li><li>删除异常</li><li>修改复杂</li></ul></li><li>解决的是非主属性对复合主键的部份依赖</li><li>单一候选键一定符合</li></ul><h3><span id="5-3nf">5 3NF</span></h3><ul><li>定义：设关系模式 $R<u,f>\in 1NF$，若R中不存在这样的码X、属性组Y及非主属性Z $(Z\not\subseteq Y),s.t. \ X\rightarrow Y , Y\rightarrow Z$成立，$Y\not\rightarrow X$，则称 $R<u,f>\in 3NF$</u,f></u,f></li><li>即不存在传递依赖</li><li>3NF通常解决的是非主属性之间的依赖关系，非主属性对候选键的传递依赖。</li><li>属性组Y可能包括部分主属性、非主属性、或二者组合</li></ul><h3><span id="6-bcnf">6 BCNF</span></h3><ul><li>设关系模式 $R<u,f>\in1NF$，若 $X\rightarrow Y \ and \ Y\not\subseteq X$时X必含有码，则 $R<u,f>\in BCNF$</u,f></u,f></li><li>每一个决定属性集都包含候选码</li><li>解决了主属性组（但不构成候选键）对候选键的部分或者传递依赖关系</li><li>即除了所有属性（组）对候选键的依赖关系之外，没有任何其他的依赖关系</li><li>总结：<ul><li>2NF解决非主属性对候选键的部分依赖</li><li>3NF解决非主属性对候选键的传递依赖</li><li>BCNF解决主属性对候选键的部分或传递依赖</li><li></li></ul></li></ul><h3><span id="7-多值依赖">7 多值依赖</span></h3><ul><li>定义：MVD 设 $R(U)$是属性集U上的一个关系模式。<em>X，Y，Z</em>是U的子集，且 $Z=U-X-Y$。关系模式<em>R(U)</em>中多值依赖 $X\rightarrow\rightarrow Y$成立，当且仅当对<em>R(U)</em>的任意关系r，给定的一对 $(x,z)$值，有一组Y的值，仅仅决定于x值而与z值无关</li><li>Y和Z相互独立</li><li>平凡多值依赖：Z为空的情况</li><li>性质：<ul><li>对称性：即若X→→Y，则X→→Z，其中Z＝U－X－Y</li><li>传递性：即若X→→Y，Y→→Z， 则X→→Z -Y。</li><li>函数依赖是多值依赖的特例：即若X→Y，则 X→→Y。</li><li>若X→→Y，X→→Z，则X→→YZ。</li><li>若X→→Y，X→→Z，则X→→Y∩Z。</li><li>若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y。</li></ul></li></ul><h3><span id="8-4nf">8 4NF</span></h3><ul><li>定义：设关系模式 $R<u,f>\in1NF$，若 对于R的每个非平凡多值依赖 $X\rightarrow\rightarrow Y$ 时X都含有码，则 $R<u,f>\in 4NF$</u,f></u,f></li><li>性质：<ul><li>不允许有非平凡且非函数依赖的多值依赖</li><li>允许的非平凡多值依赖实际是函数依赖</li><li>平凡的多值依赖属于第四范式</li><li>4NF $\rightarrow$ BCNF</li></ul></li></ul><h2><span id="0x03-数据依赖的公理系统">0x03 数据依赖的公理系统</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库第11周学习日志</title>
      <link>http://www.warmfire.com/2023/11/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
      <guid>http://www.warmfire.com/2023/11/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Thu, 16 Nov 2023 12:55:32 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;数据库完整性&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>数据库完整性</p><span id="more"></span><h2><span id="0x01-实体完整性">0x01  实体完整性</span></h2><h3><span id="1-实体完整性定义">1 实体完整性定义</span></h3><h4><span id="关系模型的实体完整性">关系模型的实体完整性</span></h4><ul><li>CREATE TABLE 用 PRIMARY KEY定义</li></ul><h4><span id="单属性构成的主键有两种说明方法">单属性构成的主键有两种说明方法</span></h4><ul><li>定义为列级约束条件</li><li>定义为表级约束条件</li></ul><h4><span id="对多个属性构成的主键只有一个说明方法">对多个属性构成的主键只有一个说明方法</span></h4><ul><li>定义为表级约束条件</li></ul><h3><span id="2-实体完整性检查和违约处理">2 实体完整性检查和违约处理</span></h3><p>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查</p><ul><li>检查主码值是否唯一<ul><li>全表扫描：耗时</li><li>RDBMS在主码上自动建立一个索引</li></ul></li><li>检查主码的各个属性是否为空</li></ul><h2><span id="0x02-参照完整性">0x02 参照完整性</span></h2><h3><span id="1-参照完整性定义">1 参照完整性定义</span></h3><ul><li>用FOREIGN KEY定义外码</li><li>用REFERENCES指明外码参照哪些表的主码</li></ul><h3><span id="2-参照完整性检查和违约处理">2 参照完整性检查和违约处理</span></h3><ul><li><p>将两个表中的相应元组联系起来</p></li><li><p>两个表的增删改都有可能破坏参照完整性，必须进行检查</p></li><li></li><li><p>| <strong>被参照表（例如Student</strong>） | 参照表（例如SC）   | <strong>违约处理</strong>             |<br>| —————————————- | ————————— | ———————————— |<br>| 可能破坏参照完整性          | 插入元组           | 拒绝                     |<br>| 可能破坏参照完整性          | 修改外码值         | 拒绝                     |<br>| 删除元组                    | 可能破坏参照完整性 | 拒绝/级连删除/设置为空值 |<br>| 修改主码值                  | 可能破坏参照完整性 | 拒绝/级连修改/设置为空值 |</p></li></ul><ol><li>拒绝执行 NO ACTION：默认策略</li><li>级联操作 CASCADE：</li><li>设置为空值 SET NULL：</li></ol><ul><li>除了定义外码，还应该定义外码列是否允许空值</li></ul><h2><span id="0x03-用户定义的完整性">0x03 用户定义的完整性</span></h2><ul><li>针对某一具体应用的数据必须满足的语义要求</li></ul><h3><span id="1-属性上的约束条件">1 属性上的约束条件</span></h3><h4><span id="属性上约束条件的定义">属性上约束条件的定义</span></h4><ul><li>列值非空 NOT NULL</li><li>列值唯一 UNIQUE</li><li>检查列值是否满足一个条件表达式 CHECK</li></ul><h4><span id="属性上的约束条件检查和违约处理">属性上的约束条件检查和违约处理</span></h4><ul><li>约束条件RDBMS自动检查</li><li>不满足则拒绝执行</li></ul><h3><span id="2-元组上的约束条件">2 元组上的约束条件</span></h3><h4><span id="元组上约束条件的定义">元组上约束条件的定义</span></h4><ul><li>CHECK短语定义元组上的约束条件，元组级的限制</li><li>元组级限制可以设置不同属性之间的取值的相互约束条件</li></ul><h4><span id="元组上的约束条件检查和违约处理">元组上的约束条件检查和违约处理</span></h4><ul><li>约束条件RDBMS自动检查</li><li>不满足则拒绝执行</li></ul><h2><span id="0x04-完整性约束命名子句">0x04 完整性约束命名子句</span></h2><h3><span id="1-完整性约束命名子句">1 完整性约束命名子句</span></h3><p>CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</p><h3><span id="2-修改表中的完整性限制">2 修改表中的完整性限制</span></h3><p>使用 ALTER TABLE语句修改表中的完整性限制</p><h2><span id="0x05-域中的完整性限制">0x05 域中的完整性限制</span></h2><h2><span id="0x06-断言">0x06 断言</span></h2><ul><li>SQL中，使用CREATE ASSERTION 语句，通过声明性断言来指定更具一般性的约束</li><li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束</li><li>任何对断言所涉及的关系的操作都会触发DDBMS的检查，断言不为真值的操作会被拒绝。</li></ul><h3><span id="1-创建断言的语句格式">1 创建断言的语句格式</span></h3><p>CREATE ASSERTION &lt;断言名&gt; <check 子句></check></p><h3><span id="2-删除断言的语句格式">2 删除断言的语句格式</span></h3><p>DROP ASSERTION &lt;断言名&gt;</p><h2><span id="0x07-触发器">0x07 触发器</span></h2><ul><li>触发器 Trigger 是用户定义在关系表上的一类由事件驱动的特殊过程</li><li>触发器保存在数据库服务器中</li><li>任何增删改操作均由服务器自动激活相应的触发器</li></ul><h3><span id="1-定义触发器">1 定义触发器</span></h3><p>CREATE TRIGGER <trigger_name></trigger_name></p><p>{BEFORE| AFTER} <trigger_event> ON <table_name></table_name></trigger_event></p><p>REFERENCES NEW|OLD ROW AS <variables></variables></p><p>FOR EACH {ROW| STATEMENT}</p><p>[WHEN <trigger_condition>] <trigger_action></trigger_action></trigger_condition></p><ul><li>表的拥有者才可以在表上创建触发器</li><li>触发器名<ul><li>可以包含模式名，也可以不包含模式名</li><li>同一模式下，触发器名必须唯一</li><li>触发器名和表名必须在统一模式下</li></ul></li><li>表名<ul><li>触发器只能定义在基本表上，不能定义在视图上</li></ul></li><li>触发事件<ul><li>INSERT\DELETE\UPDATE</li><li>UPDATE OF {COLUMN}来限制具体某一列</li></ul></li><li>触发器类型<ul><li>行级    FOR EACH ROW</li><li>语句级  FOR EACH STATEMENT </li></ul></li><li>触发条件：condition为真</li><li>触发行动体：如果为行级触发器，可以使用new或old</li></ul><h3><span id="2-激活触发器">2 激活触发器</span></h3><ul><li>由触发事件激活</li><li>可能定义多个触发器，顺序：<ol><li>执行BEFORE触发器</li><li>激活触发器的SQL语句</li><li>执行AFTER触发器</li></ol></li></ul><h3><span id="3-删除触发器">3 删除触发器</span></h3><ul><li>DROP TRIGGER <trigger_name> ON <table_name></table_name></trigger_name></li><li></li></ul><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/11/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Database Manual</title>
      <link>http://www.warmfire.com/2023/11/13/Database-Manual/</link>
      <guid>http://www.warmfire.com/2023/11/13/Database-Manual/</guid>
      <pubDate>Mon, 13 Nov 2023 01:34:40 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;记录数据库知识手册，涉及到&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>记录数据库知识手册，涉及到</p><span id="more"></span><h2><span id="0x01-关系数据库理论">0x01  关系数据库理论</span></h2><h3><span id="1-关系数据结构及形式化定义">1 关系数据结构及形式化定义</span></h3><ol><li>关系<ul><li>组成：同一类实体型的实例集合；</li><li>联系：实体之间，实体属性之间存在某种关联关系</li><li>域：相同数据类型的值的集合（有限且不重复）</li><li>笛卡尔积：允许某些域是相同的<ul><li>笛卡尔积中每个元素是一个n元组</li><li>元组中每个值叫做一个分量</li><li>基数：集合中包含元素的个数</li></ul></li><li>关系：笛卡尔积的子集叫做在域 $D_1,D_2,\cdots,D_n$上的关系，表示为 $R(D_1,D_2,\cdots,D_n)$<ul><li>n也称目或度，R为关系名</li><li>n=1：单元关系，n=2：二元关系</li><li>超键：属性集合能够在关系中唯一标识元组<ul><li>候选键/码 Candidate key：某一属性组的值能唯一标识一个元组<ul><li>属性组是几个属性的集合</li><li>最小超键</li><li>主码/主键：一个关系中有多个候选码，选定其中一个为主码<ul><li>外键：一个实体的主键被另外一个实体使用，以表达不同实体元组之间的关系（这里面的实体可以理解为一个关系）</li><li>二者区别：</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113113200209.png" alt="image-20231113113200209"></li><li>实体之间的关系依赖主键-外键关联实现<ul><li>1对1，1对多</li><li>多对多可能存在数据冗余以及追溯父节点的难以区分</li><li>ER图的学习：<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113112439396.png" alt="image-20231113112439396"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113112802826.png" alt="image-20231113112802826"></li></ul></li></ul></li></ul></li><li>主属性：候选码中的所有属性，其余的属性称为非主属性</li></ul></li><li>全码/键 All-key：关系模式的所有属性组是这个关系模式的候选码</li></ul></li></ul></li><li>三类关系<ol><li>基本关系 （基本表或基表）</li><li>查询表</li><li>视图表</li></ol></li><li>基本关系的性质<ol><li>列同质：分量来自同一域</li><li>不同列可以出自同一域</li><li>行、列次序可交换</li><li>任意两个元组候选码不能相同</li><li>分量必须是原子值<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113114048546.png" alt="image-20231113114048546"></li></ul></li></ol></li></ul></li><li>关系模式<ul><li>型 Type，结构</li><li>R(U, D, DOM, F) 可以简记为 R(U)<ul><li>R        关系名</li><li>U        组成该关系的属性名集合</li><li>D        U中属性所来自的域</li><li>DOM   属性向域的映象集合</li><li>F        属性间数据的依赖关系的集合</li></ul></li></ul></li><li>关系数据库<ul><li>所有关系的集合构成一个关系数据库</li><li>型：关系数据库模式 schema</li><li>值：关系集合</li></ul></li><li>关系模型的存储结构</li></ol><h3><span id="2-关系操作">2 关系操作</span></h3><blockquote><p>引入记号：</p><p>设关系为 $R(A_1,A_2,\cdots,A_n)$，$t\in R$，</p><ol><li>$t[A_i]$表示元组 $t$中对应属性 $A_i$的一个分量</li><li>若 $A=\{A_{i_1},\cdots,A_{i_k}\}$，则 $t[A]$表示元组t相应分量的集合，$\bar{A}$表示除去A中属性后剩余的属性组</li><li>$\overset{\frown}{t_rt_s}$ 元组连接，列数变为m+n列，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</li></ol><p>设关系为 $R(X,Z)$</p><ol><li>象集 $Z_x=\{t[Z]|t\in R, t[X]=x\}$</li></ol></blockquote><ul><li><p>查询操作：</p><ol><li>选择 $\sigma$<ul><li>$\sigma_F(R)=\{t|t\in R \and F(t)=True\}$</li><li>$F:X_1\theta X_2$， $\theta$可以是比较运算符</li><li>行的角度进行</li><li>优先级：$\{(),\theta,\neg,\and,\or\}$</li></ul></li><li>投影 $\pi$<ul><li>$\pi_A(R)=\{t[A]|t\in R\}$</li><li>列的角度进行，会避免重复行</li></ul></li><li>连接 $\bowtie$<ul><li>$R\underset{A\theta B}{\bowtie} S= \{\overset{\frown}{t_rt_s}|t_r\in R \and t_s\in S \and t_r[A] \theta t_s[B] \}$</li><li>常用连接运算：<ul><li>等值连接 $A\theta B:A=B$</li><li>自然连接 Natural join $R\bowtie S=\{\overset{\frown}{t_rt_s}[U-B]|t_r\in R \and t_s\in S \and t_r[B]=t_s[B]\}$ <ul><li>U是全体属性集合，B是R和S具有的相同的属性组</li><li>行列角度进行运算，取消重复列</li><li>悬浮元组：做自然连接时，关系R中某些元组可能在S中不存在公共属性上值相等的元组</li><li>外连接：将悬浮元组保存在结果关系中，其他属性上填空值<ul><li>左外连接：保留左边关系</li><li>右外连接：保留右边关系</li></ul></li></ul></li></ul></li></ul></li><li>除 $\div$<ul><li>$R\div S=\{t_r[X]|t_r\in R \and \pi_Y(S)\subset Y_x  \},x=t_r[X]$</li><li>一般的 $\pi_y(S)\subset \pi_y(R)$成立</li><li>行列进行操作</li><li><code>查询...至少/全部的/所有的...</code>问题</li><li>$R\div S=\pi_X(R)-\pi_X(\pi_X(R)\times\pi_y(S)-R)$</li></ul></li><li>并 $\cup$<ul><li>具有相同的目，相应的属性取自同一域</li><li>结果不允许重复</li></ul></li><li>差 $-$<ul><li>具有相同的目，相应的属性取自同一域</li><li>$R-S$结果为属于R但不属于S的元组构成</li></ul></li><li>交 $\cap$<ul><li>具有相同的目，相应的属性取自同一域</li></ul></li><li>笛卡尔积 $\times$<ul><li>$R \times S$<ul><li>$R$：n目关系，$k_1$个元组</li><li>$S$：m目关系，$k_2$个元组</li><li>结果为 $m+n$列，$k_1\times k_2$行</li></ul></li></ul></li></ol><ul><li>并、差、笛卡尔积、投影、选择为五种基本运算</li></ul></li><li><p>数据更新</p><ol><li>插入</li><li>删除</li><li>修改</li></ol></li><li><p>关系操作的对象和结果均是集合</p></li><li><p>关系数据库语言有两类</p><ol><li>关系代数语言：关系运算来表达查询要求，对关系代数表达式求值</li><li>关系演算语言：用为此来表达查询要求</li></ol><ul><li>SQL具有关系代数和关系演算的双重特点</li></ul></li></ul><h3><span id="3-关系的完整性">3 关系的完整性</span></h3><ul><li><p>三类完整性约束</p><ol><li>实体完整性<ul><li>主属性不能取空值</li><li>NULL是不知道或不存在或无意义或不适用的值<ul><li>NULL不能参与算数、比较或逻辑运算</li></ul></li></ul></li><li>参照完整性<ul><li>引用其他关系的主键作为外键F的关系R称为参照关系，被引用主键对应的关系S称为被参照关系或目标关系</li><li>R与S不一定是不同的关系</li><li>主码外码必须在同一个域上，但不一定要同名</li><li>参照关系中的外码值要么等于被参照关系的主码值，要么为空值（F的每个属性值均为空值）</li><li>关系数据库不支持m:n联系，因为会造成大量的数据冗余，不符合数据库设计的基本要求</li></ul></li><li>用户定义的完整性<ul><li>满足具体的语义要求</li></ul></li></ol><ul><li>1，2合称关系的两个不变性</li></ul></li></ul><h3><span id="4-关系代数">4 关系代数</span></h3><ul><li><p>抽象的查询语言，关系代数的运算符有两类</p><ol><li>集合运算符</li><li>专门的关系运算符</li></ol><ul><li>集合运算符涉及到关系的行，专门的关系运算涉及到行与列</li></ul></li></ul><h2><span id="0x02-关系数据库语言-sql">0x02 关系数据库语言 SQL</span></h2><ul><li><p>特点</p><ol><li><p>综合统一</p><ul><li><p>数据定义语言 DDL    Create/Alter/Drop</p><ul><li><p>模式定义/删除 <code>CREATE SCHEMA</code> <code>DROP SCHEMA</code></p><ul><li>定义结构和命名空间</li><li>RDBMS提供了一个层次化的数据库对象命名机制<ul><li>一个RDBMS的实例 Instance 中可以建立多个数据库</li><li>一个数据库中可以建立多个模式</li><li>一个模式下通常包括多个表、视图和索引等数据库对象</li></ul></li><li><code>CREATE SCHEMA &lt;SCHEMA_NAME&gt; AUTHORIZATION &lt;USER&gt;</code></li><li><code>DROP SCHEMA &lt;SCHEMA_NAME&gt; &lt;CASCADE|RESTRICT&gt;</code><ul><li><code>CASCADE</code> 级联，删除模式中所有数据库对象</li><li><code>RESTRICT</code> 限制，如果模式中定义了下属的数据库对象，则拒绝该删除语句的执行</li></ul></li><li>在Mysql中，Schema与Database是等价的概念。</li><li>在Oracle中，Database和Instance是一对一关系。Database值服务器上所有数据文件、日志文件的综合，Instance值运行在服务器的一组后台进程。Schema是指某个User名下所有数据库对象的综合，而不是一个独立存在的实体，相当于数据库对象的命名空间，与UserName等价。</li></ul></li><li><p>表定义/删除/修改 <code>CREATE TABLE</code> <code>DROP TABLE</code> <code>ALTER TABLE</code></p><ul><li><p>CREATE TABLE &lt;表名&gt;</p><p>   (&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]</p><p>   [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] </p><p>   …</p><pre><code>[,&lt;表级完整性约束条件&gt; ] );</code></pre></li><li><p>外键设置： <code>FOREIGN KEY(XXX) REFEREENCES TABLE_XXX(XXX)</code></p></li><li><p>主键设置：<code>PRIMARY KEY</code></p></li><li><p>唯一值约束：<code>UNIQUE</code></p></li><li></li><li><p>| <strong>数据类型</strong>                      | <strong>含 义</strong>                                                    |<br>| ————————————————- | —————————————————————————————— |<br>| CHAR(<em>n</em>),CHARACTER(<em>n</em>)          | 长度为n的定长字符串  （字节计数，自动补齐空格）              |<br>| VARCHAR(<em>n</em>)                      | 最大长度为n的变长字符串  （字节计数）                        |<br>| CLOB                              | 字符串大对象  (character  large object)                      |<br>| BLOB                              | 二进制大对象(binary  large object)                           |<br>| INT，INTEGER                      | 整数（4字节）                                                |<br>| SMALLINT                          | 短整数（2字节）                                              |<br>| BIGINT                            | 长整数（8字节）                                              |<br>| NUMERIC(<em>p</em>，<em>d</em>)                 | 定点数，由<em>p</em>位数字（不包括符号、小数点）组成，小数后面有<em>d</em>位数字  —看起来p是小数点前，d是小数点后 |<br>| DECIMAL(<em>p</em>, <em>d</em>),  DEC(<em>p</em>, <em>d</em>) | 同NUMERIC                                                    |<br>| REAL                              | 取决于机器精度的单精度浮点数                                 |<br>| DOUBLE PRECISION                  | 取决于机器精度的双精度浮点数                                 |<br>| FLOAT(<em>n</em>)                        | 可选精度的浮点数，精度至少为<em>n</em>位数字                        |<br>| BOOLEAN                           | 逻辑布尔量                                                   |<br>| DATE                              | 日期，包含年、月、日，格式为YYYY-MM-DD                       |<br>| TIME                              | 时间，包含一日的时、分、秒，格式为HH:MM:SS                   |<br>| TIMESTAMP                         | 时间戳类型                                                   |<br>| INTERVAL                          | 时间间隔类型                                                 |</p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231114110539378.png" alt="image-20231114110539378"></p></li><li><p>字符号常量的界定标识</p><ul><li>标准sql使用单引号标识字符串常量</li><li>字符串中间的2个连续单引号转义为一个单引号</li><li>双引号通常用来表示关键字，对象名，字段名</li></ul></li><li><p>数据库字符串编码与排序</p></li><li><p>模式与表</p><ul><li>每一个基本表属于某一个模式</li><li>一个模式包含多个基本表</li><li>dba可以设置搜索路径，然后定义基本表 <code>SET search_path TO &quot;xxx&quot;,PUBLC;</code><ul><li>此时建立的基本表为xxx模式下的基本表</li></ul></li></ul></li><li><p>修改基本表</p></li><li><p>ALTER TABLE &lt;表名&gt;</p><p>   [ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</p><p>   [ ADD &lt;表级完整性约束&gt;] </p><p>   [ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ]</p><p>   [ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ]</p><p>   [ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] ;</p></li><li><p>ADD子句：用于增加新列、新的列级完整性约束条件和新的表级约束完整性条件</p></li><li>DROP COLUMN：删除表中的列</li><li>DROP CONSTRAINT：删除指定的完整性约束条件</li><li>ALTER COLUMN：修改原有的列定义，包括修改列名和数据类型</li><li>新增一列后：不管原来的表中是否已有数据，新增的列一律为空值</li><li>采用缺省值DEFAULT来避免新增的字段取NULL，包括原来已有的数据也会被赋缺省值</li><li>删除基本表</li><li>DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE];</li></ul></li><li><p>视图定义/删除 <code>CREATE VIEW</code> <code>DROP VIEW</code></p></li><li><p>索引定义/删除/修改 <code>CREATE INDEX</code> <code>DROP INDEX</code> <code>ALTER INDEX</code></p><ul><li><p>建立索引目的：加快查询速度</p></li><li><p>常见索引：顺序文件上的索引、B+树索引、散列（hash）索引、位图（bitmap）索引</p></li><li><p>dba\表的属主建立索引</p></li><li><p>关系数据库管理系统自动选择合适的索引作为存取路径，不必也不能选择索引</p></li><li><p>CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;</p><p>ON &lt;表名&gt;(&lt;列名&gt;[次序][,&lt;列名&gt;[&lt;次序&gt;] ]…);</p><ul><li>&lt;表名&gt;：要建索引的基本表的名字</li><li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔</li><li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC</li><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示要建立的索引是聚簇索引（SQL Server语法）</li></ul></li><li><p>ALTER INDEX <old_name> RENAME TO <new_name></new_name></old_name></p></li><li></li></ul></li></ul></li><li><p>数据操纵语言 DML   Insert/ Select/Update/Delete</p><ul><li><p>数据查询</p><ul><li><p>SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,目标列表达式&gt;]…</p><p>FROM &lt;表名或视图名&gt;[,表名或视图名&gt; ]…| (SELECT 语句)  [AS]&lt;别名&gt;</p><p>[ WHERE &lt;条件表达式&gt; ]</p><p>[ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ]</p><p>[ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ];</p><ul><li>lGROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。</li><li>HAVING短语：只有满足指定条件的分组才予以输出</li><li>ORDER BY子句：对查询结果表按指定列值的升序或降序排序 </li></ul></li><li><p><strong>单表查询</strong></p><ul><li><p>选择表中若干列</p><ul><li>查询指定列：在目标列表达式里面直接写</li><li>查询全部列：目标列表达式为*</li><li>查询经过计算的值：目标列表达式可以为表达式<ul><li>列别名直接在列后面加上就可以</li></ul></li></ul></li><li><p>选择表中若干元组</p><ul><li><p>消除取值重复的行：DISTINCT</p></li><li><p>查询满足条件的元组</p></li><li></li><li><p>| 查 询 条 件          | 谓    词                                              |<br>| —————————— | ——————————————————————————- |<br>| 比  较               | =, &gt;,  &lt;, &gt;=, &lt;=, !=, &lt;&gt;,  !&gt;, !&lt;; NOT+上述比较运算符 |<br>| 确定范围             | BETWEEN AND, NOT  BETWEEN AND                         |<br>| 确定集合             | IN, NOT IN                                            |<br>| 字符匹配             | LIKE, NOT  LIKE                                       |<br>| 空  值               | IS NULL, IS NOT NULL                                  |<br>| 多重条件（逻辑运算） | AND,  OR,  NOT                                        |</p><ul><li>%代表任意长度（长度可为0）的字符串</li><li>_ 代表任意单个字符</li><li>精准匹配 <code>=</code></li><li>涉及空值的is不能用=代替</li><li>null参与数学运算时，结果为null</li><li>and or连接多个查询条件</li></ul></li></ul></li><li><p>order by子句</p><ul><li>可以按一个或多个属性列排序</li><li>缺省升序 ASC，降序DESC</li></ul></li><li><p>聚集函数</p><ul><li>统计元组个数   COUNT(*)</li><li>统计一列中值的个数   COUNT([DISTINCT|ALL] &lt;列名&gt;)</li><li>计算一列值的总和（此列必须为数值型）SUM([DISTINCT|ALL] &lt;列名&gt;) </li><li>计算一列值的平均值（此列必须为数值型）AVG([DISTINCT|ALL] &lt;列名&gt;)</li><li>求一列中的最大值和最小值   MAX([DISTINCT|ALL] &lt;列名&gt;) MIN([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li><p>group by子句</p><ul><li>细化聚集函数的作用对象</li><li>分组后，聚集函数将分别作用于每个组</li><li>按指定的一列或多列值分组，值相等的为1组</li><li>having作为聚集函数的条件表达式，作用于组</li><li>若值含有null，则将null所有行分为单独1组</li><li>count(*)会统计null记录数量，其余均忽略</li></ul></li></ul></li><li><p><strong>连接查询</strong></p><ul><li>select * from table1,table2 where …</li><li>连接条件：一般格式为 <code>[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt;</code></li><li>连接字段名称不必相同，但必须可比</li><li>等值于非等值连接查询：<ul><li>=</li><li>执行过程：<ol><li>嵌套循环法：在表1中找到每个元组一次在表2中遍历</li><li>排序合并法</li><li>索引链接</li></ol></li><li>用自然连接完成，两个连接关系的元组在公共属性上去值相等，且公共属性只出现一次</li></ul></li><li>自身连接：<ul><li>必须得起别名</li></ul></li><li>外连接：<ul><li>LEFT OUTER JOIN</li></ul></li><li>多表连接</li><li>等值连接类型：INNER JOIN XXX ON XXX</li><li>join连接<ul><li>使用natural，出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性<strong>只出现一次</strong></li><li>使用 on &lt;连接条件&gt;，出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li><li>使用using (col1,col2,..,coln)，(col1,col2,..,coln)是两个连接关系的公共属性的子集，元组在(col1,col2,..,coln)上取值相等，且(col1,col2,..,coln)只出现一次，属性集去重</li><li>MySQL会自动查找两个表中具有相同名称和数据类型的列</li><li>inner join：用 on 来加条件</li><li>cross join：如果没有where条件，返回所有表连接的笛卡尔积</li><li>建议 on 与 where 条件区分开，便于检查</li></ul></li></ul></li><li><p>嵌套查询</p><ul><li>一个SELECT-FROM-WHERE语句称为一个查询块</li><li>一个查询块嵌套在另一个查询块的where或having子句的条件中</li><li>子查询不能使用order by子句</li><li>不相关子查询：子查询的查询条件不依赖于父查询，每个子查询在上一级查询处理之前求解，子查询结果用于建立父查询的查询条件</li><li>相关子查询：子查询的查询条件依赖于父查询</li><li>带有IN谓词的子查询</li><li>带有比较运算符的子查询</li><li>带有ANY（SOME）或ALL谓词的子查询<ul><li><code>&lt;&gt; ANY</code> 或者 <code>!= ANY</code> 不等于子查询结果中的某个值，结果用为True</li><li><code>&lt;&gt; ALL</code> 或者 <code>!= ALL</code> 不等于子查询结果中的任何一个值</li><li>NOT IN与 <code>!=ALL</code>等价</li><li>如果比较值列表中包含NULL，且没有找到的时候会返回 <code>NULL</code></li></ul></li><li>带有EXISTS谓词的子查询<ul><li>在列表中没有NULL时，not in 与 not exists等价</li><li>在列表中有NULL时，not in 返回空集 not exists返回结果</li><li>全称量词也是通过exists来实现的</li></ul></li></ul></li><li><p>集合查询</p><ul><li>并操作<ul><li>UNION：将多个查询结果合并起来，自动去掉重复元组</li><li>UNION ALL：将多个查询结果合并起来，保留重复元组</li></ul></li><li>交操作 INTERSECT</li><li>差操作 EXCEPT</li></ul></li><li><p>基于派生表的查询</p><ul><li>子查询可以出现在FROM子句中</li><li>如果子查询中没有聚集函数，派生表可以不指定属性列</li></ul></li><li><p>CASE WHEN：条件返回</p><ul><li><p>CASE</p><p>​    WHEN condition1 THEN result1</p><p>​    WHEN condition2 THEN result2</p><p>​    ELSE result</p><p>END;</p></li></ul></li><li><p>WITH AS</p><ul><li>定义一个临时作用域，便于随后的查询引用</li></ul></li></ul></li><li><p><strong>数据更新</strong></p><ul><li><p>插入数据</p></li><li><p>INSERT</p><p> INTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2 &gt;…)]</p><p> VALUES (&lt;常量1&gt; [,&lt;常量2&gt;]… );</p></li><li><p>INTO</p><ul><li>属性列的顺序可与表定义中的顺序不一致</li><li>没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致</li><li>指定部分属性列：插入的元组在其他属性列上取空值，如果有缺省取缺省</li></ul></li><li><p>VALUES</p><ul><li>与INTO相匹配</li></ul></li><li><p>INSERT<br>INTO &lt;表名&gt; [(&lt;属性列1&gt;)[,&lt;属性列2&gt;…]]<br>子查询;</p></li><li><p>修改数据</p></li><li><p>UPDATE &lt;表名&gt;<br>SET &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…<br>[WHERE &lt;条件&gt;]</p></li><li><p>删除数据</p></li><li><p>DELETE<br>FROM &lt;表名&gt;<br>[WHERE &lt;条件&gt;];</p></li></ul></li><li><p><strong>视图</strong></p><ul><li>定义视图</li><li>CREATE VIEW<br>&lt;视图名&gt; [(&lt;列名&gt;[,&lt;列名&gt;])]<br>AS &lt;子查询&gt;<br>[WITH CHECK OPTION]</li><li>with check option 去报数据实时更新</li></ul></li></ul></li></ul></li></ol></li></ul><pre><code> - 数据控制语言 DCL     Grant/Revoke - 事务控制语言 TCL     Begin Transaction/Commit/Rollback</code></pre><ol><li><p>高度非过程化</p></li><li><p>面向集合的操作方式</p></li><li><p>以同一种语法结构提供多种使用方式</p><ul><li>独立语言</li><li>嵌入式语言</li><li>驱动程序API</li></ul></li></ol><ul><li><p>基本概念</p><ul><li>三级模式结构<ol><li>外模式：视图</li><li>模式：基本表</li><li>内模式：存储文件</li></ol></li><li>基本表<ul><li>一个关系对应一个基本表</li><li>一个基本表对应一个存储文件</li><li>一个表可以有若干索引</li></ul></li><li>存储文件<ul><li>逻辑结构 schema 组成了关系数据库的模式，由用户定义</li><li>物理结构 （内模式）对用户时隐蔽的、透明的</li><li>文件路径和文件名可由用户配置或指定</li><li>由DBMS进行管理，实现各异</li><li>用户修改模式，DBMS实现模式到内模式的自动映射与管理</li></ul></li><li>视图<ul><li>查询导出的表</li><li>虚表</li><li>数据库只存放使徒的定义，不存放视图对应的数据</li><li>用户可以在视图上再定义视图</li></ul></li></ul></li></ul><h2><span id="0x03-oracle-mysql工程实践">0x03 Oracle, Mysql工程实践</span></h2><ul><li><p><strong>Mysql</strong></p><ul><li><p>Schema与Database是等价的概念。</p></li><li><p>创建一个数据库用户 <code>CREATE USER &#39;USER_NAME&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;passwd&#39; --仅从本机登录</code></p></li><li><p>创建一个目标数据库/SCHEMA <code>CREATE DATABASE &lt;DB_NAME&gt; CHARACTER SET &#39;GBK&#39;/&#39;UTF8&#39;</code> </p></li><li><p>用户授权 <code>GRANT ALL ON *[DATABASE].*[TABLES,ETC] TO &#39;USER&#39;@&#39;LOACLHOST&#39; WITH GRANT OPTION;</code> <code>FLUSH PRIVILEGES --用于是内存中的权限于数据库中保持一致</code></p></li><li><p>数据类型</p><ul><li>CHAR，VARCHAR在Mysql&gt;5.6后是字符个数，不是字节数</li><li>NCHAR，NVARCHAR：国家字符集，定义的是字符的个数，通常是UTF-8字符集，1汉字=3字节</li><li>DATE：仅有日期部分，没有时间 ‘YYYY-MM-DD’</li><li>DATETIME：日期和时间两部分 ‘YYYY-MM-DD hh:mm:ss’</li><li>TIEMSTAMP：日期和时间两部分，范围是’1970-01-01 00:00:01’UTC to ‘2038-01-19 03:14:07’</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231114111315459.png" alt="image-20231114111315459"></li><li>字符串拼接：使用空格拼接</li><li>windows不区分大小写，linux区分</li><li>反引号 用来标记表名和列名</li></ul></li><li><p>数据库编码与排序规则</p><ul><li>SHOW CHARACTER SET;</li><li>SHOW CHARACTER SET LIKE ‘GB%’;</li><li>SHOW VARIABLES LIKE ‘CHARACTER_SET%’;</li><li>SHOW COLLATION LIKE ‘GB%’;</li></ul></li><li><p>字符集</p><ul><li><p>存储数据时的字符集</p><ul><li>在server\database\table\column四个级别指定所使用的字符集</li><li>服务器字符集和服务器排序规则分别由变量character_set_server和变量collation_server控制</li><li>数据库字符集和数据库排序规则<ul><li>CREATE DATABASE\ALTER DATABASE 都有选项可以指定数据库字符集和排序规则</li><li>CREATE DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name]</li><li>ALTER DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name]</li></ul></li><li>每个表都有一个表字符集和表排序规则<ul><li>CREATE TABLE tbl_name (column_list) [[DEFAULT] CHARACTER SET charset_name] [COLLATE collation_name]]</li><li>ALTER TABLE tbl_name [[DEFAULT] CHARACTER SET charset_name] [COLLATE collation_name]</li></ul></li><li>每一个字符列都有一个列字符集和列排序规则<ul><li>col_name {CHAR | VARCHAR | TEXT} (col_length) [CHARACTER SET charset_name] [COLLATE collation_name]</li></ul></li></ul></li><li><p>重要的字符集变量</p><ul><li>character_set_client 客户端发送过来的sql语句的编码</li><li>character_set_connection 服务器收到客户端的语句后，要转换的编码<ul><li>mysql server收到请求后将请求数据从character_set_client转换为character_set_connection</li><li>进行内部操作前请求数据从character_set_connection转换为内部操作字符集</li><li>最后将操作结果从内部操作字符集转换为character_set_results</li></ul></li><li>character_set_results server执行语句后，返回给客户端的数据的编码</li><li>客户端设置命令<ul><li>set names gkb/utf8</li><li>show variables like ‘CHARACTER%’;</li></ul></li></ul></li><li><p>查询</p><ul><li>缺省的转义字符是 <code>\</code></li></ul></li><li><p>复制表结构/数据</p><ul><li><blockquote><p>PPT 3-3 P14</p></blockquote></li></ul></li></ul></li></ul></li><li><p><strong>Oracle</strong></p><ul><li>Database和Instance是一对一关系。Database值服务器上所有数据文件、日志文件的综合，Instance值运行在服务器的一组后台进程。Schema是指某个User名下所有数据库对象的综合，而不是一个独立存在的实体，相当于数据库对象的命名空间，与UserName等价。</li><li>创建一个数据库用户，先创建表空间<code>CREATE TABLESPACE &lt;DB_NAME&gt; DATAFILE &#39;PATH/TO/LOAD&#39; SIZE 100M AUTOEXTEND ON NEXT 50M MAXSIZE 500M EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO</code> 之后创建用户 <code>CREATE USER &lt;USER_NAME&gt; IDENTIFIED BY &#39;&lt;PASSWD&gt;&#39; DEFAULT TABLESPACE &lt;DB_NAME&gt;</code></li><li>创建一个目标数据库/SCHEMA：安装时创建的/创建了user，就自动创建了schema</li><li>用户授权： <code>GRANT CONNECT, RESOURCE, DBA TO &lt;USER&gt;;</code> <code>GRANT UNLIMITED TABLESPACE TO &lt;USER&gt;;</code></li><li>数据类型<ul><li>DATE：日期加时间，精确到秒，固定7bytes</li><li>TIMESTAMP：日期加时间，精确到毫秒</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231114111320318.png" alt="image-20231114111320318"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231114111330664.png" alt="image-20231114111330664"></li><li>双引号标识的对象名/字段名区分大小写</li><li>字符串拼接：<code>||</code></li><li>标识符：区分大小写，建议全部大写</li><li>Oracle中双引号标识的对象名/字段名区分大小写</li></ul></li><li>数据库编码与排序规则<ul><li>SHOW PARAMETERS NLS;</li><li>NLS_DATABASE_PARAMETERS</li><li>nls_instance_parameters</li><li>nls_session_parameters</li></ul></li><li>数据字典<ul><li>有静态与动态之分：静态在用户访问数据字典时不会发生改变；动态依赖数据库运行性能，反应数据库运行的内在信息</li><li>静态数据字典：<ul><li>由表和视图组成，表是不能直接被访问的，可以访问的是视图</li><li>视图有三类<ul><li>user_*：存储当前用户所拥有的对象的信息</li><li>all_*：用户能够访问的对象的信息</li><li>dba_*：数据库中所有对象的信息</li></ul></li></ul></li><li>动态数据库<ul><li>以v$开头的视图</li></ul></li></ul></li><li>查询<ul><li>缺省的转义字符是 <code>\</code></li></ul></li></ul></li></ul><h2><span id="0x04-数据库设计的命名规范">0x04 数据库设计的命名规范</span></h2><blockquote><p> 见CH3-SQL-1</p></blockquote><hr><p><code>版权信息</code></p>]]></content:encoded>
      
      
      <category domain="http://www.warmfire.com/categories/%E5%AD%A6%E4%B9%A0/">学习</category>
      
      <category domain="http://www.warmfire.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="http://www.warmfire.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</category>
      
      <category domain="http://www.warmfire.com/tags/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/">学校课程</category>
      
      
      <comments>http://www.warmfire.com/2023/11/13/Database-Manual/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库实验记录</title>
      <link>http://www.warmfire.com/2023/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</link>
      <guid>http://www.warmfire.com/2023/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Thu, 02 Nov 2023 10:48:12 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01-oracle">0x01  Oracle</span></h2><h3><span id="1-登录">1 登录</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus &#123;&lt;username&gt;[/&lt;password&gt;]@&lt;connect_identifier&gt; &#125; [AS &#123;SYSDBA|SYSOPER|&#125;] </span><br></pre></td></tr></table></figure><h3><span id="2-数据库切换">2 数据库切换</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前的数据库</span></span><br><span class="line">sql&gt; show con_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">sql&gt; alter session <span class="built_in">set</span> container = &lt;contain_name&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">connect scott/123456@servername</span><br></pre></td></tr></table></figure><h3><span id="3-输出辅助">3 输出辅助</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set pagesize 1000; // 设置1000行</span><br><span class="line">set linesize 100; // 每行100字符</span><br><span class="line"></span><br><span class="line">spool file_name; //将内容输出到指定文件</span><br><span class="line">spool off; // 关闭输出</span><br><span class="line"></span><br><span class="line">desc table_name // 显示一个表的结构</span><br></pre></td></tr></table></figure><h3><span id="4-执行sql脚本文件">4 执行sql脚本文件</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@file_name;</span><br></pre></td></tr></table></figure><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>网络安全创新实验LAB7</title>
      <link>http://www.warmfire.com/2023/10/31/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8CLAB7/</link>
      <guid>http://www.warmfire.com/2023/10/31/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8CLAB7/</guid>
      <pubDate>Tue, 31 Oct 2023 05:35:43 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;
&lt;p&gt;防火墙实验&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><p>防火墙实验</p><span id="more"></span><h2><span id="0x01-实验原理">0x01 实验原理</span></h2><h3><span id="31-防火墙">3.1 防火墙</span></h3><p><strong>建立位置</strong></p><p>分为网络防火墙和基于主机的防火墙。网络防火墙位于网关计算机上，过滤多个网络之间的流量，基于主机的防火墙在特定主机上运行，监视并控制进出主机的网络流量。</p><p><strong>实现方法</strong></p><p>分为包过滤防火墙与应用及网关防火墙。包过滤防火墙工作于网络层，能对所有数据包进行过滤。不需要了解数据报文的具体细节，之查看数据包的源、目的地址、端口号、某些标志位；应用级防火墙工作于应用层，为特定的应用程序编写代理程序，过滤特定数据包。</p><h3><span id="32-iptables命令">3.2 iptables命令</span></h3><p>配置Linux内核防火墙的命令行工具。</p><p><code>iptables</code>存在表 <code>tables</code>、链 <code>chains</code>、 规则 <code>rules</code>三个层级。</p><p>表提供不同的数据包处理功能，存在5张表</p><ul><li><code>filter</code>表用于过滤数据包，防火墙操作的默认表，内建链包括 <code>INPUT</code> <code>OUTPUT</code> <code>FORWARD</code></li><li><code>nat</code>表用于网络地址转换，内建链 <code>PREROUTING</code> <code>POSTROUTING</code> <code>OUTPUT</code></li><li><code>mangle</code>表用于处理特定数据包，内建链 <code>PREROUTING</code> <code>INPUT</code> <code>OUTPUT</code> <code>FORWARD</code> <code>POSTROUTING</code></li><li><code>raw</code>表用于处理异常，内建链 <code>PREROUTING</code> <code>OUTPUT</code></li><li><code>security</code>表用于强制访问控制网络规则。内建链 <code>INPUT</code> <code>OUTPUT</code> <code>FORWARD</code></li></ul><p>存在5个链</p><ul><li><code>PREROUTING</code> 路由前链，在数据包刚刚到达本机，处理路由规则前通过此链，通常用于目的地址转换；</li><li><code>INPUT</code> 输入链，发往本机的数据包通过此链。</li><li><code>OUTPUT</code> 输出链，从本机发出的数据包通过此链</li><li><code>FORWARD</code> 转发链，本机转发的数据包通过此链。</li><li><code>POSTROUTING</code> 路由后链，数据包要离开本机时通过此链，通常用于源地址转换</li></ul><p>规则：任何链中都没有规则，可以自己添加。</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-L [chain]</td><td>列出指定链中的所有规则</td></tr><tr><td>-A [chain]</td><td>在指定链的末尾添加一条规则</td></tr><tr><td>-I [chain] [index]</td><td>在指定链的指定处插入一条规则</td></tr><tr><td>-D [chain] [index]</td><td>删除指定链中的指定规则</td></tr><tr><td>-R [chain] [index]</td><td>将指定链中的指定规则替换为新规则</td></tr><tr><td>-F [chain]</td><td>清空指定链中的所有规则</td></tr><tr><td>-P [chain] [target]</td><td>设置指定链的默认规则，例如 DROP，ACCEPT 等。</td></tr><tr><td>-t [table]</td><td>选择表</td></tr></tbody></table></div><p>处理动作 target</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>ACCEPT</td><td>允许数据包通过，并且不会再去匹配当前链中的其他规则</td></tr><tr><td>DROP</td><td>直接丢弃数据包， 不会返回任何的消息</td></tr><tr><td>REJECT</td><td>拒绝数据包通过，并向发送者返回错误信息</td></tr><tr><td>SNAT</td><td>对数据包进行源地址转换</td></tr><tr><td>DNAT</td><td>对数据包进行目的地址转换</td></tr><tr><td>MASQUERADE</td><td>和 SNAT 的作用相同，区别在于它不需要指定—to-source；</td></tr><tr><td>REDIRECT</td><td>转发数据包到本机另一个端口</td></tr></tbody></table></div><p>规则匹配条件于指定动作的相关参数与含义</p><p>iptables 命令规则匹配条件与指定动作的相关参数与含义</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-s</td><td>数据包的源 IP 地址</td></tr><tr><td>-d</td><td>数据包的目的 IP 地址</td></tr><tr><td>-p</td><td>数据包的协议</td></tr><tr><td>—sport</td><td>数据包的源端口</td></tr><tr><td>—dport</td><td>数据包的目的端口</td></tr><tr><td>-i</td><td>数据包的输入网卡</td></tr><tr><td>-o</td><td>数据包的输出网卡</td></tr><tr><td>-j</td><td>指定动作，例如 DROP， ACCEPT 等</td></tr><tr><td>-m</td><td>匹配扩展模块，例如 state， conntrack 等</td></tr></tbody></table></div><h3><span id="33-ssh-tunnel">3.3 SSH Tunnel</span></h3><p>隧道协议实现专用网络通信。</p><p>SSH Tunnel建立后，应用程序连接到一个被SSH客户端监听的本地端口。</p><h2><span id="0x02-实验步骤">0x02 实验步骤</span></h2><h3><span id="41-配置实验环境">4.1 配置实验环境</span></h3><p>Host U外部主机 VM1：A</p><p>Gateway网关 VM2：B</p><p>Host V内部主机VM3：C</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t [table] -A [chain] -s [<span class="built_in">source</span>] -j [target] -o [interface]</span><br></pre></td></tr></table></figure><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/10/31/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8CLAB7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>可证明安全第八周学习日志</title>
      <link>http://www.warmfire.com/2023/10/25/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AB%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</link>
      <guid>http://www.warmfire.com/2023/10/25/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AB%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Wed, 25 Oct 2023 01:51:16 GMT</pubDate>
      
      <description>&lt;p&gt;0x00 前言&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content:encoded>
      
      
      
      
      <comments>http://www.warmfire.com/2023/10/25/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AB%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
