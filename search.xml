<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024-05-13又是一日</title>
      <link href="/2024/05/13/2024-05-13%E5%8F%88%E6%98%AF%E4%B8%80%E6%97%A5/"/>
      <url>/2024/05/13/2024-05-13%E5%8F%88%E6%98%AF%E4%B8%80%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>你说，我要是每天的日记上附带一首诗，是不是很有逼格</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><p>想想最近干嘛先：</p><p>下午把升旗的事规划好了，接着把工业互联网的作业彻底搞定</p><p>晚上做做概统吧，第三讲感觉差不多了，今天真热啊</p><p>同时信息安全最后一次实验感觉也可以</p><h2><span id="0x02">0x02</span></h2><p>上午先是做实验，在下课之前做完了，那个John the Ripper我还浪费了好久去安装什么 John Blxxx的，结果发现我再run文件夹下就有john.exe这个文件，之后正常运行了，我对那个解压密码破解的挺感兴趣，毕竟很有可能用得到</p><p>之后工业互联网的时候我就把实验报告写完了，之后也没干啥</p><p>下午体育课上的挺好，就是太热了，在英语论文写作上和杨之烁交流的很好，知道了她是VR专业的，搞冯如杯是义务，而她做为队长工作量很大，考研的进展都被停滞了，可以看出来她是一个很负责的人，还挺乖的，舍不下对自己已经投入大量精力的事情，好良民！</p><p>晚上上hs课，主要就是把升旗的事安排明白了，大量的时间都没用来学习，回来洗了个澡，十一点上床，十一点半才睡觉。。。</p><h2><span id="0x03">0x03</span></h2><p>干！</p><p>专注模式，我得养成开专注模式的习惯，昨天定的上午2个半，下午3个，晚上2个半，今天开始八小时冲刺</p><h2><span id="0x04">0x04</span></h2><blockquote><p>偶成</p><p>【宋】朱熹</p><p>少年易老学难成，一寸光阴不可轻。</p><p>未觉池塘春草梦，阶前梧叶已秋声。</p></blockquote><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-13疲惫</title>
      <link href="/2024/05/13/2024-05-13%E7%96%B2%E6%83%AB/"/>
      <url>/2024/05/13/2024-05-13%E7%96%B2%E6%83%AB/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>实际是14号早上好疲惫</p><span id="more"></span><h2><span id="0x01-8小时学习已经成为目标">0x01 8小时学习已经成为目标</span></h2><p>仔细反思一天的学习时间好像还真没够8个小时</p><p>先是上午出门都已经八点了，之前的我可是八点前都到教室了，最近起的也挺晚，从明天开始一定好好睡觉，好好起床了</p><p>到了图书馆已经快九点多了，洛克王国上班刷刷就已经快十点了，这会才算是要开始学习了，上午专注了一个半小时之后就去吃饭了</p><p>中午在绿园逛了逛，回图书馆睡觉，在开始学就是下午两点了，下午先是专注了1个半小时，后续的效果就都不是很好了，好家伙，一种一鼓作气，再而衰，三而竭的美感</p><p>晚上更是重量级，全程没学入状态，后来打了打篮球，一直达到十点多，之后跟着同学聊处对象的事，</p><h2><span id="0x02">0x02</span></h2><p>总的来看，这一天学习时间甚至都到不了五个小时，先定个小目标，每天学习在8小时，上午两个半，下午三小时，晚上两小时半</p><p>同时每天一到ctf，每天背20min单词，每天保持20分钟运动</p><p>为了达成这样的目标，首先早上得保证到图书馆的时候是八点，之后可以按照课表的方式来学，有一个歪门点的方法就是硬去别人的课堂上蹭氛围。</p><p>下午和晚上也这么干，单词的学习放在中午1点半起来那段时间，ctf的做题放在学不进去的时候。</p><h2><span id="0x03">0x03</span></h2><p>最近的学习内容：概统，院长课</p><p>最近得完成的作业：工业互联网作业，实验</p><p>最近的竞赛：冯如杯制作组</p><p>周三晚上是线下集中更新PPT，冲击一手</p><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入之堆叠注入</title>
      <link href="/2024/05/12/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/05/12/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-11反思</title>
      <link href="/2024/05/12/2024-05-11%E5%8F%8D%E6%80%9D/"/>
      <url>/2024/05/12/2024-05-11%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>草草草，太堕落了</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><p>最近导的太凶了，缺乏自律，自制</p><p>以后的娱乐手段还是通过手机来吧，手机删了B站之后就拿电脑看，以后的娱乐方式就是用手机简单看看小说，而且要定时看，不能玩起来没完没了</p><p>当然还是那句话，堵不如疏，我需要找到大块的学习内容来讲精力与时间投入在上面</p><h2><span id="0x02">0x02</span></h2><p>上午先是干啥来着，草，这记忆力，翻了翻历史记录，发现是给工业互联网配置anaconda环境去了</p><p>之后去作志愿了，有点浪费时间了</p><p>下午在寝室待着，打着配置工业互联网的环境基本效率极低，后来跟老朱去跑步了，感觉这会还挺有意义的，之后去吃饭</p><p>每天得保持训练训练</p><p>晚上的效率更是低的夸张，基本上一直在刷小说了。。。</p><p>幸亏单词还是背了的</p><h2><span id="0x03">0x03</span></h2><p>明天过概统，任务量上的估计是</p><ol><li>复习第二讲错题，过第三讲视频讲解</li><li>下午作第三讲例题，作第三讲习题</li><li>晚上规划规划工作内容</li></ol><p>养成一天做一道ctf的习惯，如果半小时没思路的话就去找题解，看题解怎么做的，总比卡在一个地方好几天好，这样会很打击学习的积极性</p><h2><span id="0x04">0x04</span></h2><p>看瓦棚的故事，发现真是想象力是没有边界的，放飞自己的想象，我就是无限自由的！</p><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-10又是一日</title>
      <link href="/2024/05/11/2024-05-10%E5%8F%88%E6%98%AF%E4%B8%80%E6%97%A5/"/>
      <url>/2024/05/11/2024-05-10%E5%8F%88%E6%98%AF%E4%B8%80%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>话说今天都干啥了啊</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><p>仔细想想，好像是做概统+ 工业互联网作业</p><p>上午是做了做概统的例题，下午是做了概统的课后例题，他妈的，做题的状态不太好，有些题真容易错，做完之后后续的纠错还没有进行，明天改改</p><p>晚上写了些工业互联网作业，感觉还是配置成win10环境下的把，这样有process explorer能够好一点，明天给他正式搞掉，这么看效率有点低</p><p>冯如杯PPT还得进行改进啊，太有压力了</p><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-09挑战极限的日记</title>
      <link href="/2024/05/10/2024-05-09%E6%8C%91%E6%88%98%E6%9E%81%E9%99%90%E7%9A%84%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/10/2024-05-09%E6%8C%91%E6%88%98%E6%9E%81%E9%99%90%E7%9A%84%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>话说我为什么每次都是第二天早上写日记啊笑死</p><span id="more"></span><h2><span id="0x01-紧张又刺激的一天">0x01 紧张又刺激的一天？</span></h2><p>上午写了写篮球的作业，突然收到了挑战杯报名ddl</p><p>我尼玛，吓死我</p><p>差点错过</p><p>一整天疯狂在赶这个，我负责改PPT，他们三也陆续开始工作，最终也算是及时交上去了。</p><h2><span id="0x02">0x02</span></h2><p>明天上午弄概统吧，都多久没弄概统了，本来打算今天就弄得，结果被报名挑战杯弄得错过了</p><p>上午概统第二讲的任务量</p><p>下午第二讲错题梳理+工业互联网作业（延续到晚上</p><p>今天能把这两件事搞定就可以了</p><p>对了，别忘了背单词，这老卢真能装，明明早就开始背了，偏偏说没背，何必呢</p><h2><span id="0x03">0x03</span></h2><p>看看怎么为博客添加一个用户登录功能感觉也不错，实现的功能是只有登录的用户能够编辑查看日记部分。</p><p>突然发现这个功能以前竟然已经实现过了，hexo-admin</p><p>直接hexo server -d 登录就行</p><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-08日记</title>
      <link href="/2024/05/09/2024-05-08%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/09/2024-05-08%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>今天上午在做实验，晚上在做实验，这次的工业互联网真是好难，工业互联网的作业也得赶紧写了</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><p>上午开始做信息网络安全的实验，依然是没有设备做，只能等别人做完后去拿设备做，但是还挺好做的，问题不大</p><p>下午一方面看了谁动了我的奶酪一二，一方面把LETSniffer的环境配置了，本来以为两本书都是100页左右，看起来得挺费劲的，结果一看还挺朴素的，成年人的书籍的特色吗</p><p>晚上是工业互联网的实验，这实验也太难了，老师也催了催赶紧把作业写了，想来未来的工作内容包括工业互联网+概统+信安赛+信息安全</p><h2><span id="0x02">0x02</span></h2><p>谁动了我的奶酪里面的这部书里面让我印象较为深刻的反而是两个老鼠，</p><p>嗅嗅是我向往羡慕的类型，他对局势的变化有着敏锐的直觉，这说明首先他有着广泛的信息源，其次他的大局观能够驾驭目前的发展形势并进行预测，这也使得它能够在奶酪在减少时便早早注意到，并且很快的寻找到新的奶酪。而为了能够拥有广泛的信息源首先得维护一个健康的社交圈子，在圈子中大家交流情报，之后为了维护这个圈子也得展示自己的价值，要不拿hzgg的那个群开始练手，同时我还有酒吧群，我完全是有加入这个圈子的可能性的。</p><p>匆匆乍一听名字其实理解偏了，以为说是那种忙到感动自我的，故事里面并没有讨论到这种人，说的反而是那种fast-follower，一旦发生变化，能够很快跟上节奏的人，真是和哼哼形成了鲜明对比，也难怪他也是赢赢赢得那种，我估计现实生活中这种人是纯纯得大卷王吧，哈哈哈</p><h2><span id="0x03">0x03</span></h2><p>为了维护Hzgg粉丝群，首先保持日常的水群，在无事时让群也保持一个活跃度，其次多主动交流一些情报，这样能够让大家认识到我的价值，这个群的价值。</p><p>也和小包多交流，问问相关经验，水群也是门学问</p><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-07日记</title>
      <link href="/2024/05/07/2024-05-07%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/07/2024-05-07%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>每日反思</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><p>感觉我目前的一个主要问题就是所处的氛围中竞争感太低，就不是那么紧迫，进而效率也低，内耗也严重；</p><p>想到每次期末烤漆的时候高强度的竞争氛围使得我的效率更高，所以我要想办法加入一个高竞争的圈子中。</p><p>而且，每天还是不断在学新知识，没有对之前只是的一个温习的过程，这样很容易熊瞎子掰苞米。</p><h2><span id="0x02">0x02</span></h2><p>今天晚上回寝室，洗衣服，并且把第二讲的相关习题做完，注意多思考多思考，给大脑快放3年的假期了！！！</p><p>结果洗了衣服后基本就在刷B站了，真是禁不住诱惑！</p><p>淦</p><p>晚上和舍友聊天一直聊到一点，感觉也还挺不错的。</p><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的狼人杀生活</title>
      <link href="/2024/05/07/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%8B%BC%E4%BA%BA%E6%9D%80%E7%94%9F%E6%B4%BB/"/>
      <url>/2024/05/07/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%8B%BC%E4%BA%BA%E6%9D%80%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>嘿嘿嘿，狼人杀我来了，嘿嘿嘿</p><span id="more"></span><h2><span id="0x01-基本规则">0x01 基本规则</span></h2><p>两个对立阵营，无中立：好人阵营，狼人阵营</p><p>好人阵营有平民和神职人物，</p><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-06小日记来喽</title>
      <link href="/2024/05/06/2024-05-06%E5%B0%8F%E6%97%A5%E8%AE%B0%E6%9D%A5%E5%96%BD/"/>
      <url>/2024/05/06/2024-05-06%E5%B0%8F%E6%97%A5%E8%AE%B0%E6%9D%A5%E5%96%BD/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01-5月4日">0x01 5月4日</span></h2><p>话说是54青年节，乌鱼子的一天，全部时间投入到了回报比特别低的信安赛中，基本无进展，莫名其妙的rtl能够接收到信号了，但是gps欺骗依旧是没能实现的问题</p><h2><span id="0x02-5月5日">0x02 5月5日</span></h2><p>又把大量的时间放在信安赛上了，就像无头苍蝇一样乱撞</p><h2><span id="0x03-5月6日">0x03 5月6日</span></h2><p>今天把Python安全编程的作业水完了，还有工业互联网</p><p>概统好久没推进了</p><p>急急急</p><p>思考思考，想成为一个优秀的领袖，领导，需要能够有良好的人际关系，社交能力，能够主导讨论的动向，同时有最终决策的考量。</p><p>今晚回去后洗个澡，把工业互联网的作业推动推动，今晚争取把前两点搞掉，如果能全部完成的话就更好了。</p><p>噫，我怎么光刷小说了</p><p>宝贵的时间又浪费了</p><p>而且看的也不是很爽</p><p>明天开始再用专注软件专注吧</p><p>好久没用了</p><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-05-04补录最近日记</title>
      <link href="/2024/05/04/2024-05-04%E8%A1%A5%E5%BD%95%E6%9C%80%E8%BF%91%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/04/2024-05-04%E8%A1%A5%E5%BD%95%E6%9C%80%E8%BF%91%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>唔，这两天玩的真累啊，这会补一下最近的日记。</p><span id="more"></span><h2><span id="0x01-5月2日蓟州旅">0x01 5月2日蓟州旅</span></h2><p>为了防止睡觉睡过，1号晚上睡觉前就把手机放在了床下，早上早早地把我叫醒，好困，不过幸亏我仍是抽出一段时间来拉了泡大的，要不然路上得憋死我。</p><p>出门后先是从地铁口那个门出发的，淦，结果门没开，又重新折返，幸亏时间来得及，之后就是枯燥的坐地铁，赶地铁，疯狂换站，也是准时到了。</p><p>经典北京站，到了之后就已经在检车了，一刻没有耽误，直接就进入了火车，在车上旁边有个露大腿的小姐姐坐在旁边，美滋滋，同时在看圆桌的阳光神官，笑死我了，这作者太他妈有才了。</p><p>到站之后就一边听歌，一边闲逛着在蓟州逛逛，出了火车站就坐个大客，寻思着随便坐坐，结果看到有很多人在一站下车了，我也就跟着下去了。</p><p>到的地方是一条步行街，正好早上没吃饭呢就买了一份炸鸡，真难吃，呸！</p><p>中间广场有一个大喷泉，梦回火车站广场了。</p><p>之后朝旭哥开着车来了，我、我妈、三姨、朝旭哥四个人出发去蓟县古长城，路上一波波的车，虽说不少，但也没想象的那么夸张。</p><p>进入这里之后，真是长见识了，这个山，太夸张了，太陡峭了，太险峰了，还有飞流直下的瀑布，感觉在那里真是得很清凉，中午就在那里吃了个野餐，感觉真不错，吃的烧饼、咸鸭蛋、牛肉、椰肉罐头，之后去爬长城了，真是有点让人害怕</p><h2><span id="0x02-5月3日承德之旅">0x02 5月3日承德之旅</span></h2><p>承德的山好夸张！好牛逼！</p><p>避暑山庄真的好大好大，就是可惜玩的时间有点少，有些景点都没去，小布达拉宫也没进去，十分期待以后再来！</p><h2><span id="0x03-5月3日神秘聚餐">0x03 5月3日神秘聚餐</span></h2><p>不得不说，真的是干货满满，这种大家不同领域（理工农商）、不同阶段（学生、工作）的交流沙龙真的是很能够带来巨大的信息量，当然饭店的菜品也是很好吃的，那么~香的红烧肉真的太爽了。</p><p>这一次的交流可谓是信息量巨大，为了方便，我分几点进行梳理：</p><ol><li><strong>认清自我</strong>：认清自我真是一件很难做到的事情，对我自己来说，总是想要的太多，忙忙碌碌的，在mbti之类的人格测试中很多时候选择的选项不是真实的自我，而是我理想的自我，最终得出的结果也难免失真，所以我也就不太关注这测评结果的反馈细节，总觉得他测得不太准似地:sweat_smile:，但是娜姐组织的那个记录自己最有成就感的事情全过程的引导我去思考我真正擅长的，真正渴望的，相信这个过程能够更好地让我认清自我，在以后的学习工作中，如果用这种思维的框架来思考我的工作与安排，相信能让我对整个大局的把控更加全面，不再那么迷茫。</li><li><strong>反思自我</strong>：我有罪，我反思，我反思我太久没反思了，正是意识到了这个问题，我最近开始写日记了，与咱们的沙龙不谋而合，学习生活中能够学的东西无穷无尽，但我真正需要的东西确实需要通过思考与交流筛选出来的，埋头苦学除了感动自己外真是帮助有限，养成<strong>复盘的习惯</strong>，周期性的复盘，像是定期体检一样反思反思我的规划，<del>现在就是在复盘哦</del> ，正所谓小包曰：学而不思则罔，这个习惯，必须得坚持下来！</li><li><strong>塑造自我</strong>：朋友圈！朋友圈！朋友圈！重要的事情说三遍，时代变了，身边的社交基本都是电子社交，大家通过微信啥进行聊天了，朋友圈是我让大家认识我的一个重要途径，因此我要有意识地去打造一个基于我更优于我的人设了（<del>我要开始吹牛了</del>，其实我是不太习惯的，总感觉做人应该谦逊点，有什么成就都到处拿来显摆让我感到羞耻，算了，一步一步来吧，先是做到遇到一些牛的事情的时候，针对事情发一个认真的朋友圈，宣传宣传自己，也方便大家通过朋友圈来认识自己，之前还一直感叹没啥社交，跟别人说话感觉也没啥好聊的，那就照着娜姐的指引来，多在别人的朋友圈里露露面，点赞，评论，终究会让人更多地认识自己！</li><li>Tips<ul><li>包总太强了，学生工作能力拉爆了，以后人文，人际啥的我一定要多问问他！</li><li>收获了一些团日活动的活动形式，感觉大有可为</li><li>基于目标逆推的思维方式，这个能够让我更清晰，明确地达到最终的目的</li><li>有些突然想不起来了，说不准突然就能想起来，先来个未完待续吧</li></ul></li></ol><h2><span id="0x04-未来工作规划">0x04 未来工作规划</span></h2><p>卧槽，工业互联网作业还没做，包括两部分，分别是小组作业，课上的作业题；</p><p>Python安全编程还没搞；</p><p>之后院长课，概统都是重量级任务</p><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>preg_match字符匹配</title>
      <link href="/2024/05/01/preg-match%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
      <url>/2024/05/01/preg-match%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>web题里面遇到了RCE中字符过滤的问题，记录一下其中常见的绕过方法。</p><span id="more"></span><h2><span id="0x01-正则表达式">0x01 正则表达式</span></h2><h3><span id="普通字符">普通字符</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[ABC] </span><br><span class="line">- 匹配[...]中的所有字符</span><br><span class="line">[^ABC]</span><br><span class="line">- 匹配除了[...]中字符的所有字符</span><br><span class="line">[A-Z]</span><br><span class="line">- 表示一个区间</span><br><span class="line">.</span><br><span class="line">- 匹配换行符(\n,\r)之外的任何单个字符</span><br><span class="line">[\s\S]</span><br><span class="line">- \s匹配所有空白符，包括换行</span><br><span class="line">- \S匹配所有非空白符，不包括换行</span><br><span class="line">\w</span><br><span class="line">- 匹配字母、数字、下划线</span><br><span class="line">\d</span><br><span class="line">- 匹配任意一个阿拉伯数字</span><br></pre></td></tr></table></figure><h3><span id="非打印字符">非打印字符</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\cx</span><br><span class="line">- 匹配由x指明的控制字符</span><br><span class="line">\f</span><br><span class="line">- 匹配一个换页符。等价于 \x0c 和 \cL</span><br><span class="line">\n</span><br><span class="line">- 匹配一个换行符。等价于 \x0a 和 \cJ</span><br><span class="line">\r</span><br><span class="line">- 匹配一个回车符。等价于 \x0d 和 \cM</span><br><span class="line">\t</span><br><span class="line">- 匹配一个制表符。等价于 \x09 和 \cI</span><br><span class="line">\v</span><br><span class="line">- 匹配一个垂直制表符。等价于 \x0b 和 \cK</span><br></pre></td></tr></table></figure><h3><span id="特殊字符">特殊字符</span></h3><div class="table-container"><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 <script type="math/tex">` 也匹配 '\n' 或 '\r'。要匹配 `</script> 字符本身，请使用 <code>\$</code>。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 `\</em>`。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <code>\+</code>。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 <code>\.</code> 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 <code>\[</code>。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 <code>\?</code>。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘<code>\\</code>‘ 匹配 “<code>\</code>“，而 ‘<code>\(</code>‘ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code>。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 <code>\&#123;</code>。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>指明两项之间的一个选择。要匹配 \</td><td>，请使用 `\</td><td>`。</td></tr></tbody></table></div><h3><span id="定位符">定位符</span></h3><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">非单词边界匹配。</td></tr></tbody></table></div><h2><span id="0x02-preg_match正则绕过">0x02 preg_match正则绕过</span></h2><p><a href="https://www.cnblogs.com/tomyyyyy/p/13905357.html#空格">CTF中WEB题——RCE - tomyyyyy - 博客园 (cnblogs.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|\&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;, $ip, $match))&#123;</span><br><span class="line">    echo preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x&#123;00&#125;-\x&#123;20&#125;]|\&gt;|\&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;, $ip, $match);</span><br><span class="line">    die(&quot;fxck your symbol!&quot;);</span><br><span class="line">  &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your space!&quot;);</span><br><span class="line">  &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your bash!&quot;);</span><br><span class="line">  &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your flag!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);</span><br><span class="line">  echo &quot;</span><br><span class="line">&quot;;</span><br><span class="line">  print_r($a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>preg_match中正则表达式需要写在 <code>/ /</code>之中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过滤的字符如下：</span><br><span class="line">&#x27;,&quot;,\,(,),[,],&#123;,&#125;</span><br><span class="line">空格</span><br><span class="line">bash</span><br><span class="line">不可以有flag四个字母依次出现</span><br></pre></td></tr></table></figure><p>由于不能有flag4个字母，则第一个思路是正则表达式，第二个思路是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1=f;3=a;2=l;4=g;cat$IFS$1$2$3$4.php</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--?php</span><br><span class="line">$flag = &quot;flag&#123;b827bd0b-adca-4a9c-8315-36ce5e6ba703&#125;&quot;;</span><br><span class="line">?--&gt;</span><br></pre></td></tr></table></figure><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-1日记</title>
      <link href="/2024/05/01/%E9%97%B2%E8%81%8A/2024-5-1%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/01/%E9%97%B2%E8%81%8A/2024-5-1%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
          <category> 生活反思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-4-30日记</title>
      <link href="/2024/04/30/%E9%97%B2%E8%81%8A/2024-4-30%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/04/30/%E9%97%B2%E8%81%8A/2024-4-30%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>今天是狂欢的一天，玩的真累</p><span id="more"></span><h2><span id="0x01-生活记录">0x01 生活记录</span></h2><p>上午也没离开寝室，早上起来后把洛克王国的每日打工做完之后就开始写日记，昨天的日记真是写了好久，笑死:sweat_smile:</p><p>之后快到中午的时候简单看了看大疆无人机的情况，对应申请的内容还没写完，明天把申请书和老卢一起搞定他吧；</p><p>下午去ktv唱歌，一直唱了5个小时，真给我累完了，之后去吃筋头巴脑，吃的好饱；</p><p>本来晚上想打打篮球的，结果场里全是人，没整成，有点遗憾；</p><p>晚上回来就写个日记，再看看CTF吧</p><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
          <category> 生活反思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-4-29 突发奇想的日记环节</title>
      <link href="/2024/04/29/%E9%97%B2%E8%81%8A/2024-4-29-%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E6%97%A5%E8%AE%B0%E7%8E%AF%E8%8A%82/"/>
      <url>/2024/04/29/%E9%97%B2%E8%81%8A/2024-4-29-%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E6%97%A5%E8%AE%B0%E7%8E%AF%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>说起来这个博客真的是好久没有处理了，最近正好开始做ctf题目了，一边开始写写wp，一边开始简单写写日记吧，也不是必须得一天一写，主要是反思反思今天一天干什么了，有什么收获！</p><span id="more"></span><h2><span id="0x01-生活经历">0x01 生活经历</span></h2><p>早八起的有点晚，到实验室的时候竟然都晚了两分钟，这实验做的也没啥感觉，之后就开始做BUUCTF了，这个平台最开始的时候只寻思从Basic做起，结果没想到这么难，后来看了看Web方面，竟然还好，就开始做这部分的题了，成果还不错，一天做了5道题，最后卡在ping ping ping 这里了，感觉像是关于字符匹配绕过的，难住我了，有意思。</p><p>当然，最近的学习基本一直是伴随着大奉打更人的有声书听的，学习的效率并不高，打算之后的娱乐就不是再看或听新的小说了，重新精读一次这个小说。</p><p>老舅的事也确定下来了，总共得赔9w，得蹲3年，真点背啊。</p><p>明天下午去唱歌，5月2号去蓟州和承德，期待 ！</p><h2><span id="0x02-ctf生活">0x02 CTF生活</span></h2><p>一共做了5道题：</p><h3><span id="极客大挑战-2019easysql">[极客大挑战 2019]EasySQL</span></h3><p>主要的考点是一个简单的sql注入，我直接输一个万能密码就过关了</p><h3><span id="极客大挑战-2019havefun">[极客大挑战 2019]Havefun</span></h3><p>查看网页源代码，在注释部分观察到设置<code>$cat=dog</code></p><h3><span id="hctf-2018warmup">[HCTF 2018]WarmUp</span></h3><p>查看源代码知道访问 <code>source.php</code>，访问后显示源码：</p><p><img src="https://img-blog.csdnimg.cn/424d35d71acb40f48634ee468f57a2fc.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeTE4NjM0Mjk3OTc2,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>知道了其中有白名单进行过滤，分别访问source.php与hint.php，先进入flag.php获取flag的文件名</p><p>之后查看源码，发现当没有白名单中的元素后，会进行一次编码，并在最后加一个？之后判断遇到的第一个问号之前的内容为主要url，所以我们将？的信息进行两次编码，让其将source.php作为目录，不断访问/../../../../../../ffffffllllllaaaaaaggggg获取flag</p><h3><span id="actf2020-新生赛include">[ACTF2020 新生赛]Include</span></h3><p>这块真是没想出来访问哪个，简单找了找wp后，得知是文件包含的题目</p><p>对应的原因是 ?file=这个参数，利用php:filter协议实现读取，flag就在注释里面</p><h3><span id="actf2020-新生赛exec">[ACTF2020 新生赛]Exec</span></h3><p>命令注入，到根目录打开flag</p><h2><span id="0x03-学习思考">0x03 学习思考</span></h2><p>最近好久没学习概统了，还有英语单词也没背，同时院长课也应该背一背，目前信安赛的进度难以捉摸，真得好好想想未来规划了。</p><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
          <category> 生活反思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code Llama</title>
      <link href="/2024/01/21/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Code-Lemma/"/>
      <url>/2024/01/21/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/Code-Lemma/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>Code Llama：Open Foundation Models for Code的翻译及分析</p><span id="more"></span><h2><span id="0x01-translation">0x01 Translation</span></h2><h3><span id="abstract">Abstract</span></h3><p>We release Code Llama, a family of large language models for code based on Llama 2 providing state-of-the-art performance among open models, infilling capabilities, support for large input contexts, and zero-shot instruction following ability for programming tasks. </p><p>我们发布了Code Llama，这是基于Llama 2的一系列大型代码语言模型。该模型在开放模型中表现出色，具有填充能力、支持大型输入上下文，并且在编程任务的零指导跟随方面具有先进性能。</p><p>We provide multiple flavors to cover a wide range of applications: foundation models (Code Llama), Python specializations (Code Llama - Python), and instruction-following models (Code Llama - Instruct) with 7B, 13B and 34B parameters each. </p><p>我们为了覆盖更大范围的应用，提供了一些特色改进：基础模型、Python专业化模型与指导跟随模型，分别具有7B、13B、34B的参数。</p><p>All models are trained on sequences of 16k tokens and show improvements on inputs with up to 100k tokens. 7B and 13B Code Llama and Code Llama - Instruct variants support infilling based on surrounding content. </p><p>所有模型用大小为16k的令牌序列进行训练并且在输入高达100k令牌的情况下取得了提升。7B和13B的Code Llama 和指导Code Llama 的变种支持基于周围内容的填充功能。</p><p>Code Llama reaches state-of-the-art performance among open models on several code benchmarks, with scores of up to 53% and 55% on HumanEval and MBPP, respectively. </p><p>在多个代码基准下Code Llama均达到了开放模型的最优效果，分别在HumanEval和MBPP的评分达到了高达的53%到55%的评分。</p><p>Notably, Code Llama - Python 7B outperforms Llama 2 70B on HumanEval and MBPP, and all our models outperform every other publicly available model on MultiPL-E. </p><p>尤其是参数为7B的Code Llama Python在HumanEval与MBPP中做得比参数为70B的Llama 2更好， 并且我们所有的模型在MultiPL-E上比其他所有公开可行地模型都表现得更好。</p><p>We release Code Llama under a permissive license that allows for both research and commercial use.</p><p>我们发布了支持商业和研究的Code Llama许可证。</p><h3><span id="introduction">Introduction</span></h3><p>Large language models (LLMs) power a rapidly increasing number of applications, having reached a proficiency in natural language that allows them to be commanded and prompted to perform a variety of tasks (OpenAI, 2023; Touvron et al., 2023b). </p><p>By utilizing large, in-domain datasets, their efficacy can be greatly improved for applications that require a combination of both natural and domain-specific language and understanding of specialized terminology. </p><p>By training on domain-specific datasets, they have proved effective more broadly on applications that require advanced natural language understanding. </p><p>A prominent use-case is the formal interaction with computer systems, such as program synthesis from natural language specifications, code completion, debugging, and generating documentation (for a survey, see Xu &amp; Zhu, 2022, also see Section 5).</p><p>In this work, we present Code Llama, a family of LLMs for code generation and infilling derived from Llama 2 (Touvron et al., 2023b) and released under the same custom permissive license. </p><p>We provide inference code for both completion and infilling models in the accompanying repository. </p><p>Our approach is based on gradually specializing and increasing the capabilities of Llama 2 models by applying a cascade of training and fine-tuning steps (Figure 2):</p><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo配置文件学习</title>
      <link href="/2024/01/13/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/01/13/hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p><code>_config.yml</code>文件中的含义</p><span id="more"></span><h2><span id="0x01-网站">0x01 网站</span></h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">网站标题</td></tr><tr><td style="text-align:left"><code>subtitle</code></td><td style="text-align:left">网站副标题</td></tr><tr><td style="text-align:left"><code>description</code></td><td style="text-align:left">网站描述</td></tr><tr><td style="text-align:left"><code>keywords</code></td><td style="text-align:left">网站的关键词。支持多个关键词。</td></tr><tr><td style="text-align:left"><code>author</code></td><td style="text-align:left">您的名字</td></tr><tr><td style="text-align:left"><code>language</code></td><td style="text-align:left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td style="text-align:left"><code>timezone</code></td><td style="text-align:left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table></div><p><code>description</code>用于Search Engine Optimization (SEO, 搜索引擎优化)</p><h2><span id="0x02-网址">0x02 网址</span></h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>url</code></td><td style="text-align:left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>root</code></td><td style="text-align:left">网站根目录</td><td style="text-align:left"><code>url&#39;s pathname</code></td></tr><tr><td style="text-align:left"><code>permalink</code></td><td style="text-align:left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td><td style="text-align:left"><code>:year/:month/:day/:title/</code></td></tr><tr><td style="text-align:left"><code>permalink_defaults</code></td><td style="text-align:left">永久链接中各部分的默认值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>pretty_urls</code></td><td style="text-align:left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>pretty_urls.trailing_index</code></td><td style="text-align:left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td style="text-align:left"><code>true</code></td></tr><tr><td style="text-align:left"><code>pretty_urls.trailing_html</code></td><td style="text-align:left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td style="text-align:left"><code>true</code></td></tr></tbody></table></div><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安全协议课程总结</title>
      <link href="/2024/01/13/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/13/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数分第17周学习日志</title>
      <link href="/2023/12/28/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC17%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/12/28/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC17%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>广义积分</p><span id="more"></span><h2><span id="0x01-无穷积分定义与计算">0x01 无穷积分定义与计算</span></h2><h3><span id="定义">定义</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228095046377.png" alt="image-20231228095046377"></p><h3><span id="性质">性质</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228095109175.png" alt="image-20231228095109175"></p><ul><li>性质1感觉还是很重要的</li></ul><h3><span id="计算">计算</span></h3><p>无穷积分的计算=定积分+极限</p><h4><span id="定理-无穷积分计算">定理 无穷积分计算</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228111601965.png" alt="image-20231228111601965"></p><p>利用不定积分求原函数，之后根据定积分的定义来做差，涉及到无穷的直接是求极限</p><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228111847097.png" alt="image-20231228111847097"></p><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228111940281.png" alt="image-20231228111940281"></p><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228111953072.png" alt="image-20231228111953072"></p><h4><span id="思考题">思考题</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228112827054.png" alt="image-20231228112827054"></p><p>不一定，存在反例</p><h2><span id="0x02-非负函数无穷积分收敛问题讨论">0x02 非负函数无穷积分收敛问题讨论</span></h2><h4><span id="定理1">定理1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228150833318.png" alt="image-20231228150833318"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151118046.png" alt="image-20231228151118046"></li></ul><h4><span id="定理2">定理2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151345604.png" alt="image-20231228151345604"></p><h4><span id="定理3">定理3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151506006.png" alt="image-20231228151506006"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151611804.png" alt="image-20231228151611804"></p><p>第二个直接看作dlnx就可以了，结论记住能够加个速</p><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151741711.png" alt="image-20231228151741711"></p><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151749437.png" alt="image-20231228151749437"></p><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151819040.png" alt="image-20231228151819040"></p><h4><span id="例4">例4</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151827206.png" alt="image-20231228151827206"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151843417.png" alt="image-20231228151843417"></p><h4><span id="例5">例5</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151926150.png" alt="image-20231228151926150"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228151953437.png" alt="image-20231228151953437"></p><h2><span id="0x03-无穷积分收敛的迪利克雷和阿贝尔定理">0x03 无穷积分收敛的迪利克雷和阿贝尔定理</span></h2><h4><span id="定理-无穷积分收敛柯西定理">定理 无穷积分收敛柯西定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228153647982.png" alt="image-20231228153647982"></p><h4><span id="推论">推论</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228153912872.png" alt="image-20231228153912872"></p><h4><span id="定义-绝对收敛与条件收敛">定义 绝对收敛与条件收敛</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228153930035.png" alt="image-20231228153930035"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228155116986.png" alt="image-20231228155116986"></p><p>下面这个解与他无关</p><h4><span id="无穷积分的迪利克雷定理">无穷积分的迪利克雷定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228155537582.png" alt="image-20231228155537582"></p><p>这个F(A)有界说明可能没有极限，不一定收敛的，因此对g(x)要求更严格</p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228155615751.png" alt="image-20231228155615751"></li><li>最终使用了柯西定理别忘了</li></ul><h4><span id="无穷积分的阿贝尔判定定理">无穷积分的阿贝尔判定定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228160035304.png" alt="image-20231228160035304"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228160043773.png" alt="image-20231228160043773"></li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228160112834.png" alt="image-20231228160112834"></p><ul><li>和差化积</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228160122074.png" alt="image-20231228160122074"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228160130298.png" alt="image-20231228160130298"></p><p>这道题非常经典</p><h2><span id="0x04-瑕积分的收敛与计算">0x04 瑕积分的收敛与计算</span></h2><h4><span id="定义">定义</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228162709448.png" alt="image-20231228162709448"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228163030052.png" alt="image-20231228163030052"></p><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228163040021.png" alt="image-20231228163040021"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228163048357.png" alt="image-20231228163048357"></p><p>先找瑕点，将瑕点为界提出。</p><h4><span id="性质">性质</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228163117395.png" alt="image-20231228163117395"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231228163144823.png" alt="image-20231228163144823"></p><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库实验4学习日志</title>
      <link href="/2023/12/15/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C4%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/12/15/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C4%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>关于sql注入攻击与数据库密码策略的相关学习</p><span id="more"></span><h2><span id="0x01-oracle-password-密码策略">0x01 Oracle password 密码策略</span></h2><p><img src="https://obs-emcsapp-public.obs.cn-north-4.myhwclouds.com/image%2Feditor%2F0045b3d1-d1e9-4291-90ef-ce19f7efcd49.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 口令复杂度策略，及登陆失败措施</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> resource_limit;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> FAILED_LOGIN_ATTEMPTS;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> SEC_CASE_SENSITIVE_LOGON;</span><br><span class="line"><span class="comment">-- resource_limit: 用于控制每个用户的资源使用限制，包括 CPU、内存和 I/O </span></span><br><span class="line"><span class="comment">-- FAILED_LOGIN_ATTEMPTS: 用户在登录尝试失败n次后被锁定。</span></span><br><span class="line"><span class="comment">-- SEC_CASE_SENSITIVE_LOGON: 用于确定登录时是否区分用户名的大小写。如果设置为 TRUE，那么&quot;User&quot;和&quot;user&quot;被视为两个不同的用户。如果设置为 FALSE，大小写将被忽略，&quot;User&quot;和&quot;user&quot;将被视为同一个用户。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 确保以下两个参数为TRUE</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> resource_limit <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> SEC_CASE_SENSITIVE_LOGON <span class="operator">=</span> <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用密码复杂度规则</span></span><br><span class="line">sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba</span><br><span class="line">@?<span class="operator">/</span>rdbms<span class="operator">/</span>admin<span class="operator">/</span>utlpwdmg.sql  <span class="comment">--  创建密码验证函数(请查看?/rdbms/admin/utlpwdmg.sql里面生成的验证函数)</span></span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit password_verify_function verify_function; <span class="comment">-- 启用密码验证</span></span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit password_verify_function ORA12C_VERIFY_FUNCTION; <span class="comment">-- 启用密码验证</span></span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit password_verify_function <span class="keyword">null</span>;  <span class="comment">-- 取消密码复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前用户状态，锁定时间，过期时间</span></span><br><span class="line">col ACCOUNT_STATUS <span class="keyword">for</span> a16</span><br><span class="line">col USERNAME <span class="keyword">for</span> a30</span><br><span class="line"><span class="keyword">select</span> USERNAME,ACCOUNT_STATUS,LOCK_DATE,EXPIRY_DATE <span class="keyword">from</span> dba_users; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前配置profile</span></span><br><span class="line"><span class="keyword">set</span> line <span class="number">190</span> pages <span class="number">90</span></span><br><span class="line">col PROFILE <span class="keyword">for</span> a25</span><br><span class="line">col LIMIT <span class="keyword">for</span> a25</span><br><span class="line"><span class="keyword">select</span> PROFILE,resource_type,RESOURCE_NAME,LIMIT <span class="keyword">from</span> dba_profiles <span class="keyword">where</span> PROFILE<span class="operator">=</span><span class="string">&#x27;DEFAULT&#x27;</span>;   </span><br><span class="line"><span class="keyword">SELECT</span> profile,resource_type,resource_name,limit <span class="keyword">FROM</span> dba_profiles <span class="keyword">WHERE</span> resource_type<span class="operator">=</span><span class="string">&#x27;PASSWORD&#x27;</span> <span class="keyword">AND</span> profile<span class="operator">=</span><span class="string">&#x27;DEFAULT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改当前配置profile</span></span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit FAILED_LOGIN_ATTEMPTS <span class="number">5</span>; </span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit PASSWORD_LOCK_TIME <span class="number">30</span><span class="operator">/</span><span class="number">24</span><span class="operator">/</span><span class="number">60</span>; <span class="comment">-- 单位天(配置30分钟)</span></span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit PASSWORD_LIFE_TIME <span class="number">90</span>; </span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit PASSWORD_GRACE_TIME <span class="number">7</span>; </span><br><span class="line"><span class="comment">-- alter profile default limit PASSWORD_REUSE_TIME UNLIMITED;</span></span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit PASSWORD_REUSE_TIME <span class="number">30</span>;  </span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit PASSWORD_REUSE_MAX <span class="number">7</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> limit IDLE_TIME <span class="number">10</span>;   <span class="comment">-- 会话空闲超过10分钟之后自动断开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.PASSWORD_LOCK_TIME: 登录尝试失败达到指定次数，用户锁定时长，以“Day”为单位。</span></span><br><span class="line"><span class="comment">-- 3.PASSWORD_LIFE_TIME: 用户口令的生命周期。</span></span><br><span class="line"><span class="comment">-- 4.PASSWORD_GRACE_TIME: 表示用户口令使用时间超过其生命周期后，可以延续使用的天数，并且可延续时间内登录会有相应口令即将过期的提示。</span></span><br><span class="line"><span class="comment">-- 5.PASSWORD_REUSE_TIME: 指定了口令不能重用之前多少天之内的使用的密码。</span></span><br><span class="line"><span class="comment">-- 6.PASSWORD_REUSE_MAX: 在达到PASSWORD_REUSE_TIME指定时间后，要再次使用同一口令前必须改变的次数。</span></span><br><span class="line"><span class="comment">--   如：PASSWORD_REUSE_TIME=30，PASSWORD_REUSE_MAX=10，用户可以在30天以后重用该口令，要求口令必须被改变超过10次。</span></span><br><span class="line"><span class="comment">-- 7.PASSWORD_VERIFY_FUNCTION: Oracle允许将复杂的PL/SQL密码验证脚本做为参数传递给PASSWORD_VERIFY_FUNCTION。并且其自己提供了一个默认的脚本，但是用户可以创建自己的验证规则或使用第三方软件验证。</span></span><br><span class="line"><span class="comment">-- 8.Password Verify Function：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合检测函数说明：不能包含双引号&quot;(防注入)</span></span><br><span class="line"><span class="comment">--- ?/rdbms/admin/utlpwdmg.sql可能使用到的参数说明</span></span><br><span class="line"><span class="comment">-- ora_complexity_check( </span></span><br><span class="line"><span class="comment">-- password varchar2,</span></span><br><span class="line"><span class="comment">--  chars integer := null,  -- 口令长度</span></span><br><span class="line"><span class="comment">--  letter integer := null, -- 大小写字母数</span></span><br><span class="line"><span class="comment">--  upper integer := null,  -- 大写字母数</span></span><br><span class="line"><span class="comment">--  lower integer := null,  -- 小写字母数</span></span><br><span class="line"><span class="comment">--  digit integer := null,  -- 数字数</span></span><br><span class="line"><span class="comment">--  special integer := null -- 特殊字符数</span></span><br><span class="line"><span class="comment">-- )</span></span><br></pre></td></tr></table></figure><h2><span id="0x02-实验指导">0x02 实验指导</span></h2><h3><span id="practise-1">Practise 1</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;; --</span><br><span class="line"></span><br><span class="line">John</span><br><span class="line">&#x27; or 1 -- </span><br></pre></td></tr></table></figure><h3><span id="practise-2">Practise 2</span></h3><p>处理一对多关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id, GROUP_CONCAT(product) <span class="keyword">AS</span> products </span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; and 0 union select database(), version() -- </span></span><br><span class="line"><span class="string">-- dbsec</span></span><br><span class="line"><span class="string">-- 8.0.35-0ubuntu0.20.04.1 </span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; and 0 union select group_concat(table_name),1 from information_schema.tables where table_schema=&#x27;dbsec&#x27; -- </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27; and 0 union select group_concat(column_name), 1 from information_schema.columns where table_name=&#x27;users&#x27; -- </span><br><span class="line"></span><br><span class="line">&#x27; and 0 union select group_concat(username),group_concat(password) from users -- </span><br></pre></td></tr></table></figure><h3><span id="practise-3">Practise 3</span></h3><p>修改cookie中的user_name</p><blockquote><p>john</p><p>somesecrect</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1, database(),0 #  </span><br></pre></td></tr></table></figure><h2><span id="0x03-访问控制">0x03 访问控制</span></h2><h3><span id="权限控制">权限控制</span></h3><h4><span id="第一部分">第一部分</span></h4><ol><li><p>创建一个用户OT1，使其仅拥有对OT用户的表CUSTOMERS，ORDERS， ORDER_ITEMS和PRODUCTS的SELECT权限；</p><ul><li><p>```sql<br>create user ot1;</p><p>— REVOKE SELECT ON customers FROM  ot1<br>— REVOKE SELECT ON products FROM  ot1</p><p>grant select on ot.customers to ot1;<br>grant select on ot.orders to ot1;<br>grant select on ot.order_items to ot1;<br>grant select on ot.products to ot1;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. l 创建一个用户OT_MANAGER，使其仅拥有对表EMPLOYEES的SELECT、UPDATE、INSERT、DELETE权限；</span><br><span class="line"></span><br><span class="line">   - ```sql</span><br><span class="line">     create user ot_manager;</span><br><span class="line">     </span><br><span class="line">     grant select, update, insert, delete on employees to ot_manager;</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li></ul></li><li><p>撤销用户OT的DBA权限；</p><ul><li>```sql<br>revoke dba from ot<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">撤销掉dba权限之后是普通用户权限吗？还是直接全部撤销掉？</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">-- 查看用户的系统权限</span><br><span class="line">SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE = &#x27;ot&#x27;;</span><br><span class="line">-- 查询用户对表的对象级权限</span><br><span class="line">SELECT * FROM DBA_TAB_PRIVS WHERE GRANTEE = &#x27;ot&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>创建一个角色OT_SELECT，要求仅有对表CUSTOMERS，ORDERS，ORDER_ITEMS，PRODUCTS的SELECT权限，并将该角色授予OT1。</p><ul><li>```sql<br>create role ot_select;<br>grant select on customers to ot_select;<br>grant select on orders to ot_select;<br>grant select on order_items to ot_select;<br>grant select on products to ot_select;<br>grant ot_select to ot1;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 第2部分</span><br><span class="line"></span><br><span class="line">1. 限制用户密码的复杂度（包括字母、数字和特殊字符等），设置每隔60天需要重新修改密码，如果用户密码连续输错3次就锁定用户（不能再登录），设置用户登录session空闲超时间隔为10分钟</span><br><span class="line"></span><br><span class="line">   - ```sql</span><br><span class="line">     -- 限制用户密码的复杂度（包括字母、数字和特殊字符等）</span><br><span class="line">     sqlplus / as sysdba</span><br><span class="line">     @?/rdbms/admin/utlpwdmg.sql  --  创建密码验证函数(请查看?/rdbms/admin/utlpwdmg.sql里面生成的验证函数)</span><br><span class="line">     alter profile default limit password_verify_function ORA12C_VERIFY_FUNCTION; -- 启用密码验证</span><br><span class="line">     </span><br><span class="line">     -- 设置每隔60天需要重新修改密码</span><br><span class="line">     alter profile default limit PASSWORD_LIFE_TIME 60; </span><br><span class="line">     -- 如果用户密码连续输错3次就锁定用户（不能再登录）</span><br><span class="line">     alter profile default limit FAILED_LOGIN_ATTEMPTS 3; </span><br><span class="line">     -- 设置用户登录session空闲超时间隔为10分钟</span><br><span class="line">     alter profile default limit IDLE_TIME 10; </span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>限制应用程序从某些固定的IP地址连接服务器</p><ul><li>```<br>tcp.validnode_checking: YES;<br>sqlnet.tcp_invited_nodes=(xxx.xxx.xxx.xxx, xxx.domain.com)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">## 0x04数据备份</span><br><span class="line"></span><br><span class="line">对实验一所用数据库，采用当前数据库用户OT进行备份，再使用与备份数据库不一样的用户名进行数据恢复（使用Oracle IMPDP/EXPDP进行备份与恢复），给出执行结果与验证截图。</span><br><span class="line"></span><br><span class="line">（提示：为了进行数据恢复，先做基于schema的数据备份，然后drop当前用户，新建用户，导入数据。 如果用户名、表空间名称不一致，可以使用REMAP_SCHEMA、REMAP_TABLESPACE 选择项进行映射。具体可参考实验指导手册。）</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">create or replace directory DBBAK_DIR as &#x27;C:\app\oracle\admin\XE\dpdump\test&#x27;;</span><br><span class="line"></span><br><span class="line">-- 注：directory=dba_dir 必须在账号密码的后面，如果放在其他位置 也会有以下报错</span><br><span class="line"></span><br><span class="line">grant read,write on directory DBBAK_DIR to ot; </span><br><span class="line">create user testuser identified by abcd;</span><br><span class="line">grant read,write on directory DBBAK_DIR to testuser;</span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expdp OT/abcd@xepdb1 schemas=OT directory=DBBAK_DIR dumpfile=ot_backup.dmp logfile=ot_backup.log</span><br><span class="line">drop user ot cascade</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant dba to testuser;</span><br><span class="line">impdp testuser/abcd@xepdb1 directory=DBBAK_DIR dumpfile=ot_backup.dmp logfile=test-imp.log remap_schema=<span class="string">&#x27;OT:TESTUSER&#x27;</span></span><br><span class="line">impdp <span class="string">&#x27;sys@xepdb1 as sysdba&#x27;</span> directory=DBBAK_DIR dumpfile=ot_backup.dmp logfile=test-imp.log remap_schema=<span class="string">&#x27;OT:OT2&#x27;</span></span><br></pre></td></tr></table></figure><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet学习日志</title>
      <link href="/2023/12/11/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/Servlet%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/12/11/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/Servlet%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>记录写servlet时候遇到的知识点</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h3><span id="requestsetattribute用法">request.setAttribute用法</span></h3><ul><li><code>request.getAttribute</code>标识从 <code>request</code>范围取得设置的属性，必须要先<code>setAttribute</code> 设置属性，才能够通过<code>getAttribute</code> 来获取，设置与取得的为<code>Object</code>对象类型</li><li><code>request.getParameter</code>表示接收参数，参数为页面提交的参数，这个没有设置参数的方法，而且接收参数的类型是String</li><li>使用<code>request.setAttribute</code>时不能使<code>redirect</code>而是<code>forward</code>。即是将请求转发而不是重定向</li></ul><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>api-fox学习日志</title>
      <link href="/2023/12/08/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/api-fox%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/12/08/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/api-fox%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数分第15周学习日志</title>
      <link href="/2023/12/08/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC15%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/12/08/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC15%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>定积分应用</p><span id="more"></span><h2><span id="0x01-平面面积计算">0x01 平面面积计算</span></h2><h3><span id="1-直角坐标系下平面图形面积的计算">1 直角坐标系下平面图形面积的计算</span></h3><h4><span id="直角坐标系">直角坐标系</span></h4><p>对于两个图形围成的面积可以看作若干个条形的矩形面积和，即 $dS\approx (f(t)-g(t))\Delta x$</p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221150496.png" alt="image-20231211221150496"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221206241.png" alt="image-20231211221206241"></li></ul><p>当然需要连续曲线的条件，此外也可以横过来看，即：</p><ul><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221216745.png" alt="image-20231211221216745"></p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221227649.png" alt="image-20231211221227649"></p></li></ul><h4><span id="例1">例1</span></h4><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221320977.png" alt="image-20231211221320977"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221345484.png" alt="image-20231211221345484"></li><li>先判断是否连续，之后看看能否大致画出来，之后求交点，找到上下界，最后积分</li><li>要注意求的是所围图形的面积，即绝对是大于等于0的</li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221529770.png" alt="image-20231211221529770"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221538534.png" alt="image-20231211221538534"></li><li>这里就要确认什么时候要给他分割开，省的面积反而被剪掉了</li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221633246.png" alt="image-20231211221633246"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221641453.png" alt="image-20231211221641453"></li><li>这里就是平面上的第二种考法了，直接转换成dy积分</li></ul><h3><span id="2-参数方程表示曲线围城平面图形面积">2 参数方程表示曲线围城平面图形面积</span></h3><h4><span id="定理1-参数方程">定理1 参数方程</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221821543.png" alt="image-20231211221821543"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211221839902.png" alt="image-20231211221839902"></li><li>$u(t)$要严格单调，这个相当于x轴，$v(t)$要连续就行</li><li>之后注意这里是求图形面积，所以带了一个绝对值符号，不然正负号的判断更加抽象</li></ul><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211223036676.png" alt="image-20231211223036676"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211223049351.png" alt="image-20231211223049351"></li></ul><h4><span id="定理2-闭合曲线参数方程">定理2 闭合曲线参数方程</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211223222852.png" alt="image-20231211223222852"></p><ul><li>注意这里面的正定向是逆时针，参数方程转换的函数值起始点与终止点数值相同，曲线除端点重合外无自交点。</li><li>需要函数的导数存在且连续</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211225245936.png" alt="image-20231211225245936"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211225300232.png" alt="image-20231211225300232"></li><li>注意这个正负号的差别，如果忘加绝对值了就容易导致正好求出来相反数。</li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211225318548.png" alt="image-20231211225318548"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231211225326858.png" alt="image-20231211225326858"></li><li>这里选中的点就是(0,2)，其实选中的任意一个点只要转一圈都可以，那为什么不选一个简单呢:laughing:</li></ul><h3><span id="3-极坐标系下平面图形面积的计算">3 极坐标系下平面图形面积的计算</span></h3><h4><span id="极坐标">极坐标</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212111334128.png" alt="image-20231212111334128"></p><ul><li>这个可以类比于圆的面积的计算，只不过这个圆的r相当于常量</li><li>考点就是基本的公式调用与上下界的确定，注意条件要保证连续</li></ul><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212111752317.png" alt="image-20231212111752317"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212111926362.png" alt="image-20231212111926362"></li><li>考点1：利用对称性</li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212111939750.png" alt="image-20231212111939750"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212112008520.png" alt="image-20231212112008520"></li><li>这个东西吧，图要画出来那就好弄的多</li><li>不妨记一下，双扭线的形状</li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212112032873.png" alt="image-20231212112032873"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212112042643.png" alt="image-20231212112042643"></li></ul><h2><span id="0x02-旋转曲面面积">0x02 旋转曲面面积</span></h2><h3><span id="圆锥体的侧面积">圆锥体的侧面积</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212112514575.png" alt="image-20231212112514575"></p><ul><li>这里这个$\theta$的表达式要记住</li></ul><h3><span id="圆台的侧面积">圆台的侧面积</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212200537930.png" alt="image-20231212200537930"></p><ul><li>相当于大圆锥减去小圆锥</li></ul><h3><span id="旋转曲面面积">旋转曲面面积</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212202859714.png" alt="image-20231212202859714"></p><ul><li>$\sqrt{1+[f’(x)]^2}dx$大抵可以理解为 $\Delta z =\sqrt{\Delta x^2 + \Delta y^2}$</li><li>$2\pi f(x)$可以理解为 $\pi(f(x)+f(x+dx))$，相当于圆台 $l$就是 $\Delta z$</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205111710.png" alt="image-20231212205111710"></li></ul><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205248645.png" alt="image-20231212205248645"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205253980.png" alt="image-20231212205253980"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205832751.png" alt="image-20231212205832751"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205843870.png" alt="image-20231212205843870"></li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205857883.png" alt="image-20231212205857883"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205905916.png" alt="image-20231212205905916"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212205913888.png" alt="image-20231212205913888"></li><li>这里是证上面的中间步骤，很难看出来的 :cry:</li></ul><h3><span id="绕倾斜轴旋转的曲面面积">绕倾斜轴旋转的曲面面积</span></h3><h4><span id="1-区域面积">1 区域面积</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212215750784.png" alt="image-20231212215750784"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212215825690.png" alt="image-20231212215825690"></p><ul><li>$\sqrt{1+m^2}$相当于 $\cos \theta$，在图里面相当于取垂直高度</li><li>这个推导还挺麻烦的，不如记公式</li><li>这个区域面积就是灰色部分</li></ul><h4><span id="2-旋转体表面积">2 旋转体表面积</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212220001049.png" alt="image-20231212220001049"></p><ul><li>这里是按照圆台的方式来算的</li></ul><h4><span id="旋转体体积">旋转体体积</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212220338562.png" alt="image-20231212220338562"></p><ul><li>体积近似称圆柱的求解了？</li></ul><h2><span id="0x03-旋转体的体积">0x03 旋转体的体积</span></h2><h3><span id="柱体体积">柱体体积</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212221305150.png" alt="image-20231212221305150"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212221334969.png" alt="image-20231212221334969"></p><h3><span id="旋转体的体积定义">旋转体的体积定义</span></h3><h4><span id="旋转体定义">旋转体定义</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212221359158.png" alt="image-20231212221359158"></p><ul><li>一个平面图形绕一条直线旋转一周</li></ul><h4><span id="旋转体体积计算">旋转体体积计算</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212221424537.png" alt="image-20231212221424537"></p><ul><li>近似圆柱</li></ul><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212221536632.png" alt="image-20231212221536632"></p><ul><li>要我做，就大的减小的</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212221559157.png" alt="image-20231212221559157"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222019753.png" alt="image-20231212222019753"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222032896.png" alt="image-20231212222032896"></li><li>现求A(x)，之</li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222057445.png" alt="image-20231212222057445"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222107791.png" alt="image-20231212222107791"></li></ul><h4><span id="柱面体求体积">柱面体求体积</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222208257.png" alt="image-20231212222208257"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222436402.png" alt="image-20231212222436402"></p><ul><li>这个小结论要记住</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222451354.png" alt="image-20231212222451354"></p><ul><li>每个面围成的体积都视为圆柱体积差</li></ul><h4><span id="例4">例4</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222506951.png" alt="image-20231212222506951"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222514852.png" alt="image-20231212222514852"></li></ul><h2><span id="0x04-曲线的弧长">0x04 曲线的弧长</span></h2><h4><span id="曲线弧长定义">曲线弧长定义</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222635862.png" alt="image-20231212222635862"></p><ul><li>任意分割都可求</li></ul><h4><span id="光滑曲线">光滑曲线</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222649198.png" alt="image-20231212222649198"></p><h4><span id="定理">定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222700517.png" alt="image-20231212222700517"></p><ul><li><p>每一小段都近似理解为直线</p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222708761.png" alt="image-20231212222708761"></p></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222724701.png" alt="image-20231212222724701"></li><li>这种近似为直线或者近似为其他的可以用中值定理来找到一个真实的点</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222740236.png" alt="image-20231212222740236"></li></ul><h4><span id="弧长公式">弧长公式</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222756933.png" alt="image-20231212222756933"></p><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222808584.png" alt="image-20231212222808584"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222817850.png" alt="image-20231212222817850"></li><li>这里面有用到了对称性</li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222830961.png" alt="image-20231212222830961"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222845669.png" alt="image-20231212222845669"></li><li>注意复合函数要对里面的函数求导，不然容易落下 $\frac{1}{n}$</li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222915120.png" alt="image-20231212222915120"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231212222943493.png" alt="image-20231212222943493"></p><h2><span id="5-物理应用">5 物理应用</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数分第14周学习日志</title>
      <link href="/2023/12/06/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC14%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/12/06/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC14%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>定积分</p><span id="more"></span><h2><span id="1-定积分的定义与性质">1 定积分的定义与性质</span></h2><h3><span id="1-定积分概念的物理背景">1 定积分概念的物理背景</span></h3><p>求曲线围成的面积：</p><ul><li>区间分割</li><li>求累加和</li><li>取极限</li></ul><h3><span id="2-定积分的数学定义">2 定积分的数学定义</span></h3><ul><li>设 $f(x)$在[a,b]上有定义，存在实数I，对于 $\forall \epsilon&gt;0,\exists \delta&gt;0,\forall$分割 $\pi:x_0=a&lt;x_1&lt;x_2&lt;\cdots&lt;x_n=b,$当分割的细度 $||\pi||=\max_{1\leq i\leq n}(\Delta x_i)&lt;\delta, \Delta x_i=x_i-x_{i-1}$时，对任意 $\xi_i\in[x_{i-1},x_i], |\sum^n_{i=1}f(\xi_i)(x_i-x_{i-1})-I|&lt;\epsilon$，称 $f(x)$在[a,b]上黎曼可积，I为  $f(x)$在[a,b]上的定积分或黎曼积分<ul><li>记为 $\int^b_a f(x)dx=I$</li><li>注1：$\xi_i$是 $[x_{i-1},x_i]$中的一点</li><li>注2：积分的定义用 $\epsilon-\delta$语言来描述，极限符号表示为 $\lim_{||\pi||\rightarrow0}\sum^n_{i=1}f(\xi_i)(x_i-x_{i-1})=I$，与普通的函数极限不同</li></ul></li><li>$\int^b_a f(x)dx=I=\lim_{||\pi||\rightarrow0}\sum^n_{i=1}f(\xi_i)(x_i-x_{i-1}),\xi_i\in[x_{i-1},x_i]$<ul><li>$\sum^n_{i=1}f(\xi_i)\Delta x_i$：黎曼和</li><li>$f(x)$：被积函数</li><li>$x$：积分变量</li><li>$[a,b]$：积分区间</li><li>注3：$\int^b_a f(x)dx=\int^b_a f(t)dt=\int^b_a f(r)dr$与自变量选取无关</li><li>注4：若 $a&gt;b$，$\int^b_a f(x)dx=-\int^a_b f(x)dx$</li></ul></li></ul><h3><span id="3-定积分的基本性质">3 定积分的基本性质</span></h3><ul><li>假设 $f(x),g(x)$在 $[a,b]$上可积</li></ul><h4><span id="线性性质">线性性质</span></h4><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203151433730.png" alt="image-20231203151433730"></li></ul><h4><span id="保序性">保序性</span></h4><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203151507319.png" alt="image-20231203151507319"></li></ul><h4><span id="积分中值定理">积分中值定理</span></h4><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203151807426.png" alt="image-20231203151807426"></li></ul><h4><span id="两个不等式">两个不等式</span></h4><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203153440271.png" alt="image-20231203153440271"><ul><li>构造 $\int_a^b(f(x)+tg(x))^2dx$，之后看作关于t的一元二次方程</li></ul></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203153735219.png" alt="image-20231203153735219"></li></ul><h2><span id="2-定积分的存在定理">2 定积分的存在定理</span></h2><h3><span id="函数可积性理论">函数可积性理论</span></h3><h4><span id="定理1-可积的必要条件">定理1 可积的必要条件</span></h4><ul><li>函数f在[a,b]上可积，则f在[a,b]上有界<ul><li>注：可积必有界，有界未必可积</li><li>迪利克莱函数：达布上和与达布下和不相同，有理数的稠密性导致取得两种极限</li></ul></li></ul><h4><span id="定义1-达布上和与达布下和">定义1 达布上和与达布下和</span></h4><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203160209656.png" alt="image-20231203160209656"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203160356352.png" alt="image-20231203160356352"></li></ul><h4><span id="定理-2">定理 2</span></h4><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203160443260.png" alt="image-20231203160443260"></li><li>加密分割使得区间变得更小了，其中一个区间最值会有变化，造成了上和减，下和增</li><li>两种分割有联系</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203161819406.png" alt="image-20231203161819406"></li><li>两种分割虽然没有联系，但是可以将两种分割合并构造第三种分割 $\pi^*$，之后与这个分割相比较来确定不等式</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203161923254.png" alt="image-20231203161923254"></li><li>注：$f(x)$在 $[a,b]$上下确界分别为 $M,m$，则(1),(2)集合有界</li></ul><h4><span id="定理-3-达布定理">定理 3 达布定理</span></h4><ul><li>对于 $f(x)$在 $[a,b]$有界函数，则有 $\lim_{||\pi||\rightarrow0}\bar{S}(\pi,f)=\bar{I},\lim_{||\pi||\rightarrow0}\underline{S}(\pi,f)=\underline{I}$</li></ul><h4><span id="定理4">定理4</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203162736468.png" alt="image-20231203162736468"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203165049694.png" alt="image-20231203165049694"></p><h4><span id="定理-绝对可积">定理 绝对可积</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203165419715.png" alt="image-20231203165419715"></p><ul><li>定理逆命题不成立，比如说原本正好不同取值时取得是相反数，一作绝对值之后能相等了，但是他本身是不可积的，没错，我说的就是迪利克莱函数的姊妹版</li></ul><h4><span id="定理-积分对区间的可加性">定理 积分对区间的可加性</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203182435505.png" alt="image-20231203182435505"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203183340674.png" alt="image-20231203183340674"></p><h3><span id="可积函数类">可积函数类</span></h3><h4><span id="定理-1">定理 1</span></h4><p>设 $f(x)$在[a,b]上有界单调函数，则 $f(x)$在[a,b]可积</p><h4><span id="定理-2">定理 2</span></h4><p>设 $f(x)$在[a,b]上连续，则 $f(x)$在[a,b]可积</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203201255566.png" alt="image-20231203201255566"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203211226217.png" alt="image-20231203211226217"></p><h4><span id="定理-3">定理 3</span></h4><p>$f$在[a,b]上有界，则可积的充要条件是：任意 $\epsilon &gt; 0, \eta&gt;0,$总存在分割T，使得属于T的所有小区间中，对于振幅 $\omega_{k’}\geq \epsilon$的对应的分割区间长度综合 $\sum_{k’}\Delta x_{k’}&lt;\eta$</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203211820859.png" alt="image-20231203211820859"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203212033660.png" alt="image-20231203212033660"></p><h4><span id="例题">例题</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203212236347.png" alt="image-20231203212236347"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203212247930.png" alt="image-20231203212247930"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203212904636.png" alt="image-20231203212904636"></p><p>有理点有限个的原因是 $q\leq \frac{1}{\epsilon}$，而不是趋于无穷</p><p>为什么是2K个，我估计是 $\frac{p}{q},\frac{q-p}{q}$两个对称上了</p><p>先判断可积，根据下积分定积分。</p><h2><span id="3-微积分的基本定理">3 微积分的基本定理</span></h2><h3><span id="1-牛顿-莱布尼兹公式">1 牛顿-莱布尼兹公式</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215308742.png" alt="image-20231203215308742"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215323358.png" alt="image-20231203215323358"></li></ul><h3><span id="例题">例题</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215553771.png" alt="image-20231203215553771"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215604794.png" alt="image-20231203215604794"></li><li>分区间讨论不错</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215614812.png" alt="image-20231203215614812"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215627646.png" alt="image-20231203215627646"></li><li>要认出来黎曼积分的等价形式</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215642375.png" alt="image-20231203215642375"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215659194.png" alt="image-20231203215659194"></li><li>同样，结合之前学的求极限方法来求解</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215712930.png" alt="image-20231203215712930"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203215720592.png" alt="image-20231203215720592"></li><li>分区间讨论</li></ul><h3><span id="2-微积分基本定理变上限函数的连续与可导">2 微积分基本定理：变上限函数的连续与可导</span></h3><h4><span id="变上限积分函数">变上限积分函数</span></h4><p>$f\in R<a href="[a,b]上可积函数的集合">a,b</a>,\forall x\in[a,b],F(x)=\int_a^x f(t)dt$</p><ul><li>$F(x)$是变上限积分函数</li></ul><h4><span id="定理1">定理1</span></h4><p>若 $f\in R[a,b]$，则 $F(x)\in C[a,b]$</p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220547031.png" alt="image-20231203220547031"></li></ul><h4><span id="定理-2-变上限积分函数的可导性质">定理 2 变上限积分函数的可导性质</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220631098.png" alt="image-20231203220631098"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220639460.png" alt="image-20231203220639460"></li><li>变上限积分函数不一定始终可导哈，需要<strong>连续</strong></li></ul><h4><span id="推论-1">推论 1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220708659.png" alt="image-20231203220708659"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220721195.png" alt="image-20231203220721195"></li></ul><h4><span id="推论-2">推论 2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220732686.png" alt="image-20231203220732686"></p><ul><li>注意这个负号</li></ul><h4><span id="推论-3">推论 3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220749014.png" alt="image-20231203220749014"></p><h4><span id="定理-3-原函数存在定理">定理 3 原函数存在定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231203220757560.png" alt="image-20231203220757560"></p><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204082700058.png" alt="image-20231204082700058"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204082814246.png" alt="image-20231204082814246"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204082830558.png" alt="image-20231204082830558"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204082844003.png" alt="image-20231204082844003"></li></ul><h3><span id="典型例题">典型例题</span></h3><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204083835644.png" alt="image-20231204083835644"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204084304157.png" alt="image-20231204084304157"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204084758835.png" alt="image-20231204084758835"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204084812246.png" alt="image-20231204084812246"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204085939327.png" alt="image-20231204085939327"></li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204093515328.png" alt="image-20231204093515328"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204093527365.png" alt="image-20231204093527365"></li></ul><h2><span id="4-定积分的计算">4 定积分的计算</span></h2><h3><span id="分部积分公式与应用">分部积分公式与应用</span></h3><h4><span id="分部积分公式">分部积分公式</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204094245599.png" alt="image-20231204094245599"></p><hr><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204094318949.png" alt="image-20231204094318949"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204094328496.png" alt="image-20231204094328496"></li><li>先当不定积分算，算出来之后用上界下界求值</li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204095034904.png" alt="image-20231204095034904"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204095026618.png" alt="image-20231204095026618"></li><li>常规题型</li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204095138853.png" alt="image-20231204095138853"></p><ul><li>也是常规题型</li></ul><h4><span id="例4">例4</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204095249739.png" alt="image-20231204095249739"></p><ul><li>利用分部积分公式找递推关系式</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204095445094.png" alt="image-20231204095445094"></li></ul><hr><h4><span id="定理-taylor公式的积分余项">定理 Taylor公式的积分余项</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204095612036.png" alt="image-20231204095612036"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204095747441.png" alt="image-20231204095747441"></li></ul><hr><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204100214914.png" alt="image-20231204100214914"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204101139982.png" alt="image-20231204101139982"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204101151175.png" alt="image-20231204101151175"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204101204795.png" alt="image-20231204101204795"></li><li>感觉是道直觉题，能够找到正确的路子就会好算很多</li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204101305527.png" alt="image-20231204101305527"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204102112360.png" alt="image-20231204102112360"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204102212951.png" alt="image-20231204102212951"></li></ul><hr><h3><span id="定积分的换元公式与应用">定积分的换元公式与应用</span></h3><h4><span id="定积分换元定理">定积分换元定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204102711705.png" alt="image-20231204102711705"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204103044155.png" alt="image-20231204103044155"></li><li>这里可能出现 $\varphi(t)$不单调进而导致上下界一样的情况吧。-&gt; 注意条件3，需要满足代换后的上下界满足 $\phi(\alpha)=a,\phi(\beta)=b$才可以</li></ul><h4><span id="推论1">推论1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204103807654.png" alt="image-20231204103807654"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204103959553.png" alt="image-20231204103959553"></li></ul><h4><span id="推论2">推论2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204104037798.png" alt="image-20231204104037798"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204104049428.png" alt="image-20231204104049428"></li><li>在计算中可以利用奇偶性与周期性简化运算</li></ul><hr><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204104233319.png" alt="image-20231204104233319"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204104240207.png" alt="image-20231204104240207"></li><li>这个正好约掉了，好巧妙</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204105708753.png" alt="image-20231204105708753"></li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204105720358.png" alt="image-20231204105720358"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204105728467.png" alt="image-20231204105728467"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204105739366.png" alt="image-20231204105739366"></li></ul><h4><span id="例4">例4</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204105933170.png" alt="image-20231204105933170"></p><ul><li>常见错误，代换时忽略了换元的取值限制</li></ul><h4><span id="定积分换元定理2">定积分换元定理2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204110152145.png" alt="image-20231204110152145"></p><hr><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204111818944.png" alt="image-20231204111818944"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204111834115.png" alt="image-20231204111834115"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204123446921.png" alt="image-20231204123446921"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204123459351.png" alt="image-20231204123459351"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204123514043.png" alt="image-20231204123514043"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204123523876.png" alt="image-20231204123523876"></li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204123538142.png" alt="image-20231204123538142"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204123549317.png" alt="image-20231204123549317"></li><li>这个变化抽象的很啊，要分清其中的常数部分</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204123556166.png" alt="image-20231204123556166"></li></ul><h2><span id="5-定积分中值定理">5 定积分中值定理</span></h2><h3><span id="定积分第一中值定理">定积分第一中值定理</span></h3><h4><span id="定理-积分第一中值定理">定理 积分第一中值定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204130131424.png" alt="image-20231204130131424"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204130151753.png" alt="image-20231204130151753"></li><li>注意不变号的条件哦</li></ul><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204130219095.png" alt="image-20231204130219095"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204130228847.png" alt="image-20231204130228847"></li><li>这个分的有点意思</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204162941659.png" alt="image-20231204162941659"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204162956564.png" alt="image-20231204162956564"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204170329789.png" alt="image-20231204170329789"></li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204170343514.png" alt="image-20231204170343514"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204170355773.png" alt="image-20231204170355773"></li><li>根据分母来讨论</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204170402913.png" alt="image-20231204170402913"></li></ul><h3><span id="定积分第二中值定理">定积分第二中值定理</span></h3><h4><span id="积分第二中值定理">积分第二中值定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204190714477.png" alt="image-20231204190714477"></p><ul><li><p>非负且单调</p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204190730270.png" alt="image-20231204190730270"></p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204192128366.png" alt="image-20231204192128366"></p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204192403599.png" alt="image-20231204192403599"></p></li><li><p>牛逼</p></li></ul><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204192420555.png" alt="image-20231204192420555"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204192430866.png" alt="image-20231204192430866"></li><li>确实是个好思路，通过中值定理来讲不好处理的量提出来</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204192446467.png" alt="image-20231204192446467"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204192502378.png" alt="image-20231204192502378"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204192510804.png" alt="image-20231204192510804"></li></ul><h3><span id="定积分第三中值定理">定积分第三中值定理</span></h3><h4><span id="定理3-积分第三中值定理">定理3 积分第三中值定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201226437.png" alt="image-20231204201226437"></p><ul><li>首先得可积，提出来的那个需要单调</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201249156.png" alt="image-20231204201249156"></li><li>重点得想出来构造这样一个函数</li></ul><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201305984.png" alt="image-20231204201305984"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201315142.png" alt="image-20231204201315142"></li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201331622.png" alt="image-20231204201331622"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201343110.png" alt="image-20231204201343110"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201352063.png" alt="image-20231204201352063"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204201403660.png" alt="image-20231204201403660"></li></ul><h2><span id="6-勒贝格定理">6 勒贝格定理</span></h2><h3><span id="勒贝格定理">勒贝格定理</span></h3><h4><span id="定义-零测集">定义 零测集</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215402036.png" alt="image-20231204215402036"></p><h4><span id="例题">例题</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215420891.png" alt="image-20231204215420891"></p><ul><li>$|I_i|$ 应该是集合的长度和</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215428030.png" alt="image-20231204215428030"></p><h4><span id="零测集性质">零测集性质</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215504336.png" alt="image-20231204215504336"></p><h4><span id="勒贝格定理">勒贝格定理</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215516864.png" alt="image-20231204215516864"></p><h4><span id="推论-函数可积的四则运算法则">推论 函数可积的四则运算法则</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215532614.png" alt="image-20231204215532614"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215652798.png" alt="image-20231204215652798"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215704401.png" alt="image-20231204215704401"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215714643.png" alt="image-20231204215714643"></li></ul><h3><span id="勒贝格定理应用">勒贝格定理应用</span></h3><h4><span id="例1">例1</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215751992.png" alt="image-20231204215751992"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215807584.png" alt="image-20231204215807584"></li><li>这个 $2k+\frac{1}{2}$应该是随便取得一个例子</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215820837.png" alt="image-20231204215820837"></li><li>运用勒贝格定理的方法也就是先去找不连续点，找完观察集合是否为零测集</li></ul><h4><span id="例2">例2</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215833674.png" alt="image-20231204215833674"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215848509.png" alt="image-20231204215848509"></li></ul><h4><span id="例3">例3</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215906495.png" alt="image-20231204215906495"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215913436.png" alt="image-20231204215913436"></li></ul><h4><span id="例4">例4</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215926384.png" alt="image-20231204215926384"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215934788.png" alt="image-20231204215934788"></li></ul><h4><span id="例5">例5</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215947376.png" alt="image-20231204215947376"></p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231204215954865.png" alt="image-20231204215954865"></li></ul><h2><span id="7-积分应用函数的磨光">7 积分应用：函数的磨光</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GANLM: Encoder-Decoder Pre-training with an Auxiliary Discriminator</title>
      <link href="/2023/11/27/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/GANLM-Encoder-Decoder-Pre-training-with-an-Auxiliary-Discriminator/"/>
      <url>/2023/11/27/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/GANLM-Encoder-Decoder-Pre-training-with-an-Auxiliary-Discriminator/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>GANLM论文翻译</p><span id="more"></span><h2><span id="abstract">Abstract</span></h2><p>Pre-trained models have achieved remarkable success in natural language processing (NLP). However, existing pre-training methods underutilize the benefits of language understanding for generation. Inspired by the idea of Generative Adversarial Networks (GANs), we propose a GAN-style model for encoder-decoder pretraining by introducing an auxiliary discriminator, unifying the ability of language under standing and generation in a single model. Our model, named as GANLM, is trained with two pre-training objectives: <strong>replaced token detection and replaced token denoising</strong>. Specifically, <strong>given masked source sentences, the generator outputs the target distribution and the discriminator predicts whether the target sampled tokens from distribution are incorrect. The target sentence is replaced with misclassified tokens to construct noisy previous context, which is used to generate the gold sentence</strong>. In general, both tasks improve the ability of language understanding and generation by selectively using the denoising data. Extensive experiments in language generation benchmarks show that GANLM with the powerful language understanding capability outperforms various strong pre-trained language models (PLMs) and achieves state-of-the-art performance.</p><blockquote><p>underutilize vt.未充分使用</p><p>auxiliary adj. 辅助的</p><p>unify v.联合</p><p>replace token detection 替换token检测</p><p>replace token denoising 替换token去噪</p><p>gold sentense</p></blockquote><p>预训练模型在自然语言处理(NLP)领域取得了显著的成功。然而，现有的预训练方法没有充分利用语言理解对生成的好处。受生成对抗网络(GANs)思想的启发，通过引入辅助判别器，提出了一种用于编码器-解码器预训练的gan风格的模型，将语言理解和生成的能力统一在单个模型中。该模型名为GANLM，使用两个预训练目标进行训练:<strong>替换token检测和替换token去噪</strong>。具体来说，<strong>给定掩码源句子，生成器输出目标分布，鉴别器预测来自分布的目标采样token是否不正确。将目标句子替换为错误分类的token，构建有噪声的前一个上下文，用于生成黄金句子</strong>。总的来说，这两项任务都通过有选择地使用去噪数据来提高语言理解和生成的能力。在语言生成基准上的广泛实验表明，具有强大语言理解能力的GANLM优于各种强大的预训练语言模型(plm)，并取得了最先进的性能。</p><h2><span id="1-introduction">1 Introduction</span></h2><p>​    The pre-training-then-fine-tuning paradigm has been proven successful in many natural language processing tasks (Devlin et al., 2019; Liu et al., 2019; Schick and Schütze, 2021). While there are various pre-training approaches for the encoder only architectures (Clark et al., 2020; Conneauet al., 2020), the encoder-decoder pre-training is underexplored, which is essential for natural language generation. To pre-train the entire encoder-decoder model, BART (Lewis et al., 2020) proposes a denoising language model objective and T5 (Raffelet al., 2020) pre-trains the models with a span corruption objective. Furthermore, mBART (Liu et al., \2020) and mT5 (Xue et al., 2021) extend them to be multilingual pre-trained language models. </p><p>​    预训练-然后微调的范式已被证明在许多自然语言处理任务中是成功的(Devlin等人，2019;Liu等人，2019;Schick and Schütze, 2021)。虽然有各种针对仅编码器架构的预训练方法(Clark等人，2020;Conneauet al.， 2020)，编码器-解码器预训练尚未得到充分开发，而这对自然语言生成至关重要。为了预训练整个编码器-解码器模型，BART (Lewis et al.， 2020)提出了去噪语言模型目标，T5 (Raffelet al.， 2020)预训练具有跨度破坏目标的模型。此外，mBART (Liu et al.， \2020)和mT5 (Xue et al.， 2021)将它们扩展为多语言预训练语言模型。</p><p>​    Unlike most encoder-decoder pre-training methods that simply apply sequence-to-sequence tasks on a single encoder-decoder architecture, we explore the approaches to pre-train the model in a GAN-style manner with an auxiliary discriminator. GAN (Goodfellow et al., 2014) performs well on both text and image generation tasks by combining the generator and discriminator. It aims to improve the ability of the generator to produce high quality samples, which is important for the encoder decoder pre-training when transferred to down stream generation tasks. Similarly, MaskGAN (Fedus et al., 2018) shows the GAN-like training can improve the quality of the autoregressive language model. Therefore, it is intuitive to leverage GAN to empower the encoder-decoder pre-training by unifying language understanding and generation. </p><p>​    与大多数仅在单个编码器-解码器架构上应用序列到序列任务的编码器-解码器预训练方法不同，本文探索了用辅助判别器以gan风格的方式预训练模型的方法。GAN (Goodfellow等人，2014)通过结合生成器和鉴别器，在文本和图像生成任务上表现良好。它旨在提高生成器产生高质量样本的能力，这对于将编码器-解码器预训练迁移到下游生成任务时很重要。同样，MaskGAN (Fedus et al.， 2018)表明类gan训练可以提高自回归语言模型的质量。因此，利用GAN通过统一语言理解和生成来增强编码器-解码器预训练是很直观的。</p><p>​    In this work, we propose a pre-training frame work GANLM, using GAN-style learning to improve the transferability of pre-trained language models for the natural language generation. Specifically, the encoder reads the masked source sentence and the generator obtains target distribution. Then, the discriminator distinguishes whether each token sampled from the target distribution matches the target gold sentence (replaced token detection). The misclassified tokens by discriminator are regarded as hard tokens for the generator to predict accurately. We replace original tokens in the target sentence with misclassified sampled ones to construct the noisy previous context for predicting the target sentence (replaced token denoising). In Figure 1,the generator predicts the masked words “guardian watered”, where the incorrect token “guardian” and correct token “watered” are both misclassified into REPLACED and ORIGINAL by the discriminator. Next, we resample a different token “watering” from the generated distribution. Consequently, the target tokens “gardener watered” are replaced with the sampled tokens “guardian watering” to construct the noisy sample. The generator predicts the next word conditioned on previous noisy tokens (replaced token denoising). Through combing two tasks, GANLM strengthen generation performance with the enhanced language understanding capability from the replaced token detection task.</p><p>​    本文提出一种预训练框架GANLM，用gan风格的学习来提高预训练语言模型的可迁移性，用于自然语言生成。具体来说，编码器读取被掩码的源语句，生成器获得目标分布。然后，鉴别器区分从目标分布中采样的每个token是否与目标黄金句子匹配(替换token检测)。判别器将误分类的词项视为硬词项，供生成器进行准确预测。我们将目标句子中的原始标记替换为错误分类的采样标记，以构建含噪的前一个上下文来预测目标句子(替换标记去噪)。在图1中，生成器预测了被屏蔽的单词” guardian “，其中不正确的标记” guardian “和正确的标记” “都被判别器错误地分类为替换标记和原始标记。接下来，我们从生成的分布中重新采样不同的token “浇水”。因此，将目标标记” gardener “替换为采样标记” guardian “来构建噪声样本。生成器根据之前的噪声标记(替换的标记去噪)预测下一个单词。通过将两个任务相结合，GANLM增强了生成性能，并增强了替换token检测任务的语言理解能力。</p><p>​    Our method is effective for text generation and can be extended to natural language understanding tasks. We pre-train GANLM model on large-scale monolingual corpora and evaluate the performance of our pre-trained English model GANLM and multilingual model GANLM-m on various downstream tasks, including text summarization, machine translation, and data-to-text generation. Experimental results demonstrate that our method substantially outperforms previous pre-trained encoder and sequence-to-sequence models on generation tasks. Our method is further tested on GLUE (Wang et al.,\2019) and XNLI (Conneau et al., 2018) to validate the transferability of our pre-trained model. Analytic experiments emphasize the importance of the discriminator in both the pre-training and finetuning stage, leading to better performance.</p><p>​    该方法对文本生成是有效的，可以扩展到自然语言理解任务。在大规模单语语料库上预训练了GANLM模型，并评估了预训练英语模型GANLM和多语言模型GANLM-m在各种下游任务上的性能，包括文本摘要、机器翻译和数据到文本生成。实验结果表明，该方法在生成任务上大大优于之前的预训练编码器和序列到序列模型。我们的方法在GLUE (Wang et al.，\2019)和XNLI (Conneau et al.， 2018)上进行了进一步测试，以验证预训练模型的可移植性。分析性实验强调了判别器在预训练和微调阶段的重要性，从而获得了更好的性能。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231127231837770.png" align="center"></p><p>Figure 1: A pre-training sample of our method, where replaced token detection (discriminator) and replaced token denoising (generator) are used for pre-training. The discriminator classifies each generated token into REPLACED or ORIGINAL, where REPLACED denotes the predicted token is different from the gold token. The red fonts denote incorrect predictions.</p><p>图1:我们方法的预训练样本，其中替换的token检测(鉴别器)和替换的token去噪(生成器)用于预训练。鉴别器将每个生成的token分类为替换的或原始的，替换表示预测的token不同于黄金token。红色字体表示错误的预测。</p><h2><span id="2-ganlm">2 GANLM</span></h2><h3><span id="21-model-overview">2.1 Model Overview</span></h3><p>Our GAN-style pre-trained model comprises a generator (<em>G</em>) and discriminator (<em>D</em>), which are both encoder-decoder frameworks and conditioned on the same encoder (Enc). In Figure 2, the encoder reads the masked sentence and the generator decoder obtains the target distribution. Then the discriminator decoder distinguishes whether each token in the sampled target sentence matches the gold reference. Tokens in the target gold sentence are randomly replaced with misclassified ones by the discriminator to construct the noisy sample, which is fed into the generator decoder to predict the target sentence (replaced token denoising).</p><p>我们的生成对抗网络（GAN）风格预训练模型包括一个生成器 (<em>G</em>) 和一个判别器 (<em>D</em>)，它们都是编码器-解码器框架，并且都在相同的编码器（Enc）的条件下。在图2中，编码器读取被掩码的句子，生成器解码器获取目标分布。然后，判别器解码器区分采样目标句子中的每个标记是否与黄金参考匹配。目标黄金句子中的标记会被判别器随机替换为被错误分类的标记，以构建含噪样本，然后将其输入生成器解码器以预测目标句子（替换标记去噪）。</p><h3><span id="22-masked-sequence-generator">2.2 Masked Sequence Generator</span></h3><p>Given a monolingual sentence $x = (x_1,\cdots,x_n)$ with $n$ words from the dataset $D_k$ of language $L_k \in L_{all}=\{L_1,\cdots,L_K\}(|L_{all}|=K)$, some random spans of contiguous tokens in $x$ corrupted as the source sentence, which is denoted as $x^{src}=(x_1,\cdots,x_{\backslash u:v},\cdots,x_n)$. $x_{\backslash u:v}$ is a masked span of $x_{u:v}$, where the fragment from position $u$ to $v$ is corrupted by [MASK]. Given $x^{src}$, the generator predicts the original identities of the masked tokens $x^{trg}=(x_{\backslash 1},\cdots,x_{\backslash u:v},\cdots,x_{\backslash n})$ autoregressively:</p><script type="math/tex; mode=display">x^{trg}_t=Enc-Dec(x^{src},x^{trg}_{1:t-1};\{\theta_{\epsilon},\theta_{\mathcal{G}}\})</script><p>where $\theta_{\epsilon}$  and $\theta_{\mathcal{G}}$ denote the encoder and decoder parameters of the generator. Enc-Dec denotes an encoder-decoder model. The generator predicts the next position $t$ token $x^{trg}_t$ based on previous tokens. </p><p>给定一个单语句 $x = (x_1,\cdots,x_n)$，其中包含来自语言 $L_k$ 的数据集 $D_k$ 中的 $n$ 个单词，其中 $L_k \in L_{all}=\{L_1,\cdots,L_K\}$（$|L_{all}|=K$），$x$ 的一些连续标记的随机跨度被损坏，作为源句子表示为 $x^{src}=(x_1,\cdots,x_{\backslash u:v},\cdots,x_n)$。$x_{\backslash u:v}$ 是 $x_{u:v}$ 的一个掩码跨度，其中从位置 $u$ 到 $v$ 的片段被 [MASK] 损坏。给定 $x^{src}$，生成器通过自回归方式预测被掩码的标记的原始标识 $x^{trg}=(x_{\backslash 1},\cdots,x_{\backslash u:v},\cdots,x_{\backslash n})$：</p><script type="math/tex; mode=display">x^{trg}_t=Enc-Dec(x^{src},x^{trg}_{1:t-1};\{\theta_{\epsilon},\theta_{\mathcal{G}}\}) \tag 1</script><p>其中 $\theta_{\epsilon}$ 和 $\theta_{\mathcal{G}}$ 表示生成器的编码器和解码器参数。Enc-Dec 表示一个编码器-解码器模型。生成器基于先前标记预测下一个位置 $t$ 的标记 $x^{trg}_t$。</p><p>​    The training objective of sequence-to-sequence masked language modeling (S2S-MLM) on the dataset $D_k$ of language $L_k$ is defined as:</p><script type="math/tex; mode=display">\mathcal{L_{\mathcal{G}}}=E_{x\sim{D_k}}[\log P_G(x^{trg}|x^{src};\{\theta_{\epsilon},\theta_{\mathcal{G}}\})]</script><p>where $x^{src}$ and $x^{trg}$ are derived from $x$.</p><p>​    语言 $L_k$ 的序列到序列掩码语言建模（S2S-MLM）的训练目标定义为：</p><script type="math/tex; mode=display">\mathcal{L_{\mathcal{G}}}=E_{x\sim{D_k}}[\log P_G(x^{trg}|x^{src};\{\theta_{\epsilon},\theta_{\mathcal{G}}\})] \tag 2</script><p>其中 $x^{src}$ 和 $x^{trg}$ 派生自 $x$。</p><h3><span id="23-replaced-token-detection">2.3 Replaced Token Detection</span></h3><p>The generator outputs the distribution of each target token and we create a sampled sentence $\hat{x}^{trg}$ by randomly sampling tokens from the distribution. The discriminator distinguishes whether each token in<br>$\hat{x}^{trg}$ is replaced compared to $x^{trg}$. Given the target distribution $P_G(x^{trg}_t|x^{src})(x^{trg}_t\in x^{src})$ from the generator, we construct $\hat{x}^{trg}$ for the discriminator:</p><script type="math/tex; mode=display">\hat{x}^{trg} = REPLACE(x^{trg};x'_t) \\w.r.t. x'_t \sim P_G(x^{trg}_t|x^{src})\and(x^{trg}_t\in x^{src}) \tag 3</script><blockquote><p>w.r.t. with respect to 关于，相对于</p></blockquote><p>生成器输出每个目标标记的分布，我们通过从分布中随机抽样标记创建一个样本句子 $\hat{x}^{trg}$。判别器区分在 $\hat{x}^{trg}$ 中的每个标记是否与 $x^{trg}$ 相比发生了替换。鉴于来自生成器的目标分布 $P_G(x^{trg}_t|x^{src})(x^{trg}_t\in x^{src})$，我们为判别器构建 $\hat{x}^{trg}$：</p><script type="math/tex; mode=display">\hat{x}^{trg} = REPLACE(x^{trg};x'_t) \\\text{w.r.t. } x'_t \sim P_G(x^{trg}_t|x^{src})\and(x^{trg}_t\in x^{src}) \tag{3}</script><p>where REPLACE($\cdot$) replaces target <em>t</em>-th position unmasked token in $x^{trg}$ with the sampled token $x’_t$<br>from the generated distribution $P_G(x^{trg}_t|x^{src})$. </p><p>其中，REPLACE($\cdot$) 替换 $x^{trg}$ 中目标第 <em>t</em> 位置的未掩码标记，用来自生成分布 $P_G(x^{trg}_t|x^{src})$ 的抽样标记 $x’_t$ 替换。</p><p>​    Given the source sentence $x^{src}$ and the encoder $\theta_{\epsilon}$ , the decoder of the discriminator $\theta_{\mathcal{D}}$ obtains a sequence of hidden representations $H_d=(h_1,\cdots,h_n)$ by feeding the sampled sentence $\hat{x}^{trg}$ to the discriminator decoder:</p><script type="math/tex; mode=display">H_d =Enc-Dec(x^{src},\hat{x}^{trg};\{\theta_{\epsilon},\theta_{\mathcal{D}}\}) \tag 4</script><p>​    鉴于源句子 $x^{src}$ 和判别器的编码器 $\theta_{\epsilon}$，判别器的解码器 $\theta_{\mathcal{D}}$ 通过将抽样句子 $\hat{x}^{trg}$ 提供给判别器解码器，获得一系列隐藏表示 $H_d=(h_1,\cdots,h_n)$：</p><script type="math/tex; mode=display">H_d = Enc-Dec(x^{src},\hat{x}^{trg};\{\theta_{\epsilon},\theta_{\mathcal{D}}\}) \tag{4}</script><p>where $\theta_{\epsilon}$ and $\theta_{\mathcal{D}}$ denote the encoder and decoder parameters of the discriminator. The decoder of the discriminator $\theta_{\mathcal{D}}$ adopts the bidirectional language model to classify each input token by extracting the past and future representations.</p><p>其中，$\theta_{\epsilon}$ 和 $\theta_{\mathcal{D}}$ 分别表示判别器的编码器和解码器参数。判别器的解码器 $\theta_{\mathcal{D}}$ 采用双向语言模型，通过提取过去和未来的表示来对每个输入标记进行分类。</p><p>​    Given the representations $H_d$, the discriminator classifies sampled tokens $\hat{x}^{trg}$ into the REPLACED or ORIGINAL label with a sigmoid function $\sigma$:</p><script type="math/tex; mode=display">V=\sigma(H_dW_d)\tag 5</script><p>where $W_d\in R^{d_\epsilon \times 2}$ is the matrix projects the token representations to two categories (REPLACED or ORIGINAL) and $d_\epsilon$ is the model hidden size.</p><p>​    鉴于表示 $H_d$，判别器使用 S 型函数 $\sigma$ 将抽样标记 $\hat{x}^{trg}$ 分类为 REPLACED 或 ORIGINAL 标签：</p><script type="math/tex; mode=display">V=\sigma(H_dW_d)\tag{5}</script><p>其中 $W_d\in R^{d_\epsilon \times 2}$ 是将标记表示投影到两个类别（REPLACED 或 ORIGINAL）的矩阵，$d_\epsilon$ 是模型的隐藏大小。</p><p>​    The training objective of the replaced token detection task for the discriminator is:</p><script type="math/tex; mode=display">\mathcal{L_{\mathcal{D}}}=E_{x\sim{D_k}}[\mathbb{I}(\hat{x}^{trg}=x^{trg})\log V+\mathbb{I}(\hat{x}^{trg}\neq x^{trg})\log(1-V)] \tag 6</script><p>where $\mathbb{I}(\cdot)$ is the indicator function.</p><p>​    判别器替换标记检测任务的训练目标为：</p><script type="math/tex; mode=display">\mathcal{L_{\mathcal{D}}}=E_{x\sim{D_k}}[\mathbb{I}(\hat{x}^{trg}=x^{trg})\log V+\mathbb{I}(\hat{x}^{trg}\neq x^{trg})\log(1-V)] \tag{6}</script><p>其中 $\mathbb{I}(\cdot)$ 是指示函数。</p><h3><span id="24-replaced-token-denoising">2.4 Replaced Token Denoising</span></h3><p>Although our model structure is similar to GAN,  the generator is trained with maximum likelihood rather than the standard GAN objective due to the difficulty of the GAN training in NLP. We replace tokens in $x^{trg}$ with misclassified tokens by discriminator to construct the noisy previous context $x^{trg}_f$. If the sampled token $\hat{x}^{trg}_t=x_t$  is labeled with ORIGINAL, we will resample the token $x’_t(x’_t\neq x_t)$ from target distribution as the misclassified token to modify $x_t$ in $x^{trg}$. When $\hat{x}^{trg}_t=x’_t(x’_t\neq x_t)$ is labeled with REPLACED, the miscalssified token $x’_t$ directly replaces $x_t$ in the target sentence. Given the target sentence $x^{trg}$ and generated probabilities $P_G$, we replace tokens in $x^{trg}$ with sampled tokens as the previous noisy context:</p><script type="math/tex; mode=display">x^{trg}_f = REPLACE(x^{trg};\hat{x}^{trg}_t) \\w.r.t. \ \hat{x}^{trg}_t \sim P_G(x^{trg}_t|x^{src})\and(t\in v) \tag{7}</script><p>where $v=\{v_1,\cdots,v_p\}(|v|=p)$ denotes the positions in $x^{trg}$ of the misclassified tokens. </p><p>尽管我们的模型结构类似于 GAN，由于在自然语言处理中 GAN 训练的困难，生成器是使用最大似然而不是标准 GAN 目标进行训练。我们通过判别器用被错误分类的标记替换 $x^{trg}$ 中的标记来构建带有噪声的先前上下文 $x^{trg}_f$。如果抽样的标记 $\hat{x}^{trg}_t=x_t$ 被标记为 ORIGINAL，我们将从目标分布中重新抽样标记 $x’_t(x’_t\neq x_t)$ 作为错误分类的标记，以修改 $x^{trg}$ 中的 $x_t$。当 $\hat{x}^{trg}_t=x’_t(x’_t\neq x_t)$ 被标记为 REPLACED 时，错误分类的标记 $x’_t$ 直接替换目标句子中的 $x_t$。给定目标句子 $x^{trg}$ 和生成的概率 $P_G$，我们用抽样的标记替换 $x^{trg}$ 中的标记，形成先前的带噪声上下文：</p><script type="math/tex; mode=display">x^{trg}_f = REPLACE(x^{trg};\hat{x}^{trg}_t) \\\text{w.r.t. } \hat{x}^{trg}_t \sim P_G(x^{trg}_t|x^{src})\text{ 且 }(t\in v) \tag{7}</script><p>其中 $v=\{v_1,\cdots,v_p\}(|v|=p)$ 表示 $x^{trg}$ 中被错误分类的标记的位置。</p><p>The training objective of the replaced token denoising ($\mathcal{DG}$) task based on the source sentence $x^{src}$ and target noisy context $x^{trg}_f$ is described as:</p><script type="math/tex; mode=display">\mathcal{L_{\mathcal{DG}}}=E_{x\sim{D_{L_k}}}[-\log P(x^{trg}|x^{src},x^{trg}_f;\{\theta_{\epsilon},\theta_{\mathcal{D}}\})]\tag{8}</script><p>where $x^{trg}$ is predicted by the previous noisy tokens $x^{trg}_f$ instead of previous gold context.</p><p>基于源句子 $x^{src}$ 和目标带噪声上下文 $x^{trg}_f$ 的替换标记去噪（$\mathcal{DG}$）任务的训练目标如下：</p><script type="math/tex; mode=display">\mathcal{L_{\mathcal{DG}}}=E_{x\sim{D_{L_k}}}[-\log P(x^{trg}|x^{src},x^{trg}_f;\{\theta_{\epsilon},\theta_{\mathcal{D}}\})] \tag{8}</script><p>其中 $x^{trg}$ 是由先前的带噪声标记 $x^{trg}_f$ 预测的，而不是先前的黄金上下文。</p><h3><span id="25-multi-task-learning">2.5 Multi-task Learning</span></h3><p>Given multilingual corpora $D_{all}=\{D_1,\cdots,D_K\}$ of $K$ languages, the pre-trained model with parameters $\{\theta_{\epsilon},\theta_{\mathcal{G}}, \theta_{\mathcal{D}}\}$ is jointly trained over <em>K</em> languages to optimize the combined self-supervised objective as below:</p><script type="math/tex; mode=display">\mathcal{L_P}=\mathbb{E}_{L_k\in L_{all}}[\mathcal{L_G}+\lambda\mathcal{L_D}+\mathcal{L_DG}] \tag{9}</script><p>where $\lambda=10.0$ is the discriminator weight and $L_{all}=\{L_1,\cdots,L_K\}$. To improve model efficiency, a tiny discriminator decoder (4 layers) is adopted to help the generator decoder (12 layers).</p><p>给定 $K$ 种语言的多语料库 $D_{all}=\{D_1,\cdots,D_K\}$，使用参数 $\{\theta_{\epsilon},\theta_{\mathcal{G}}, \theta_{\mathcal{D}}\}$ 的预训练模型通过在 <em>K</em> 种语言上联合训练以优化下面的综合自监督目标：</p><script type="math/tex; mode=display">\mathcal{L_P}=\mathbb{E}_{L_k\in L_{all}}[\mathcal{L_G}+\lambda\mathcal{L_D}+\mathcal{L_DG}] \tag{9}</script><p>其中 $\lambda=10.0$ 是判别器权重，$L_{all}=\{L_1,\cdots,L_K\}$。为提高模型效率，使用一个较小的判别器解码器（4 层）来辅助生成器解码器（12 层）。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231128100203852.png" alt="image-20231128100203852"></p><p>Figure 2: Overview of GANLM, including (a) replaced token detection and (b) replaced token denoising. The encoder reads the source sentence and the generator obtains target distribution, where the generator and discriminator are supervised by the gold labels in (a). The discriminator distinguishes whether the sampled tokens “guardian watered” are replaced (both tokens are misclassified in this example). For the correct predicted token “watered”, we obtain a different token “watering” by resampling. The target tokens are replaced with the misclassified tokens to construct the noisy input, which are used to predict the gold sentence “gardener watered [EOS]” in (b).</p><p><strong>图 2：GANLM概述</strong></p><p><strong>(a) 替换标记检测</strong> 和 <strong>(b) 替换标记去噪</strong></p><p>在 (a) 中，编码器读取源句子，生成器获取目标分布，生成器和判别器在此过程中由金标签进行监督。判别器区分采样标记“guardian watered”是否被替换（在此示例中，两个标记都被错误分类）。对于正确预测的标记“watered”，我们通过重新抽样获得一个不同的标记“watering”。目标标记被替换为错误分类的标记，构建带有噪声的输入，用于预测 (b) 中的金句子“gardener watered [EOS]”。</p><h2><span id="3-discriminator-enhanced-fine-tuning">3 Discriminator-enhanced Fine-tuning</span></h2><p>To fully utilize the pre-trained parameters, we keep the auxiliary discriminator in downstream generation tasks (discriminator-enhanced fine-tuning) to enhance the generator, where both the pre-trained generator and discriminator are recycled. Given the annotated corpus $D_s$ of $K$ languages, the pretrained model $\{\theta_{\epsilon},\theta_{\mathcal{G}}, \theta_{\mathcal{D}}\}$ is optimized by:</p><script type="math/tex; mode=display">\mathcal{L_F}=\mathbb{E}_{x,y\sim D_s}[\mathcal{L_G}+\lambda\mathcal{L_D}+\mathcal{L_DG}] \tag{10}</script><p>where $x$ and $y$ are the parallel pair from $D_s$. The objective in the fine-tuning stage use the original pair  $x$ and $y$ without S2S-MLM. The generator $\{\theta_{\epsilon},\theta_{\mathcal{G}}\}$ are kept for inference by throwing out the discriminator decoder $ \theta_{\mathcal{D}}$. Alternatively, the discriminator $(\mathcal{D}:\{\theta_{\epsilon},\theta_{\mathcal{D}}\})$ or generator $(\mathcal{G}:\{\theta_{\epsilon},\theta_{\mathcal{G}}\})$ can also be separately fine-tuned on the downstream task.</p><p>为了充分利用预训练参数，我们在下游生成任务中保留辅助判别器（判别器增强微调）以增强生成器，其中预训练的生成器和判别器都得到了重复利用。给定 $K$ 种语言的带标注语料库 $D_s$，预训练模型 $\{\theta_{\epsilon},\theta_{\mathcal{G}}, \theta_{\mathcal{D}}\}$ 通过以下方式进行优化：</p><script type="math/tex; mode=display">\mathcal{L_F}=\mathbb{E}_{x,y\sim D_s}[\mathcal{L_G}+\lambda\mathcal{L_D}+\mathcal{L_DG}] \tag{10}</script><p>其中 $x$ 和 $y$ 是来自 $D_s$ 的平行语料对。微调阶段的目标使用原始对 $x$ 和 $y$，而不使用 S2S-MLM。生成器 $\{\theta_{\epsilon},\theta_{\mathcal{G}}\}$ 被保留用于推断，而判别器解码器 $ \theta_{\mathcal{D}}$ 被丢弃。或者，判别器 $(\mathcal{D}:\{\theta_{\epsilon},\theta_{\mathcal{D}}\})$ 或生成器 $(\mathcal{G}:\{\theta_{\epsilon},\theta_{\mathcal{G}}\})$ 也可以在下游任务上分别进行微调。</p><h2><span id="4-experiment-setting">4 Experiment Setting</span></h2><h3><span id="41-pre-training-details">4.1 Pre-training Details</span></h3><h4><span id="model-configuration">Model Configuration</span></h4><p>In the experiments, we adopt a sequence-to-sequence base-setting Transformer architecture with 768 hidden size, 3072 FFN (feed-forward network) dimension, 12 attention heads, and 12 encoder/decoder layers. The maximum sequence length of learned positions embeddings in the encoder/decoder is set as 1024. All token embedding matrices and output projection matrix parameters are shared for model efficiency. </p><h4><span id="模型配置">模型配置</span></h4><p>在实验中，我们采用了一个基于序列到序列的 Transformer 架构，具有 768 的隐藏大小，3072 的前馈网络（FFN）维度，12 个注意力头，以及 12 个编码器/解码器层。在编码器/解码器中学到的位置嵌入的最大序列长度被设置为 1024。为了提高模型效率，所有标记嵌入矩阵和输出投影矩阵参数都是共享的。</p><h4><span id="dataset">Dataset</span></h4><p>Following the previous work (Liu et al., 2019), our English pre-trained model GANLM is</p><p>trained on 160GB English monolingual data from BookCorpus, CC-News, OpenWebText, and CC Stories. In addition, we pre-train GANLM-m with 6TB multilingual data as the pioneering work (Maet al., 2021), which is a combination of CC100, CCNet, and Wikipedia, covering 100 languages. All texts are tokenized by SentencePiece (Kudo and Richardson, 2018) and encoded by the dictionary from XLM-R (Conneau et al., 2020).</p><h4><span id="数据集">数据集</span></h4><p>按照先前的工作（Liu et al., 2019），我们的英语预训练模型 GANLM 是在来自 BookCorpus、CC-News、OpenWebText 和 CC Stories 的 160GB 英语单语数据上训练的。此外，我们还预训了 GANLM-m，使用了 6TB 多语言数据，这是作为开创性工作（Ma et al., 2021）的一部分，涵盖了CC100、CCNet 和 Wikipedia，涵盖了 100 种语言。所有文本都由 SentencePiece（Kudo 和 Richardson, 2018）进行分词，并由 XLM-R（Conneau et al., 2020）的字典进行编码。</p><h4><span id="optimization">Optimization</span></h4><p>For S2S-MLM, we randomly mask 15% of the words in each instance with an average span length of 3 (Raffel et al., 2020). For the replaced token detection, we set the discriminator weight $\lambda=10.0$. We adopt Adam (Kingma and Ba, 2015) with a learning rate of 3e-4 and 10K warm-up steps for pre-training. The model is trained on 128 NVIDIA A100 GPUs (40GB) from scratch and each batch contains 8K samples. The English pre-trained model GANLM and multilingual model GANLM-m are trained for 500K steps. Specifically, all methods in Table 1 are pre-trained with 500K steps for a fair comparison.</p><h4><span id="优化">优化</span></h4><p>对于 S2S-MLM，我们随机地对每个实例中的 15% 单词进行屏蔽，平均跨度长度为 3（Raffel et al., 2020）。对于替换标记检测，我们设置判别器权重 $\lambda=10.0$。我们采用 Adam（Kingma 和 Ba, 2015）作为优化器，学习率为 3e-4，并进行了 10K 次热身步骤进行预训练。该模型是在 128 个 NVIDIA A100 GPU（40GB）上从头开始训练的，每个批次包含 8K 个样本。英语预训练模型 GANLM 和多语言模型 GANLM-m 训练了 500K 步。具体而言，表格1中的所有方法都进行了 500K 步的预训练，以进行公平比较。</p><h3><span id="42-downstream-tasks">4.2 Downstream Tasks</span></h3><h4><span id="monolingual-summarization">Monolingual Summarization</span></h4><p><strong>CNN / DailyMail</strong>(See et al., 2017) is an abstractive summarization dataset aiming at generating a concise summary from an English news article in CNN and DailyMail. As a popular abstractive summarization dataset, <strong>XSum</strong> (Narayan et al., 2018) compresses a BBC news article to a short one-sentence summary.</p><h4><span id="单语言摘要">单语言摘要</span></h4><p><strong>CNN/DailyMail</strong>（See et al., 2017）是一个目标生成摘要的抽象摘要数据集，旨在从 CNN 和 DailyMail 的英语新闻文章中生成简洁的摘要。作为一个受欢迎的抽象摘要数据集，<strong>XSum</strong>（Narayan et al., 2018）将 BBC 新闻文章压缩成一个简短的一句摘要。</p><h4><span id="multilingual-summarization">Multilingual Summarization</span></h4><p>To test the capability of our multilingual pre-trained model, a large-scale multilingual dataset named  <strong>WikiLingua</strong> (Ladhak et al., 2020) of 18 languages from WikiHow is used to evaluate multilingual abstractive summarization systems.</p><h4><span id="多语言摘要">多语言摘要</span></h4><p>为了测试我们多语言预训练模型的能力，我们使用了一个名为<strong>WikiLingua</strong>（Ladhak et al., 2020）的大规模多语言数据集，其中包含来自 WikiHow 的 18 种语言，用于评估多语言抽象摘要系统。</p><h4><span id="bilingual-translation">Bilingual Translation</span></h4><p>For the bilingual task, we use the <strong>WMT-14 English-German</strong>, <strong>WMT-14 English-French</strong>, and <strong>WMT-16 EnglishRomanian</strong> dataset for evaluation. WMT-14 En-De from WMT consists of 4.5M sentence pairs and the newstest2014 is used as the test set. WMT-14 EnFr is a large-scale dataset containing nearly 41M sentence pairs and newstest2014 is adopted for evaluation. WMT-16 En-Ro is comprised of original parallel sentences and back-translation data.</p><h4><span id="双语翻译">双语翻译</span></h4><p>对于双语任务，我们使用<strong>WMT-14英德</strong>、<strong>WMT-14英法</strong>和<strong>WMT-16英罗</strong>数据集进行评估。WMT-14 En-De 来自 WMT，包含 450 万个句对，newstest2014 用作测试集。WMT-14 En-Fr 是一个大规模数据集，包含近 4100 万个句对，采用 newstest2014 进行评估。WMT-16 En-Ro 由原始平行句子和反向翻译数据组成。</p><h4><span id="multilingual-translation">Multilingual Translation</span></h4><p><strong>IWSLT-17</strong> of 5 languages and <strong>WMT-10</strong> of 11 languages are utilized for multilingual translation. For IWSLT-17, English (En), German (De), Italian (It), Dutch (Nl), and Romanian (Ro) corpora are downloaded from the IWSLT-2017 benchmark. We use dev2010 for validation and tst2017 for test. For WMT-10, we use the parallel data of 11 languages from the WMT benchmark for evaluation (Wang et al., 2020).</p><h4><span id="多语言翻译">多语言翻译</span></h4><p>我们利用包含 5 种语言的<strong>IWSLT-17</strong>和包含 11 种语言的<strong>WMT-10</strong>进行多语言翻译。对于 IWSLT-17，我们从 IWSLT-2017 基准下载了英语（En）、德语（De）、意大利语（It）、荷兰语（Nl）和罗马尼亚语（Ro）语料库。我们使用 dev2010 进行验证，tst2017 进行测试。对于 WMT-10，我们使用 WMT 基准的 11 种语言的平行数据进行评估（Wang et al., 2020）。</p><h4><span id="data-to-text-generation">Data-to-Text Generation</span></h4><p>Data-to-text generation accepts multiple triplets and produces a description. WebNLG (Gardent et al., 2017) contains parallel DBpedia triple sets and short texts. The EnEn direction contains 17K triple sets and 45K short texts and the En-Ru direction contains 7K triple sets and 19K texts in Russian. The ROUGE scores on the valid set are reported for a fair comparison with the previous work (Gehrmann et al., 2021).</p><h4><span id="数据生成文本">数据生成文本</span></h4><p>数据生成文本接受多个三元组并生成描述。<strong>WebNLG</strong>（Gardent et al., 2017）包含平行的 DBpedia 三元组集和短文本。英英方向包含 17K 个三元组集和 45K 个短文本，而英俄方向包含 7K 个三元组集和 19K 个俄文文本。为了与先前的工作（Gehrmann et al., 2021）进行公平比较，报告了验证集上的 ROUGE 分数。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231128104227297.png" alt="image-20231128104227297"></p><p>Table 1: Comparison of different pre-training objectives. Particularly, all methods in this table use the base-setting model and are pre-trained with 500K steps on the same corpora for a fair comparison. We report ROUGE scores for abstractive text summarization (XSum) and BLEU scores for multilingual machine translation (IWSLT-17).</p><p>表1：不同预训练目标的比较。特别地，表中所有方法使用基础设置模型，并在相同的语料库上进行了50万步的预训练，以进行公平比较。我们报告了对抽象文本摘要（XSum）的ROUGE分数以及对多语言机器翻译（IWSLT-17）的BLEU分数。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231128104355560.png" alt="image-20231128104355560"></p><p>Table 2: Abstractive summarization results on the test set of CNN / DailyMail, and XSum. The evaluation metric is the F1 score of ROUGE (RG) scores.</p><p>表2：在CNN / DailyMail和XSum的测试集上的抽象摘要结果。评估指标是ROUGE（RG）分数的F1分数。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231128104426541.png" alt="image-20231128104426541"></p><p>Table 3: Results of our method and other baselines on multilingual abstractive summarization. We report the RG-1/RG-2/RG-L (ROUGE) F1 scores of the 18 WikiLingua languages and the average scores.</p><p>表3：我们的方法和其他基线在多语言抽象摘要上的结果。我们报告了对18种WikiLingua语言的ROUGE-1/ROUGE-2/ROUGE-L（ROUGE）F1分数以及平均分数。</p><h3><span id="43-fine-tuning-details">4.3 Fine-tuning Details</span></h3><h4><span id="abstractive-summarization">Abstractive Summarization</span></h4><p>During fine-tuning, we use the Adam (Kingma and Ba, 2015) optimizer with an initial learning rate of 1e-4 and the batch size is set as 2048 tokens on 8 V100 GPUs. The models are trained with the label smoothing cross entropy with a smoothing ratio of 0.1.</p><h4><span id="抽象摘要">抽象摘要</span></h4><p>在微调过程中，我们使用Adam优化器（Kingma和Ba，2015），初始学习率为1e-4，批大小设置为在8个V100 GPU上为2048个标记。模型使用标签平滑的交叉熵进行训练，平滑比例为0.1。</p><h4><span id="neural-machine-translation">Neural Machine Translation</span></h4><p>For the large-scale multilingual dataset WMT-10, our pre-trained model is fine-tuned on 32 V100 GPUs with a learning rate of 3e-4. For all bilingual translation tasks and the IWSLT-2017 benchmark, we adopt Adam with a learning rate of 1e-4 and set the batch size as 2048 tokens on 8 V100 GPUs.</p><h4><span id="神经机器翻译">神经机器翻译</span></h4><p>对于大规模多语言数据集WMT-10，我们的预训练模型在32个V100 GPU上进行微调，学习率为3e-4。对于所有的双语翻译任务和IWSLT-2017基准测试，我们采用Adam优化器，学习率为1e-4，并在8个V100 GPU上将批大小设置为2048个标记。</p><h4><span id="data-to-text-generation">Data-to-text Generation</span></h4><p>We use Adam with a learning rate of {8e-5,1e-4} and set the batch size as 16 sentences on the WebNLG dataset.</p><h4><span id="数据到文本生成">数据到文本生成</span></h4><p>在WebNLG数据集上，我们使用Adam优化器，学习率为{8e-5, 1e-4}，批大小设置为16个句子。</p><h2><span id="5-comparing-pre-training-objectives">5 Comparing Pre-training Objectives</span></h2><p>To verify the potential of our pre-training task under a fair comparison, we re-implement previous pre-training tasks and pre-trains baselines on the same corpora with 500K steps, including BERT/mBERT (Devlin et al., 2019), ELECTRA (Clark et al., 2020), BART (Lewis et al., 2020)/mBART (Liu et al., 2020), and T5 (Raffel et al.,2020)/mT5 (Xue et al., 2021). Table 1 reports the ROUGE and BLEU points on the summarization dataset XSum and multilingual translation dataset IWSLT-17. All models have 12 encoder and 12 decoder layers with a hidden size of 768. We observe that the encoder-decoder pre-trained model (T5/mT5) outperforms the pre-trained encoder (ELECTRA, BERT/mBERT), which corroborates the encoder-decoder pre-training is morebeneficial to the downstream generation task. Experiments ⑥<em>∼</em>⑧ show the importance of the discriminator and replaced token denoising. Experiment ⑧ demonstrates that only the replaced token detection task can still bring improvement through strengthening the encoder shared by both generator and discriminator. Besides, the replaced token detection task is also helpful to downstream language understanding tasks with a powerful encoder. Lastly, the results verify that fine-tuning with the help of the pre-trained auxiliary discriminator further improves performance.</p><p>为了在公平比较下验证我们预训练任务的潜力，我们重新实现了以前的预训练任务，并在相同的语料库上进行了500K步的预训练，包括BERT/mBERT（Devlin等人，2019）、ELECTRA（Clark等人，2020）、BART（Lewis等人，2020）/mBART（Liu等人，2020）和T5（Raffel等人，2020）/mT5（Xue等人，2021）。表1报告了在摘要数据集XSum和多语言翻译数据集IWSLT-17上的ROUGE和BLEU分数。所有模型都有12个编码器层和12个解码器层，隐藏大小为768。我们观察到编码器-解码器预训练模型（T5/mT5）优于仅进行编码器预训练的模型（ELECTRA、BERT/mBERT），这证实了编码器-解码器预训练对下游生成任务更有益。实验⑥<em>∼</em>⑧展示了鉴别器和替换标记去噪的重要性。实验⑧表明，仅替换标记检测任务仍然可以通过强化生成器和鉴别器共享的编码器来带来改善。此外，替换标记检测任务对具有强大编码器的下游语言理解任务也有帮助。最后，结果验证了在辅助预训练鉴别器的帮助下进行微调能够进一步提高性能。</p><h2><span id="6-results-of-ganlm">6 Results of GANLM</span></h2><p>The English pre-trained model GANLM is evaluated on the abstractive text summarization task with the ROUGE (Lin, 2004) scores.</p><p>英文预训练模型 GANLM 在抽象文本摘要任务上通过 ROUGE（Lin, 2004）分数进行评估。</p><h3><span id="xsum">XSum</span></h3><p>As shown in Table 2, the pre-training methods achieve significant improvements over the strong baseline PTRNET without pre-training. The sequence-to-sequence pre-trained model such as UniLMv2 + <em>s2s-ft</em> outperforms other pre-training baselines, where the pseudo-masked technique is applied to the fine-tuning stage. Our method beats all pre-training baselines by a large margin with the discriminator-enhanced fine-tuning strategy. It emphasizes the importance of the fine-tuning strategy for the performance of downstream tasks.</p><p>如表2所示，预训练方法在没有预训练的强基准模型 PTRNET 上取得了显著的改进。诸如 UniLMv2 + <em>s2s-ft</em> 这样的序列到序列预训练模型在精调阶段应用了伪掩码技术，优于其他预训练基准。我们的方法通过鉴别器增强的微调策略在所有预训练基准上大幅领先。这强调了微调策略对下游任务性能的重要性。</p><h3><span id="cnn-dailymail">CNN / DailyMail</span></h3><p>Our method is also evaluated on the CNN / DailyMail dataset in Table 2. The comparisons further indicate that our method obtains strong performance on generation by leveraging the discriminator.</p><p>我们的方法还在CNN / DailyMail数据集上进行了评估，如表2所示。进一步的比较表明，我们的方法通过利用鉴别器在生成任务上取得了强大的性能。</p><h2><span id="7-results-of-ganlm-m">7 Results of GANLM-m</span></h2><p>To evaluate the multilingual pre-trained model GANLM-m, we report the BLEU (Papineni et al., \2002) scores for machine translation and ROUGE (Lin, 2004) scores for text summarization and data to-text generation.</p><p>为了评估多语言预训练模型 GANLM-m，我们报告了机器翻译的 BLEU（Papineni等人，2002）分数，以及文本摘要和数据到文本生成的 ROUGE（Lin, 2004）分数。</p><h3><span id="wikilingua">WikiLingua</span></h3><p>Table 3 reports the average ROUGE scores of 18 WikiLingua languages. The large improvement over other pre-training method demon strate the summarization ability of our GANLM-m.</p><p>表3报告了18种 WikiLingua 语言的平均 ROUGE 分数。与其他预训练方法相比的巨大改进表明了我们的 GANLM-m 的摘要能力。</p><h3><span id="wmt14-en-de">WMT14 En-De</span></h3><p>The results on the bilingual translation are presented at Table 4. We observe that the proposed GANLM outperforms all previous works in the high-resource machine translation scenario (<em>&gt;</em> 4M sentence pairs).</p><p>双语翻译的结果显示在表4中。我们观察到，在高资源机器翻译场景（*&gt; 4M 句对）中，我们提出的 GANLM 胜过了所有先前的工作。</p><h3><span id="wmt14-en-fr">WMT14 En-Fr</span></h3><p>We further conduct experiments on the WMT14 En-Fr bilingual translation task. Table 4 GANLM-m shows that GANLM-m still brings significant improvement to the downstream task with large-scale machine translation fine tuning data (<em>&gt;</em> 40M sentence pairs).</p><p>我们在WMT14 En-Fr双语翻译任务上进一步进行实验。表4中的 GANLM-m 显示，GANLM-m 仍然在大规模机器翻译微调数据（*&gt; 40M 句对）上为下游任务带来显著的改进。</p><h3><span id="wmt16-en-ro">WMT16 En-Ro</span></h3><p>For the low-resource setting (&lt;1M sentence pairs), there is an average gain of +4 BLEU points compared to the Transformer baseline in Table 5. With the same back-translation data, GANLM-m further improves the model performance and still beats other baselines.</p><p>在低资源设置（&lt;1M 句对）中，与表5中的 Transformer 基线相比，平均 BLEU 分数提高了 +4 分。在相同的回译数据情况下，GANLM-m 进一步提高了模型性能，并仍然击败了其他基线。</p><h3><span id="wmt-10">WMT-10</span></h3><p>For the multilingual translation, we compare GANLM-m with the strong multilingual pre-trained models in Table 7 and Table 6, such as mBART (Liu et al., 2020). It is notable our method outperforms large pre-trained model mBART with 1024 hidden size by a large margin (+1<em>∼</em>2 BLEU points). Plus, there is a +1.5 BLEU gain over XLMR, whose encoder and decoder are initialized by the cross-lingual pre-trained encoder (Ma et al., 2020).</p><p>对于多语言翻译，我们在表7和表6中与强大的多语言预训练模型进行比较，如 mBART（Liu等人，2020）。值得注意的是，我们的方法在 BLEU 分数上大幅胜过具有 1024 隐藏大小的大型预训练模型 mBART（+1<em>∼</em>2 BLEU 分数）。此外，与由跨语言预训练编码器初始化的 XLM-R 相比，还有 +1.5 BLEU 的提升。</p><h3><span id="webnlg">WebNLG</span></h3><p>Table 8 presents the performance on the data-to-text generation task, showing that GANLM outperforms multilingual sequence-to sequence pre-training baselines mBART and mT5 by +2 ROUGE-L points on both languages.</p><p>表8展示了在数据到文本生成任务上的性能，表明 GANLM 在两种语言上都在 ROUGE-L 分数上优于多语言序列到序列预训练基线 mBART 和 mT5（+2 ROUGE-L 分数）。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231128105705309.png" alt="image-20231128105705309"></p><p>Table 4: Comparison with other pre-training approaches on the WMT14 En-De and WMT14 En-Fr benchmark.</p><p>表4：在WMT14 En-De和WMT14 En-Fr基准上与其他预训练方法的比较。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231128105718279.png" alt="image-20231128105718279"></p><p>Table 5: Comparison with other pre-training methods on the WMT16 En-Ro benchmark.<br>表5：在WMT16 En-Ro基准上与其他预训练方法的比较。</p><h2><span id="8-analysis">8 Analysis</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
          <category> 冯如杯专利 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习学习记录</title>
      <link href="/2023/11/27/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/11/27/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>机器学习与深度学习</p><ul><li>Transformer模型</li><li>预处理概念</li><li>T5模型</li></ul><span id="more"></span><h2><span id="0x01-transformer">0x01 Transformer</span></h2><h3><span id="overview">Overview</span></h3><ul><li><code>Transformer</code> is a model proposed by Google in 2017 for machine translation.</li><li>The inside of a Transformer is essentially an <code>Encoder-Decoder</code> structure.</li><li>The whole network structure is entirely composed of <code>Attention</code> mechanism.</li><li>Using a 6-layer <code>Encoder-Decoder</code> structure.</li><li><img src="https://pic2.zhimg.com/80/v2-d04206d1a624dcaec8d56c79bea053b1_720w.webp" alt="img"></li></ul><h3><span id="example">Example</span></h3><ul><li>For ease of understanding, we only look at one of the Encoder-Decoder structures.</li><li><img src="https://pic3.zhimg.com/80/v2-6a52fadb8ba310a12076aac79baa2be2_720w.webp" alt="img"></li><li>The encoder is responsible for mapping the language sequence into a hidden layer (step 2 above), which is a mathematical representation of the natural language sequence.</li><li>The decoder remaps the hidden layers into natural language sequences, which allows us to solve various problems such as sentiment analysis, machine translation, summary generation, semantic relation extraction, etc.</li><li>Briefly, what does each step of the diagram do:<ol><li>Input a natural language sequence to the encoder: <code>Why do we work</code>(<code>为什么要工作</code>);</li><li>The hidden layer output from the encoder is fed to the decoder;</li><li>Input the <code>&lt; &gt;</code> as the start symbol to decoder;</li><li>The decoder gets the first word “为”;</li><li>Input the “为” to decoder;</li><li>The decoder gets the second word “什”;</li><li>The process is repeated until the end symbol is printed.</li></ol></li></ul><p>The content about encoder is divided into 4 parts, which are explained in turn.</p><ul><li><img src="https://pic4.zhimg.com/80/v2-af307443f765f2ecf440534d76f7ba2b_720w.webp" alt="img"></li></ul><h3><span id="positional-encoding"><strong>Positional Encoding</strong></span></h3><ul><li><p>Input data X with dimensions <code>[batch size, sequence length]</code>, like <code>我们为什么工作</code></p><ul><li><p><code>batch size</code> is the size of batch, <code>sequence length</code> is the length of sentence. </p></li><li><p>i.e. if X=[“我们为什么工作”], batch size equals 1 and sequence length equals 7.</p></li><li>Briefly, it is the conversion of text -&gt; word vectors.</li></ul></li><li><p>Output $X_{embedding}$ with dimensions <code>[batch size, sequence length, embedding dimension]</code>.</p><ul><li>The size of embedding dimension is determined by the <code>Word2Vec</code> algorithm, <code>Tramsformer</code> uses a word vector of <code>512</code> length.</li><li>if X=[“我们为什么工作”], batch size equals 1, sequence length equals 7 and embedding dimension equals 512.</li></ul></li><li><p><img src="https://pic4.zhimg.com/80/v2-5deb991462e2794a79772bbf5cd714d7_720w.webp" alt="img"></p></li><li><p>The position of the text is important. In order to retain this location information for the Transformer to learn, we need to use <code>location embedding</code>.</p></li><li><p><code>Transformer</code> uses the sin-cos rule.</p><ul><li>$PE_{(pos,2i)}=\sin(pos/10000^{2i/d_{model}})$</li><li>$PE_{(pos,2i+1)}=\cos(pos/10000^{2i/d_{model}})$</li><li><code>pos</code> refers to the position of the word in the sentence, ranging from [0,h), i refers to the dimension of the word embedding, and the range is $[0,d_{model})$.</li></ul></li><li><p>Then unique texture location information is generated, and the model learns the dependencies between locations and the temporal characteristic of natural language.</p></li><li><p>Finally,  $X_{embedding}$ and position embeddings are added and sent to the next layer.</p></li><li><p>```python</p><h1><span id="导入依赖库">导入依赖库</span></h1><p>import numpy as np<br>import matplotlib.pyplot as plt<br>import seaborn as sns<br>import math</p><p>def get_positional_encoding(max_seq_len, embed_dim):</p><pre><code># 初始化一个positional encoding# embed_dim: 字嵌入的维度# max_seq_len: 最大的序列长度positional_encoding = np.array([    [pos / np.power(10000, 2 * i / embed_dim) for i in range(embed_dim)]    if pos != 0 else np.zeros(embed_dim) for pos in range(max_seq_len)])positional_encoding[1:, 0::2] = np.sin(positional_encoding[1:, 0::2])  # dim 2i 偶数positional_encoding[1:, 1::2] = np.cos(positional_encoding[1:, 1::2])  # dim 2i+1 奇数# 归一化, 用位置嵌入的每一行除以它的模长# denominator = np.sqrt(np.sum(position_enc**2, axis=1, keepdims=True))# position_enc = position_enc / (denominator + 1e-8)return positional_encoding</code></pre><p>positional_encoding = get_positional_encoding(max_seq_len=100, embed_dim=16)<br>plt.figure(figsize=(10,10))<br>sns.heatmap(positional_encoding)<br>plt.title(“Sinusoidal Function”)<br>plt.xlabel(“hidden dimension”)<br>plt.ylabel(“sequence length”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### **Self-attention layer**</span><br><span class="line"></span><br><span class="line">1. ![img](https://pic3.zhimg.com/80/v2-fa1f2a80f5c311fc2a51e8c1d37655b2_720w.webp)</span><br><span class="line"></span><br><span class="line">- The meaning of multi head is that the resulting matrix of $QK^T$ is called the attention matrix, and it shows how similar each word is to other words.</span><br><span class="line">- The larger the dot product, the closer the two vectors are.</span><br><span class="line">- ![img](https://pic4.zhimg.com/80/v2-3d94e8346052a261eed3356c46f05fa7_720w.webp)</span><br><span class="line">- Our goal is to have each word contain information about all the words in the current sentence, and with the attention layer, we do this. </span><br><span class="line">- It is important to note that the above `self attention` calculation in the process, we usually use `mini batch`, it is also more than a calculation of words, the above example in a sentence.</span><br><span class="line">- The length of each sentence is not the same and needs to be treated uniformly according to the length of the longest sentence. For short sentences, do the `Padding` operation, generally we use `0` to fill.</span><br><span class="line">- ![图片](https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjr1iaicSWjfKiasqX6Af1z4ibPGzLrU09tucAobKyD7hDibroHYeAuLkPgpTUHUh17o8mw5aHMKwTvKow/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">### **Residual linkage and layer normalization**</span><br><span class="line"></span><br><span class="line">- The residual design and layer normalization operations are added to prevent the gradient from disappearing and speed up the convergence.</span><br><span class="line"></span><br><span class="line">1. **residual design**</span><br><span class="line"></span><br><span class="line">   - We got in the previous step after attention matrix weighted `V`, namely `Attention(Q, K, V)`, we transpose it, making its and $X_&#123;embedding&#125;$ dimension is consistent, i.e. `[batch size, sequence length, embedding dimension]`, then we add them together to do the residual join, which adds the elements directly because they have the same dimensions.</span><br><span class="line">   - $X_&#123;embedding&#125;+Attention(Q, K,V)$</span><br><span class="line">   - In the following operation, after each module operation, the value before the operation and the value after the operation should be added to obtain the residual connection, so that the gradient can directly take a shortcut to the initial layer during training.</span><br><span class="line">   - $X+SubLayer(X)$</span><br><span class="line"></span><br><span class="line">2. **layer normalization**</span><br><span class="line"></span><br><span class="line">   - It normalizes the hidden layers of the neural network to standard normal distribution, namely `i.i.d` independent identically distributed, to speed up the training, the role of the accelerating convergence.</span><br><span class="line"></span><br><span class="line">   - $$</span><br><span class="line">     \mu_i=\frac&#123;1&#125;&#123;m&#125;\sum^m_&#123;i=1&#125;x_&#123;ij&#125;</span><br><span class="line">     $$</span><br><span class="line"></span><br><span class="line">     on the type of line in a matrix(row) average for the unit.</span><br><span class="line"></span><br><span class="line">   - $$</span><br><span class="line">     \sigma^2_j=\frac&#123;1&#125;&#123;n&#125;\sum^m_&#123;i=1&#125;(x_&#123;ij&#125;-\mu_j)^2</span><br><span class="line">     $$</span><br><span class="line"></span><br><span class="line">     on the type of line in a matrix(row) as the unit of variance.</span><br><span class="line"></span><br><span class="line">   - $$</span><br><span class="line">     LayerNorm(x)=\alpha\odot\frac&#123;x_&#123;ij&#125;-\mu_i&#125;&#123;\sqrt&#123;\sigma^2_i+\epsilon&#125;&#125;+\beta</span><br><span class="line">     $$</span><br><span class="line"></span><br><span class="line">     We introduce two trainable parameters to compensate for the information lost in the normalization process. Note that $\odot$ represents element-wise multiplication rather than dot  product, and we typically initialize $\alpha$ with all ones, and $\beta$ with all zeros.</span><br><span class="line"></span><br><span class="line">   - ```python</span><br><span class="line">     class ScaledDotProductAttention(nn.Module):</span><br><span class="line">         &#x27;&#x27;&#x27; Scaled Dot-Product Attention &#x27;&#x27;&#x27;</span><br><span class="line">     </span><br><span class="line">         def __init__(self, temperature, attn_dropout=0.1):</span><br><span class="line">             super().__init__()</span><br><span class="line">             self.temperature = temperature</span><br><span class="line">             self.dropout = nn.Dropout(attn_dropout)</span><br><span class="line">     </span><br><span class="line">         def forward(self, q, k, v, mask=None):</span><br><span class="line">             # self.temperature是论文中的d_k ** 0.5，防止梯度过大</span><br><span class="line">             # QxK/sqrt(dk)</span><br><span class="line">             attn = torch.matmul(q / self.temperature, k.transpose(2, 3))</span><br><span class="line">     </span><br><span class="line">             if mask is not None:</span><br><span class="line">                 # 屏蔽不想要的输出</span><br><span class="line">                 attn = attn.masked_fill(mask == 0, -1e9)</span><br><span class="line">             # softmax+dropout</span><br><span class="line">             attn = self.dropout(F.softmax(attn, dim=-1))</span><br><span class="line">             # 概率分布xV</span><br><span class="line">             output = torch.matmul(attn, v)</span><br><span class="line">     </span><br><span class="line">             return output, attn</span><br><span class="line">         </span><br><span class="line">     class MultiHeadAttention(nn.Module):</span><br><span class="line">         &#x27;&#x27;&#x27; Multi-Head Attention module &#x27;&#x27;&#x27;</span><br><span class="line">     </span><br><span class="line">         # n_head头的个数，默认是8</span><br><span class="line">         # d_model编码向量长度，例如本文说的512</span><br><span class="line">         # d_k, d_v的值一般会设置为 n_head * d_k=d_model，</span><br><span class="line">         # 此时concat后正好和原始输入一样，当然不相同也可以，因为后面有fc层</span><br><span class="line">         # 相当于将可学习矩阵分成独立的n_head份</span><br><span class="line">         def __init__(self, n_head, d_model, d_k, d_v, dropout=0.1):</span><br><span class="line">             super().__init__()</span><br><span class="line">             # 假设n_head=8，d_k=64</span><br><span class="line">             self.n_head = n_head</span><br><span class="line">             self.d_k = d_k</span><br><span class="line">             self.d_v = d_v</span><br><span class="line">             # d_model输入向量，n_head * d_k输出向量</span><br><span class="line">             # 可学习W^Q，W^K,W^V矩阵参数初始化</span><br><span class="line">             self.w_qs = nn.Linear(d_model, n_head * d_k, bias=False)</span><br><span class="line">             self.w_ks = nn.Linear(d_model, n_head * d_k, bias=False)</span><br><span class="line">             self.w_vs = nn.Linear(d_model, n_head * d_v, bias=False)</span><br><span class="line">             # 最后的输出维度变换操作</span><br><span class="line">             self.fc = nn.Linear(n_head * d_v, d_model, bias=False)</span><br><span class="line">             # 单头自注意力</span><br><span class="line">             self.attention = ScaledDotProductAttention(temperature=d_k ** 0.5)</span><br><span class="line">             self.dropout = nn.Dropout(dropout)</span><br><span class="line">             # 层归一化</span><br><span class="line">             self.layer_norm = nn.LayerNorm(d_model, eps=1e-6)</span><br><span class="line">     </span><br><span class="line">         def forward(self, q, k, v, mask=None):</span><br><span class="line">             # 假设qkv输入是(b,100,512),100是训练每个样本最大单词个数</span><br><span class="line">             # 一般qkv相等，即自注意力</span><br><span class="line">             residual = q</span><br><span class="line">             # 将输入x和可学习矩阵相乘，得到(b,100,512)输出</span><br><span class="line">             # 其中512的含义其实是8x64，8个head，每个head的可学习矩阵为64维度</span><br><span class="line">             # q的输出是(b,100,8,64),kv也是一样</span><br><span class="line">             q = self.w_qs(q).view(sz_b, len_q, n_head, d_k)</span><br><span class="line">             k = self.w_ks(k).view(sz_b, len_k, n_head, d_k)</span><br><span class="line">             v = self.w_vs(v).view(sz_b, len_v, n_head, d_v)</span><br><span class="line">     </span><br><span class="line">             # 变成(b,8,100,64)，方便后面计算，也就是8个头单独计算</span><br><span class="line">             q, k, v = q.transpose(1, 2), k.transpose(1, 2), v.transpose(1, 2)</span><br><span class="line">     </span><br><span class="line">             if mask is not None:</span><br><span class="line">                 mask = mask.unsqueeze(1)   # For head axis broadcasting.</span><br><span class="line">             # 输出q是(b,8,100,64),维持不变,内部计算流程是：</span><br><span class="line">             # q*k转置，除以d_k ** 0.5，输出维度是b,8,100,100即单词和单词直接的相似性</span><br><span class="line">             # 对最后一个维度进行softmax操作得到b,8,100,100</span><br><span class="line">             # 最后乘上V，得到b,8,100,64输出</span><br><span class="line">             q, attn = self.attention(q, k, v, mask=mask)</span><br><span class="line">     </span><br><span class="line">             # b,100,8,64--&gt;b,100,512</span><br><span class="line">             q = q.transpose(1, 2).contiguous().view(sz_b, len_q, -1)</span><br><span class="line">             q = self.dropout(self.fc(q))</span><br><span class="line">             # 残差计算</span><br><span class="line">             q += residual</span><br><span class="line">             # 层归一化，在512维度计算均值和方差，进行层归一化</span><br><span class="line">             q = self.layer_norm(q)</span><br><span class="line">     </span><br><span class="line">             return q, attn</span><br></pre></td></tr></table></figure></li></ul><h3><span id="feedforward-network"><strong>feedforward network</strong></span></h3><ul><li><pre><code class="lang-python">class PositionwiseFeedForward(nn.Module):    &#39;&#39;&#39; A two-feed-forward-layer module &#39;&#39;&#39;    def __init__(self, d_in, d_hid, dropout=0.1):        super().__init__()        # 两个fc层，对最后的512维度进行变换        self.w_1 = nn.Linear(d_in, d_hid) # position-wise        self.w_2 = nn.Linear(d_hid, d_in) # position-wise        self.layer_norm = nn.LayerNorm(d_in, eps=1e-6)        self.dropout = nn.Dropout(dropout)    def forward(self, x):        residual = x        x = self.w_2(F.relu(self.w_1(x)))        x = self.dropout(x)        x += residual        x = self.layer_norm(x)        return x</code></pre></li></ul><h3><span id="repeat-step-3"><strong>Repeat step 3</strong></span></h3><ul><li><script type="math/tex; mode=display">X_{hidden} = X_{attention} + X_{hidden} \\X_{hidden} = LayerNorm(X_{hidden}) \\ X_{hidden} \in R^{batch size * seq. len.* embed.dim. }</script></li><li></li></ul><h2><span id="0x02-pre-train">0x02 Pre train</span></h2><blockquote><ul><li><strong>PTM:</strong> Pre-train Model, 预训练模型</li><li><strong>LM</strong>: Language Model，语言模型</li><li><strong>AR</strong>: Auto-Regressive，自回归</li><li><strong>AE</strong>: Auto-Encoding，自编码</li><li><strong>CLM</strong>: Causual Language Model</li><li><strong>MLM</strong>: Masked Language Model</li><li><strong>PLM</strong>: Permuted Language Model</li><li><strong>NLU</strong>: Natural Language Understanding</li><li><strong>NLG</strong>: Natural Language Generation</li></ul></blockquote><h3><span id="1-whats-the-pre-train">1 What’s the pre train</span></h3><ul><li>Model parameters are no longer randomly initialized but are pretrained by some task such as language model.</li><li>The training task is decomposed into two steps: common learning and feature learning.</li></ul><h3><span id="2-how-to-pre-train">2 How to pre train</span></h3><h4><span id="21-two-basic-paradigms-autoregressivear-pretraining-and-autoencoderae-pretaining">2.1 Two basic paradigms: autoregressive(AR) pretraining and autoencoder(AE) pretaining</span></h4><p>GPT and BERT represent the two most basic pre-training paradigms. They are called “autoregressive”(e.g., GPT) and “autoencoder pre-training” (e.g., BERT), and they are suitable for different types of downstream tasks, with <strong>GPT</strong> often more suitable for <strong>text generation tasks</strong> and <strong>BERT</strong> often more suitable for <strong>text understanding tasks</strong>. Both are based on partial parameters of the Transformer architecture.</p><ul><li>GPT corresponds to the pretraining of the <strong>decoder</strong><ul><li>GPT’s full name is Generative Pre-Training.</li></ul></li><li>BERT corresponds to the pretraining of the <strong>encoder</strong><ul><li>BERT’s full name is <strong>Bidirectional</strong> Encoder Representations form Transformers.</li></ul></li></ul><h4><span id="211-gpt-gt-arlm-applicable-to-the-nlg-task">2.1.1 GPT —&gt; AR/LM , applicable to the NLG task</span></h4><p>The optimization goal of GPT is the joint probability of the model sequence (from left to right or from right to left), which is a traditional language model, and the latter predicted word is conditioned on the first predicted word, which is suitable for text generation tasks.</p><script type="math/tex; mode=display">p(x_{1;T}) = \Pi_{t=1}^Tp(x_t|x_{0:t-1})</script><h4><span id="212-bert-gt-aemlm-applicable-to-the-nlu-task">2.1.2 BERT —&gt; AE/MLM, applicable to the NLU task</span></h4><p>BERT works in a bidirectional way by replacing some tokens with special [MASK] characters and predicting these replaced characters on the target side.</p><h3><span id="3-t5-model-nlp-text-to-text">3 T5 model: NLP Text-to-Text</span></h3><ul><li>Full name is Transfer Text-to-Text Transformer.</li><li>Turn all NLP tasks into Text-to-Text tasks.</li><li>Data cleaning process<ul><li>Only lines ending with a normal symbol are kept.</li><li>Delete any pages containing Bad Words, specific words refer to <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words">List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words</a></strong></li><li>Lines that contain Javascript words are removed.</li><li>Pages containing curly braces commonly used in programming languages.</li><li>Any page that contains “lorem ipsum”</li><li>Repeat the situation in three consecutive sentences and keep one.</li></ul></li></ul><h4><span id="architecture-the-best-one">Architecture: The Best One</span></h4><p><img src="https://pic2.zhimg.com/80/v2-b1a8d9af6110e6d1b6a7615fc300a229_720w.webp" alt="img"></p><p>T5 model actually is the Encoder-Decoder model of Transformer.</p><h4><span id="objectives-search-search-search">Objectives: Search, Search, Search</span></h4><p><img src="https://pic3.zhimg.com/80/v2-247e53593f78282caf557d84c1d2c1fa_720w.webp" alt="img"></p><ol><li><p>First Part: Comparison of high-level methods (self-supervised pre-training methods)</p><ol><li>Language model style, from left to right;</li><li>Bert-style, destroy a part, and then restore it;</li><li>Deshuffling is to shuffle the text and then restore it.</li></ol><ul><li>Bert-style is the best!</li></ul></li><li><p>Second Part: A strategy when a section of text is corrupted.</p><ol><li>Mask, as most models do today, replace the corrupted token with a special character such as [M];</li><li>The replace span method, it can be regarded as synthesizing a special character from adjacent [M] in the Mask method above, and replacing a special character for each small segment to improve the calculation efficiency.</li><li>Drop method, without replacement operation, directly drops some characters at random.</li></ol><ul><li>Replace spans is the best!</li></ul></li><li><p>Third Part: What percentage of the text should be corrupted</p><ul><li>15% is the best!</li></ul></li><li><p>Forth Part: Destroy a small segment of approximately how long</p><ul><li>3 is the best!</li></ul></li></ol><h3><span id="datasets">Datasets</span></h3><h2><span id="0x04-ganlm">0x04 GANLM</span></h2><hr><p>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
          <category> 冯如杯专利 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数分第13周学习日志</title>
      <link href="/2023/11/25/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC13%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/25/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC13%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>不定积分</p><span id="more"></span><h2><span id="0x01-不定积分定义与基本性质">0x01 不定积分定义与基本性质</span></h2><h3><span id="不定积分的定义">不定积分的定义</span></h3><ul><li>定义：如果存在函数 $F(x),F’(x)=f(x),\forall x\in I,$则称 $F(x)$为 $f(x)$在集合I上原函数</li><li>定义：函数 $f(x)$在集合I上所有原函数，称为 $f(x)$在集合I上的不定积分。</li><li>$\int{f(x)dx}=F(x)+c$<ul><li>$\int$ 积分符号</li><li>$x$ 积分变量</li><li>$f(x)$ 被积函数</li><li>$f(x)dx$被积表达式</li></ul></li></ul><h3><span id="基本性质">基本性质</span></h3><ol><li>若函数 $f(x)$的原函数存在，则 $kf(x)$存在原函数，且有 $\int kfdx = k\int fdx, \forall k\in R$</li><li>若函数 $f(x)$和 $g(x)$的原函数存在，则 $f(x)\pm g(x)$存在原函数，且 $\int(f\pm g)dx=\int fdx+\int gdx$</li><li>$\frac{d}{dx}[\int f(x)dx]=f(x); d[\int f(x)dx]=f(x)dx;\int dF(x)=F(x)+c;$</li><li>微分运算与积分运算互逆</li></ol><h3><span id="积分表">积分表</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125100925999.png" alt="image-20231125100925999"></p><p>要注意 $\ln|x| $</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125100939645.png" alt="image-20231125100939645"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125100953784.png" alt="image-20231125100953784"></p><p>含有第一类间断点的函数没有原函数。</p><h2><span id="0x02-第一类换元公式及应用">0x02 第一类换元公式及应用</span></h2><h3><span id="换元公式">换元公式</span></h3><p>若 $f(u)$在区间I上有原函数 $F(u),\phi(x)$在J上可导，$\{u|u=\phi(x),\forall x\in J\}$，则 $F(\phi(x))$是 $f(\phi(x))\phi’(x)$在区间J上的原函数，即有：$\int f(\phi(x))\phi’(x)dx=\int f(u)du = F(u)+C = F(\phi(x))+C$</p><h3><span id="应用">应用</span></h3><h4><span id="积分表">积分表</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125113508778.png" alt="image-20231125113508778"></p><h2><span id="0x03-分部积分公式及应用">0x03 分部积分公式及应用</span></h2><ul><li>$(uv)’=u’v+uv’, uv’=(uv)’-u’v$</li><li>$\int u(x)v’(x)dx = u(x)v(x)-\int u’(x)v(x)dx$</li><li>$\int vdu$ easier than $\int udv$</li><li>有递推关系的可以设为 $I_n$</li><li>三角函数相关的部分很有可能有周期性</li></ul><h2><span id="0x04-第二类换元公式及应用">0x04 第二类换元公式及应用</span></h2><h3><span id="定义">定义</span></h3><ul><li>设 $x=\psi(t)$是在区间上J单调可导的函数，并且 $\psi’(t)\neq 0$，又 $f(\psi(t))\psi’(t)$在区间J上存在原函数，则在J上有换元公式 $\int f(x)dx = \int f(\psi(t))\psi’(t)dt|_{t=\psi^{-1}(x)}$，其中 $t=\psi^{-1}(x)$为 $x=\psi(t)$的反函数</li><li>第一类换元是将多项凑成一项合并，定义域没有变化，第二类换元是将被积函数进行变量替换分解，注意其自身定义域的变化</li><li>一定要根据定义域进行讨论</li><li>常用三角代换的方式，目的是化解其中的根式</li></ul><h3><span id="积分表">积分表</span></h3><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125145048519.png" alt="image-20231125145048519"></li></ul><p>当分母阶较高时，可以采用倒代换</p><h2><span id="0x05-有理函数及有理三角函数的不定积分">0x05 有理函数及有理三角函数的不定积分</span></h2><h3><span id="有理函数">有理函数</span></h3><ul><li>定义：形如 $R(x)=\frac{P(x)}{Q(x)}$的函数，称为有理函数，其中 $P(x),Q(x)$分别是多项式。</li><li>若 $P(x)$的次数大于 $Q(x)$的次数，R(x)为假分式，类比于假分数</li></ul><h3><span id="有理函数分解定理">有理函数分解定理</span></h3><p>设 $R(x)=\frac{P(x)}{Q(x)}$为一个真分式，分母有分解式 $Q(x)=(x-a)^{n_1}\cdots(x-b)^{n_k}(x^2+px+q)^{m_1}\cdots(x^2+rx+s)^{m_i}$，所有二次式没有实根。</p><ul><li>注1：$f(x)=(x-a)^kg(x),g(a)\neq 0$，则 $x=a$为f(x)的k重根</li><li>注2：$x=a$为k重根 $\Leftrightarrow f^{(i)}(a)=0,i=0,1\cdots,k-1, f^{(k)}(a)\neq 0$</li></ul><h3><span id="三角函数有理式">三角函数有理式</span></h3><p>利用万能公式转换为有理函数的形式</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125173828993.png" alt="image-20231125173828993"></p><h3><span id="无理根式的不定积分">无理根式的不定积分</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231125174213069.png" alt="image-20231125174213069"></p><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CE Log</title>
      <link href="/2023/11/22/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/CE-Log/"/>
      <url>/2023/11/22/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/CE-Log/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>记录学习内容</p><span id="more"></span><h2><span id="0x01-教程部分">0x01  教程部分</span></h2><h3><span id="步骤9注入">步骤9：注入++</span></h3><p>在分析结构的过程中要想明白，比如我们查找的血量，很有可能是一个结构体的实例的一个属性值，因此内存空间上其他属性的分布极有可能是连续的，因此直接分析改变值对应的地址很可能猜出来其结构</p><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第12周学习日志</title>
      <link href="/2023/11/21/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/21/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>Message Authentication Code</p><span id="more"></span><h2><span id="0x01-definition-and-security-of-mac">0x01  Definition and Security of MAC</span></h2><h3><span id="integrity">Integrity</span></h3><ul><li>ensuring that a received message originated from the intended party, and was not modified</li><li>even if an attacker controls the channel</li><li>use message authentication code</li></ul><h3><span id="definition-of-mac">Definition of MAC</span></h3><p>A message authentication code is defined by three PPT algorithms (Gen, Mac, Vrfy):</p><ul><li>Gen: takes as input $1^n$; outputs $k$. (Assume $|k|\geq n$)</li><li>Mac: takes as input key $k$ and message $m\in\{0,1\}^*$; outputs tag $t$, $t:= Mac_k(m)$</li><li>Vrfy: takes key $k$, message $m$, and tag $t$ as input; outputs 1 or 0</li></ul><h3><span id="security">Security</span></h3><h4><span id="threat-model">Threat model</span></h4><ul><li>adaptive chosen-message attack</li><li>assume the attacker can induce the sender to authenticate messages of the attacker’s choice</li></ul><h4><span id="security-goal">Security goal</span></h4><ul><li>existential unforgeability</li><li>attacker should be unable to forge a valid tag on any message not previously authenticated by the sender</li></ul><h3><span id="formal-definition">Formal Definition</span></h3><h4><span id="def-42-security-definition-of-mac">Def. 4.2 Security Definition of Mac</span></h4><ul><li>Fix $\mathcal{A},\Pi$</li><li>Define randomized experiment $Forge_{\mathcal{A},\Pi}(n)$:<ol><li>$k \leftarrow Gen(1^n)$</li><li>$\mathcal{A}$ interacts with an oracle $Mac_k(\cdot)$; let $\mathcal{Q}$ be the set of messages submitted to this oracle</li><li>$(m,t)\leftarrow \mathcal{A}$</li><li>$\mathcal{A}$ succeeds, and the experiment evaluates to 1,  if $Vrfy_k(m,t)=1$ and $m \not\in \mathcal{Q}$</li></ol></li><li>A message authentication code $\Pi = (Gen, Mac, Vrfy)$ is existentially unforgeable under an adaptive chosen-message attack if for all PPT attackers $\mathcal{A}$, there is a negligible function $\epsilon$ that $\Pr[Mac-Forge_{\mathcal{A},\Pi}=1]\leq \epsilon(n)$</li></ul><h3><span id="replay-attacks">Replay Attacks</span></h3><ul><li>no stateless mechanism can prevent them</li><li></li></ul><h2><span id="0x02-a-fixed-length-mac">0x02 A fixed-length MAC</span></h2><h3><span id="construction">Construction</span></h3><h4><span id="definition-46-secure-mac">Definition 4.6 Secure Mac</span></h4><ul><li>if F is a pseudomrandom function, then the above is a secure fixed-length MAC for message of length n.</li><li></li></ul><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数分第11周学习日志</title>
      <link href="/2023/11/19/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/19/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%95%B0%E5%88%86%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>泰勒公式</p><span id="more"></span><h2><span id="0x01-微分的定义与计算">0x01  微分的定义与计算</span></h2><h3><span id="1-微分的定义">1 微分的定义</span></h3><h4><span id="定义">定义</span></h4><p>设函数 $y=f(x)$定义在 $U(x_0;\delta),x_0+\Delta x\in (x_0;\delta)$，如果成立：$\Delta y=f(x_0+\Delta x)-f(x_0)=A\cdot\Delta x+o(\Delta x)$，其中A是与 $\Delta x$无关的常熟，则称函数在点 $x_0$可微，$A\cdot\Delta x$称为函数在该点相应于自变量增量的微分，记作：$dy|_{x=x_0}=A\cdot\Delta x, or \ df(x_0)=A\cdot\Delta x$</p><h4><span id="等价定义">等价定义</span></h4><p>$\Delta y = f(x_0+\Delta x)-f(x_0)=A\cdot\Delta x+o(\Delta x)$</p><ul><li>$f(x)-(f(x_0)+A(x-x_0))=o(x-x_0)$</li></ul><h4><span id="可微条件">可微条件</span></h4><ul><li>定理：函数 $f(x)$在点 $x_0$可微的充要条件是函数 $f(x)$在点 $x_0$可导，且 $A=f’(x_0)$</li><li>注1：函数 $f(x)$在 $\forall x\in U(x_0;\delta)$ 可微，记为 $dy \ or \ df(x),i.t. dy=f’(x)\Delta x$</li><li>注2：自变量x的增量 $\Delta x$视为自变量的微分</li></ul><h4><span id="运算法则">运算法则</span></h4><p>与求导的法则相似</p><h4><span id="高阶微分">高阶微分</span></h4><p>$dx^n=(dx)^n,f^{(n)}(x)=\frac{d^nf(x)}{dx^n}$</p><h4><span id="微分形式的不变性">微分形式的不变性</span></h4><p>复合函数二阶微分不变，高阶变</p><h2><span id="0x02-微分的计算">0x02 微分的计算</span></h2><h3><span id="1-基本初等函数的微分公式">1 基本初等函数的微分公式</span></h3><p>与求导相似，带了一个 $dx$</p><h3><span id="应用近似公式">应用：近似公式</span></h3><h2><span id="0x03-带有peano余项的泰勒公式">0x03 带有Peano余项的泰勒公式</span></h2><h3><span id="1-带有peano余项的泰勒公式证明">1 带有Peano余项的泰勒公式证明</span></h3><h3><span id="2-带有peano余项的泰勒公式">2 带有Peano余项的泰勒公式</span></h3><p>$f(x)=p_n(x)+o[(x-x_0)^n]$ —- ①</p><p>$p_n(x)=\sum^n_{k=0}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k$</p><p>当 $x_0=0$，称为麦克劳林公式</p><h3><span id="3-常用函数展开">3 常用函数展开</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222204635.png" alt="image-20231119222204635"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222218627.png" alt="image-20231119222218627"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222437511.png" alt="image-20231119222437511"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222501948.png" alt="image-20231119222501948"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222644899.png" alt="image-20231119222644899"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119222659182.png" alt="image-20231119222659182"></p><h2><span id="0x04-带拉格朗日余项的泰勒公式">0x04 带拉格朗日余项的泰勒公式</span></h2><p>利用Cauchy中值定理进行证明余项原因</p><h3><span id="公式表示">公式表示</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225543780.png" alt="image-20231119225543780"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225619413.png" alt="image-20231119225619413"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225626803.png" alt="image-20231119225626803"></p><h3><span id="常用函数">常用函数</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225652984.png" alt="image-20231119225652984"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225716179.png" alt="image-20231119225716179"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225804737.png" alt="image-20231119225804737"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231119225901342.png" alt="image-20231119225901342"></p><h3><span id="应用">应用</span></h3><h4><span id="1-极值问题">1 极值问题</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231120085838499.png" alt="image-20231120085838499"></p><h4><span id="2-求函数极限">2 求函数极限</span></h4><p>用多项式替换复杂函数</p><h3><span id="典型例题">典型例题</span></h3><p>两种余项定理条件不同，一个n阶导，一个n+1阶导</p><p>Taylor公式可以将函数与其导函数联系到一起</p><p>多利用奇偶性的不同来实现除去特定项</p><h2><span id="提高课">提高课</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第12周学习日志</title>
      <link href="/2023/11/17/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/17/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC12%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>关系数据库理论</p><span id="more"></span><h2><span id="0x01-问题的提出">0x01  问题的提出</span></h2><ul><li><p>把关系模式看作一个三元组 $R<u,f>$</u,f></p></li><li><p>作为一个二维表，关系要符合一个最基本的条件：</p><ul><li><p>每个分量必须是不可分的数据项</p></li><li><p>满足了这个条件的关系模式属于<strong>第一范式（1NF）</strong></p></li></ul></li><li><p>数据依赖</p><ul><li>一个关系内部属性之间的一种约束关系</li><li>数据内在的性质，语义的体现</li><li>设计关系模式时，除给出属性全集外，还需给出数据依赖集合</li><li>分为两类：函数依赖（FD）、多值依赖（MVD）</li></ul></li><li><p>$R(U,F)$中存在的问题</p><ul><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常</li><li>原因：模式中某些数据依赖引起的</li><li>解决：用规范化理论改造关系模式消除其中不合适的数据依赖</li><li></li></ul></li></ul><h2><span id="0x02-规范化">0x02 规范化</span></h2><h3><span id="1-函数依赖">1 函数依赖</span></h3><h4><span id="函数依赖">函数依赖</span></h4><ul><li>定义：设 $R(U)$时一个属性集U上的关系模式，$X,Y$是U的子集。若对于 $R(U)$的<strong>任意一个可能关系r</strong>，r中不可能<strong>存在两个元组</strong>在X上的属性值相等，而在Y上的属性值不等，则称 <code>X函数确定Y</code>或 <code>Y函数依赖于X</code>，记作 $X\rightarrow Y$</li><li>$X\rightarrow Y,Y\rightarrow X \Longrightarrow X \leftarrow\rightarrow Y$</li><li>若Y不函数依赖于X，则记为 $X\not\rightarrow Y$</li><li>函数依赖是R的所有关系实例均要满足的约束条件</li><li>语义概念，只能根据数据的语义来确定一个函数依赖</li><li>本质上是对属性间取值的一种约束，是一种数据依赖，是问题域业务规则的体现</li></ul><h4><span id="平凡函数依赖与非平凡函数依赖">平凡函数依赖与非平凡函数依赖</span></h4><ul><li>$X\rightarrow Y , but\ Y \not\subseteq X,then \ X\rightarrow Y$是非平凡的函数依赖</li><li>$X\rightarrow Y , and\ Y \subseteq X,then \ X\rightarrow Y$是平凡的函数依赖</li><li>平凡函数依赖必然成立</li><li>$X\rightarrow Y$，则称X为这个函数依赖的决定因素</li></ul><h4><span id="完全函数依赖与部分函数依赖">完全函数依赖与部分函数依赖</span></h4><ul><li>在 $R(U)$中，如果 $X\rightarrow Y$，并且对于X的任何一个真子集 $X’$，都有 $X’\not\rightarrow Y$，则称Y对X完全函数依赖，记作 $X\overset{F}{\rightarrow}Y$</li><li>若 $X\rightarrow Y$​，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作$X\overset{P}{\rightarrow}Y$</li></ul><h4><span id="传递函数依赖">传递函数依赖</span></h4><ul><li>定义：在 $R(U)$中，如果 $X\rightarrow Y , Y \not\subseteq X,Y\not{\rightarrow}X, Y\rightarrow Z , Z \not\subseteq Y$，则称Z对X传递函数依赖，记为 $X\overset{传递}{\rightarrow}Z$</li><li>如果 $Y\rightarrow X$则Z直接依赖于X，而不是传递依赖</li><li>存在非受控冗余</li></ul><h3><span id="2-码键">2 码/键</span></h3><ul><li>定义：设K为 $R<u,f>$中的属性或属性组合，若 $K\overset{F}{\rightarrow}U$，则K称为R的一个候选键/码</u,f></li><li>部分依赖则成为超键</li><li>候选键是最小的超码</li><li>多个候选码选定一个为主码</li><li>定义：关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则X是R的外部码</li><li>定义：对于满足一组函数依赖F的关系模式 $R<u,f>$，其中任何一个关系r，若函数依赖 $X\rightarrow Y$成立，则称F逻辑蕴涵 $X\rightarrow Y$</u,f></li><li>Armstrong公理系统<ul><li>设<em>U</em>为属性集总体，<em>F</em>是<em>U</em>上的一组函数依赖， 于是有关系模式<em>R</em> &lt;<em>U</em>,<em>F</em> &gt;。对<em>R</em> &lt;<em>U</em>,<em>F</em>&gt; 来说有以下的推理规则：</li><li>A1 自反律：若 $Y\subseteq X\subseteq U$，则F逻辑蕴涵 $X\rightarrow Y$</li><li>A2 增广律：若 F逻辑蕴涵 $X\rightarrow Y$，且 $Z\subseteq U$，则F逻辑蕴涵 $XZ\rightarrow YZ$</li><li>A3 传递律：若F逻辑蕴涵 $X\rightarrow Y$与$Y\rightarrow Z$，则F逻辑蕴涵 $X\rightarrow Z$</li><li>三条推理规则：<ul><li>合并规则：由<em>X</em>→<em>Y</em>，<em>X</em>→<em>Z</em>，有<em>X</em>→<em>YZ</em>。</li><li>伪传递规则：由<em>X</em>→<em>Y</em>，<em>WY</em>→<em>Z</em>，有<em>XW</em>→<em>Z</em>。</li><li>分解规则：$X\rightarrow Y, Z\subseteq Y$,有 $X\rightarrow Z$</li></ul></li></ul></li></ul><h3><span id="3-范式-nf">3 范式 NF</span></h3><ul><li>符合某一种级别的关系模式的集合</li><li>种类<ul><li>第一范式(1NF)</li><li>第二范式(2NF)</li><li>第三范式(3NF)</li><li>BC范式(BCNF)</li><li>第四范式(4NF)</li><li>第五范式(5NF)</li></ul></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231117152439523.png" alt="image-20231117152439523"></li><li>一个低一级范式的关系模式，通过模式分解，可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化</li></ul><h3><span id="4-2nf">4 2NF</span></h3><ul><li>定义：若关系模式 $R\in 1NF$，且每个非主属性都完全函数依赖于任何一个候选码，则 $R\in2NF$</li><li>关系模式不属于2NF，会产生以下问题：<ul><li>插入异常</li><li>删除异常</li><li>修改复杂</li></ul></li><li>解决的是非主属性对复合主键的部份依赖</li><li>单一候选键一定符合</li></ul><h3><span id="5-3nf">5 3NF</span></h3><ul><li>定义：设关系模式 $R<u,f>\in 1NF$，若R中不存在这样的码X、属性组Y及非主属性Z $(Z\not\subseteq Y),s.t. \ X\rightarrow Y , Y\rightarrow Z$成立，$Y\not\rightarrow X$，则称 $R<u,f>\in 3NF$</u,f></u,f></li><li>即不存在传递依赖</li><li>3NF通常解决的是非主属性之间的依赖关系，非主属性对候选键的传递依赖。</li><li>属性组Y可能包括部分主属性、非主属性、或二者组合</li></ul><h3><span id="6-bcnf">6 BCNF</span></h3><ul><li>设关系模式 $R<u,f>\in1NF$，若 $X\rightarrow Y \ and \ Y\not\subseteq X$时X必含有码，则 $R<u,f>\in BCNF$</u,f></u,f></li><li>每一个决定属性集都包含候选码</li><li>解决了主属性组（但不构成候选键）对候选键的部分或者传递依赖关系</li><li>即除了所有属性（组）对候选键的依赖关系之外，没有任何其他的依赖关系</li><li>总结：<ul><li>2NF解决非主属性对候选键的部分依赖</li><li>3NF解决非主属性对候选键的传递依赖</li><li>BCNF解决主属性对候选键的部分或传递依赖</li><li></li></ul></li></ul><h3><span id="7-多值依赖">7 多值依赖</span></h3><ul><li>定义：MVD 设 $R(U)$是属性集U上的一个关系模式。<em>X，Y，Z</em>是U的子集，且 $Z=U-X-Y$。关系模式<em>R(U)</em>中多值依赖 $X\rightarrow\rightarrow Y$成立，当且仅当对<em>R(U)</em>的任意关系r，给定的一对 $(x,z)$值，有一组Y的值，仅仅决定于x值而与z值无关</li><li>Y和Z相互独立</li><li>平凡多值依赖：Z为空的情况</li><li>性质：<ul><li>对称性：即若X→→Y，则X→→Z，其中Z＝U－X－Y</li><li>传递性：即若X→→Y，Y→→Z， 则X→→Z -Y。</li><li>函数依赖是多值依赖的特例：即若X→Y，则 X→→Y。</li><li>若X→→Y，X→→Z，则X→→YZ。</li><li>若X→→Y，X→→Z，则X→→Y∩Z。</li><li>若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y。</li></ul></li></ul><h3><span id="8-4nf">8 4NF</span></h3><ul><li>定义：设关系模式 $R<u,f>\in1NF$，若 对于R的每个非平凡多值依赖 $X\rightarrow\rightarrow Y$ 时X都含有码，则 $R<u,f>\in 4NF$</u,f></u,f></li><li>性质：<ul><li>不允许有非平凡且非函数依赖的多值依赖</li><li>允许的非平凡多值依赖实际是函数依赖</li><li>平凡的多值依赖属于第四范式</li><li>4NF $\rightarrow$ BCNF</li></ul></li></ul><h2><span id="0x03-数据依赖的公理系统">0x03 数据依赖的公理系统</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第11周学习日志</title>
      <link href="/2023/11/16/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/16/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC11%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>数据库完整性</p><span id="more"></span><h2><span id="0x01-实体完整性">0x01  实体完整性</span></h2><h3><span id="1-实体完整性定义">1 实体完整性定义</span></h3><h4><span id="关系模型的实体完整性">关系模型的实体完整性</span></h4><ul><li>CREATE TABLE 用 PRIMARY KEY定义</li></ul><h4><span id="单属性构成的主键有两种说明方法">单属性构成的主键有两种说明方法</span></h4><ul><li>定义为列级约束条件</li><li>定义为表级约束条件</li></ul><h4><span id="对多个属性构成的主键只有一个说明方法">对多个属性构成的主键只有一个说明方法</span></h4><ul><li>定义为表级约束条件</li></ul><h3><span id="2-实体完整性检查和违约处理">2 实体完整性检查和违约处理</span></h3><p>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查</p><ul><li>检查主码值是否唯一<ul><li>全表扫描：耗时</li><li>RDBMS在主码上自动建立一个索引</li></ul></li><li>检查主码的各个属性是否为空</li></ul><h2><span id="0x02-参照完整性">0x02 参照完整性</span></h2><h3><span id="1-参照完整性定义">1 参照完整性定义</span></h3><ul><li>用FOREIGN KEY定义外码</li><li>用REFERENCES指明外码参照哪些表的主码</li></ul><h3><span id="2-参照完整性检查和违约处理">2 参照完整性检查和违约处理</span></h3><ul><li><p>将两个表中的相应元组联系起来</p></li><li><p>两个表的增删改都有可能破坏参照完整性，必须进行检查</p></li><li></li><li><p>| <strong>被参照表（例如Student</strong>） | 参照表（例如SC）   | <strong>违约处理</strong>             |<br>| —————————————- | ————————— | ———————————— |<br>| 可能破坏参照完整性          | 插入元组           | 拒绝                     |<br>| 可能破坏参照完整性          | 修改外码值         | 拒绝                     |<br>| 删除元组                    | 可能破坏参照完整性 | 拒绝/级连删除/设置为空值 |<br>| 修改主码值                  | 可能破坏参照完整性 | 拒绝/级连修改/设置为空值 |</p></li></ul><ol><li>拒绝执行 NO ACTION：默认策略</li><li>级联操作 CASCADE：</li><li>设置为空值 SET NULL：</li></ol><ul><li>除了定义外码，还应该定义外码列是否允许空值</li></ul><h2><span id="0x03-用户定义的完整性">0x03 用户定义的完整性</span></h2><ul><li>针对某一具体应用的数据必须满足的语义要求</li></ul><h3><span id="1-属性上的约束条件">1 属性上的约束条件</span></h3><h4><span id="属性上约束条件的定义">属性上约束条件的定义</span></h4><ul><li>列值非空 NOT NULL</li><li>列值唯一 UNIQUE</li><li>检查列值是否满足一个条件表达式 CHECK</li></ul><h4><span id="属性上的约束条件检查和违约处理">属性上的约束条件检查和违约处理</span></h4><ul><li>约束条件RDBMS自动检查</li><li>不满足则拒绝执行</li></ul><h3><span id="2-元组上的约束条件">2 元组上的约束条件</span></h3><h4><span id="元组上约束条件的定义">元组上约束条件的定义</span></h4><ul><li>CHECK短语定义元组上的约束条件，元组级的限制</li><li>元组级限制可以设置不同属性之间的取值的相互约束条件</li></ul><h4><span id="元组上的约束条件检查和违约处理">元组上的约束条件检查和违约处理</span></h4><ul><li>约束条件RDBMS自动检查</li><li>不满足则拒绝执行</li></ul><h2><span id="0x04-完整性约束命名子句">0x04 完整性约束命名子句</span></h2><h3><span id="1-完整性约束命名子句">1 完整性约束命名子句</span></h3><p>CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</p><h3><span id="2-修改表中的完整性限制">2 修改表中的完整性限制</span></h3><p>使用 ALTER TABLE语句修改表中的完整性限制</p><h2><span id="0x05-域中的完整性限制">0x05 域中的完整性限制</span></h2><h2><span id="0x06-断言">0x06 断言</span></h2><ul><li>SQL中，使用CREATE ASSERTION 语句，通过声明性断言来指定更具一般性的约束</li><li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束</li><li>任何对断言所涉及的关系的操作都会触发DDBMS的检查，断言不为真值的操作会被拒绝。</li></ul><h3><span id="1-创建断言的语句格式">1 创建断言的语句格式</span></h3><p>CREATE ASSERTION &lt;断言名&gt; <check 子句></check></p><h3><span id="2-删除断言的语句格式">2 删除断言的语句格式</span></h3><p>DROP ASSERTION &lt;断言名&gt;</p><h2><span id="0x07-触发器">0x07 触发器</span></h2><ul><li>触发器 Trigger 是用户定义在关系表上的一类由事件驱动的特殊过程</li><li>触发器保存在数据库服务器中</li><li>任何增删改操作均由服务器自动激活相应的触发器</li></ul><h3><span id="1-定义触发器">1 定义触发器</span></h3><p>CREATE TRIGGER <trigger_name></trigger_name></p><p>{BEFORE| AFTER} <trigger_event> ON <table_name></table_name></trigger_event></p><p>REFERENCES NEW|OLD ROW AS <variables></variables></p><p>FOR EACH {ROW| STATEMENT}</p><p>[WHEN <trigger_condition>] <trigger_action></trigger_action></trigger_condition></p><ul><li>表的拥有者才可以在表上创建触发器</li><li>触发器名<ul><li>可以包含模式名，也可以不包含模式名</li><li>同一模式下，触发器名必须唯一</li><li>触发器名和表名必须在统一模式下</li></ul></li><li>表名<ul><li>触发器只能定义在基本表上，不能定义在视图上</li></ul></li><li>触发事件<ul><li>INSERT\DELETE\UPDATE</li><li>UPDATE OF {COLUMN}来限制具体某一列</li></ul></li><li>触发器类型<ul><li>行级    FOR EACH ROW</li><li>语句级  FOR EACH STATEMENT </li></ul></li><li>触发条件：condition为真</li><li>触发行动体：如果为行级触发器，可以使用new或old</li></ul><h3><span id="2-激活触发器">2 激活触发器</span></h3><ul><li>由触发事件激活</li><li>可能定义多个触发器，顺序：<ol><li>执行BEFORE触发器</li><li>激活触发器的SQL语句</li><li>执行AFTER触发器</li></ol></li></ul><h3><span id="3-删除触发器">3 删除触发器</span></h3><ul><li>DROP TRIGGER <trigger_name> ON <table_name></table_name></trigger_name></li><li></li></ul><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Manual</title>
      <link href="/2023/11/13/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/Database-Manual/"/>
      <url>/2023/11/13/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/Database-Manual/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>记录数据库知识手册，涉及到</p><span id="more"></span><h2><span id="0x01-关系数据库理论">0x01  关系数据库理论</span></h2><h3><span id="1-关系数据结构及形式化定义">1 关系数据结构及形式化定义</span></h3><ol><li>关系<ul><li>组成：同一类实体型的实例集合；</li><li>联系：实体之间，实体属性之间存在某种关联关系</li><li>域：相同数据类型的值的集合（有限且不重复）</li><li>笛卡尔积：允许某些域是相同的<ul><li>笛卡尔积中每个元素是一个n元组</li><li>元组中每个值叫做一个分量</li><li>基数：集合中包含元素的个数</li></ul></li><li>关系：笛卡尔积的子集叫做在域 $D_1,D_2,\cdots,D_n$上的关系，表示为 $R(D_1,D_2,\cdots,D_n)$<ul><li>n也称目或度，R为关系名</li><li>n=1：单元关系，n=2：二元关系</li><li>超键：属性集合能够在关系中唯一标识元组<ul><li>候选键/码 Candidate key：某一属性组的值能唯一标识一个元组<ul><li>属性组是几个属性的集合</li><li>最小超键</li><li>主码/主键：一个关系中有多个候选码，选定其中一个为主码<ul><li>外键：一个实体的主键被另外一个实体使用，以表达不同实体元组之间的关系（这里面的实体可以理解为一个关系）</li><li>二者区别：</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113113200209.png" alt="image-20231113113200209"></li><li>实体之间的关系依赖主键-外键关联实现<ul><li>1对1，1对多</li><li>多对多可能存在数据冗余以及追溯父节点的难以区分</li><li>ER图的学习：<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113112439396.png" alt="image-20231113112439396"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113112802826.png" alt="image-20231113112802826"></li></ul></li></ul></li></ul></li><li>主属性：候选码中的所有属性，其余的属性称为非主属性</li></ul></li><li>全码/键 All-key：关系模式的所有属性组是这个关系模式的候选码</li></ul></li></ul></li><li>三类关系<ol><li>基本关系 （基本表或基表）</li><li>查询表</li><li>视图表</li></ol></li><li>基本关系的性质<ol><li>列同质：分量来自同一域</li><li>不同列可以出自同一域</li><li>行、列次序可交换</li><li>任意两个元组候选码不能相同</li><li>分量必须是原子值<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231113114048546.png" alt="image-20231113114048546"></li></ul></li></ol></li></ul></li><li>关系模式<ul><li>型 Type，结构</li><li>R(U, D, DOM, F) 可以简记为 R(U)<ul><li>R        关系名</li><li>U        组成该关系的属性名集合</li><li>D        U中属性所来自的域</li><li>DOM   属性向域的映象集合</li><li>F        属性间数据的依赖关系的集合</li></ul></li></ul></li><li>关系数据库<ul><li>所有关系的集合构成一个关系数据库</li><li>型：关系数据库模式 schema</li><li>值：关系集合</li></ul></li><li>关系模型的存储结构</li></ol><h3><span id="2-关系操作">2 关系操作</span></h3><blockquote><p>引入记号：</p><p>设关系为 $R(A_1,A_2,\cdots,A_n)$，$t\in R$，</p><ol><li>$t[A_i]$表示元组 $t$中对应属性 $A_i$的一个分量</li><li>若 $A=\{A_{i_1},\cdots,A_{i_k}\}$，则 $t[A]$表示元组t相应分量的集合，$\bar{A}$表示除去A中属性后剩余的属性组</li><li>$\overset{\frown}{t_rt_s}$ 元组连接，列数变为m+n列，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</li></ol><p>设关系为 $R(X,Z)$</p><ol><li>象集 $Z_x=\{t[Z]|t\in R, t[X]=x\}$</li></ol></blockquote><ul><li><p>查询操作：</p><ol><li>选择 $\sigma$<ul><li>$\sigma_F(R)=\{t|t\in R \and F(t)=True\}$</li><li>$F:X_1\theta X_2$， $\theta$可以是比较运算符</li><li>行的角度进行</li><li>优先级：$\{(),\theta,\neg,\and,\or\}$</li></ul></li><li>投影 $\pi$<ul><li>$\pi_A(R)=\{t[A]|t\in R\}$</li><li>列的角度进行，会避免重复行</li></ul></li><li>连接 $\bowtie$<ul><li>$R\underset{A\theta B}{\bowtie} S= \{\overset{\frown}{t_rt_s}|t_r\in R \and t_s\in S \and t_r[A] \theta t_s[B] \}$</li><li>常用连接运算：<ul><li>等值连接 $A\theta B:A=B$</li><li>自然连接 Natural join $R\bowtie S=\{\overset{\frown}{t_rt_s}[U-B]|t_r\in R \and t_s\in S \and t_r[B]=t_s[B]\}$ <ul><li>U是全体属性集合，B是R和S具有的相同的属性组</li><li>行列角度进行运算，取消重复列</li><li>悬浮元组：做自然连接时，关系R中某些元组可能在S中不存在公共属性上值相等的元组</li><li>外连接：将悬浮元组保存在结果关系中，其他属性上填空值<ul><li>左外连接：保留左边关系</li><li>右外连接：保留右边关系</li></ul></li></ul></li></ul></li></ul></li><li>除 $\div$<ul><li>$R\div S=\{t_r[X]|t_r\in R \and \pi_Y(S)\subset Y_x  \},x=t_r[X]$</li><li>一般的 $\pi_y(S)\subset \pi_y(R)$成立</li><li>行列进行操作</li><li><code>查询...至少/全部的/所有的...</code>问题</li><li>$R\div S=\pi_X(R)-\pi_X(\pi_X(R)\times\pi_y(S)-R)$</li></ul></li><li>并 $\cup$<ul><li>具有相同的目，相应的属性取自同一域</li><li>结果不允许重复</li></ul></li><li>差 $-$<ul><li>具有相同的目，相应的属性取自同一域</li><li>$R-S$结果为属于R但不属于S的元组构成</li></ul></li><li>交 $\cap$<ul><li>具有相同的目，相应的属性取自同一域</li></ul></li><li>笛卡尔积 $\times$<ul><li>$R \times S$<ul><li>$R$：n目关系，$k_1$个元组</li><li>$S$：m目关系，$k_2$个元组</li><li>结果为 $m+n$列，$k_1\times k_2$行</li></ul></li></ul></li></ol><ul><li>并、差、笛卡尔积、投影、选择为五种基本运算</li></ul></li><li><p>数据更新</p><ol><li>插入</li><li>删除</li><li>修改</li></ol></li><li><p>关系操作的对象和结果均是集合</p></li><li><p>关系数据库语言有两类</p><ol><li>关系代数语言：关系运算来表达查询要求，对关系代数表达式求值</li><li>关系演算语言：用为此来表达查询要求</li></ol><ul><li>SQL具有关系代数和关系演算的双重特点</li></ul></li></ul><h3><span id="3-关系的完整性">3 关系的完整性</span></h3><ul><li><p>三类完整性约束</p><ol><li>实体完整性<ul><li>主属性不能取空值</li><li>NULL是不知道或不存在或无意义或不适用的值<ul><li>NULL不能参与算数、比较或逻辑运算</li></ul></li></ul></li><li>参照完整性<ul><li>引用其他关系的主键作为外键F的关系R称为参照关系，被引用主键对应的关系S称为被参照关系或目标关系</li><li>R与S不一定是不同的关系</li><li>主码外码必须在同一个域上，但不一定要同名</li><li>参照关系中的外码值要么等于被参照关系的主码值，要么为空值（F的每个属性值均为空值）</li><li>关系数据库不支持m:n联系，因为会造成大量的数据冗余，不符合数据库设计的基本要求</li></ul></li><li>用户定义的完整性<ul><li>满足具体的语义要求</li></ul></li></ol><ul><li>1，2合称关系的两个不变性</li></ul></li></ul><h3><span id="4-关系代数">4 关系代数</span></h3><ul><li><p>抽象的查询语言，关系代数的运算符有两类</p><ol><li>集合运算符</li><li>专门的关系运算符</li></ol><ul><li>集合运算符涉及到关系的行，专门的关系运算涉及到行与列</li></ul></li></ul><h2><span id="0x02-关系数据库语言-sql">0x02 关系数据库语言 SQL</span></h2><ul><li>特点<ol><li>综合统一<ul><li>数据定义语言 DDL    Create/Alter/Drop</li><li>数据操纵语言 DML   Insert/ Select/Update/Delete</li><li>数据控制语言 DCL     Grant/Revoke</li><li>事务控制语言 TCL     Begin Transaction/Commit/Rollback</li></ul></li><li>高度非过程化</li><li>面向集合的操作方式</li><li>以同一种语法结构提供多种使用方式<ul><li>独立语言</li><li>嵌入式语言</li><li>驱动程序API</li></ul></li></ol></li><li>基本概念<ul><li>三级模式结构<ol><li>外模式</li><li>模式</li><li>内模式</li></ol></li><li>基本表<ul><li>一个关系对应一个基本表</li><li>一个基本表对应一个存储文件</li><li>一个表可以有若干索引</li></ul></li><li>存储表<ul><li>逻辑结构</li><li></li></ul></li></ul></li></ul><h2><span id="0x03-oracle-mysql工程实践">0x03 Oracle, Mysql工程实践</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库实验记录</title>
      <link href="/2023/11/02/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/11/02/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>记录了一些实验的一些琐碎文件</p><span id="more"></span><h2><span id="0x01-oracle">0x01  Oracle</span></h2><h3><span id="1-登录">1 登录</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus &#123;&lt;username&gt;[/&lt;password&gt;]@&lt;connect_identifier&gt; &#125; [AS &#123;SYSDBA|SYSOPER|&#125;] </span><br></pre></td></tr></table></figure><h3><span id="2-数据库切换">2 数据库切换</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前的数据库</span></span><br><span class="line">sql&gt; show con_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">sql&gt; alter session <span class="built_in">set</span> container = &lt;contain_name&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">connect scott/123456@servername</span><br></pre></td></tr></table></figure><h3><span id="3-输出辅助">3 输出辅助</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set pagesize 1000; // 设置1000行</span><br><span class="line">set linesize 100; // 每行100字符</span><br><span class="line"></span><br><span class="line">spool file_name; //将内容输出到指定文件</span><br><span class="line">spool off; // 关闭输出</span><br><span class="line"></span><br><span class="line">desc table_name // 显示一个表的结构</span><br></pre></td></tr></table></figure><h3><span id="4-执行sql脚本文件">4 执行sql脚本文件</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@file_name;</span><br></pre></td></tr></table></figure><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全创新实验LAB7</title>
      <link href="/2023/10/31/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8CLAB7/"/>
      <url>/2023/10/31/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8CLAB7/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>防火墙实验</p><span id="more"></span><h2><span id="0x01-实验原理">0x01 实验原理</span></h2><h3><span id="31-防火墙">3.1 防火墙</span></h3><p><strong>建立位置</strong></p><p>分为网络防火墙和基于主机的防火墙。网络防火墙位于网关计算机上，过滤多个网络之间的流量，基于主机的防火墙在特定主机上运行，监视并控制进出主机的网络流量。</p><p><strong>实现方法</strong></p><p>分为包过滤防火墙与应用及网关防火墙。包过滤防火墙工作于网络层，能对所有数据包进行过滤。不需要了解数据报文的具体细节，之查看数据包的源、目的地址、端口号、某些标志位；应用级防火墙工作于应用层，为特定的应用程序编写代理程序，过滤特定数据包。</p><h3><span id="32-iptables命令">3.2 iptables命令</span></h3><p>配置Linux内核防火墙的命令行工具。</p><p><code>iptables</code>存在表 <code>tables</code>、链 <code>chains</code>、 规则 <code>rules</code>三个层级。</p><p>表提供不同的数据包处理功能，存在5张表</p><ul><li><code>filter</code>表用于过滤数据包，防火墙操作的默认表，内建链包括 <code>INPUT</code> <code>OUTPUT</code> <code>FORWARD</code></li><li><code>nat</code>表用于网络地址转换，内建链 <code>PREROUTING</code> <code>POSTROUTING</code> <code>OUTPUT</code></li><li><code>mangle</code>表用于处理特定数据包，内建链 <code>PREROUTING</code> <code>INPUT</code> <code>OUTPUT</code> <code>FORWARD</code> <code>POSTROUTING</code></li><li><code>raw</code>表用于处理异常，内建链 <code>PREROUTING</code> <code>OUTPUT</code></li><li><code>security</code>表用于强制访问控制网络规则。内建链 <code>INPUT</code> <code>OUTPUT</code> <code>FORWARD</code></li></ul><p>存在5个链</p><ul><li><code>PREROUTING</code> 路由前链，在数据包刚刚到达本机，处理路由规则前通过此链，通常用于目的地址转换；</li><li><code>INPUT</code> 输入链，发往本机的数据包通过此链。</li><li><code>OUTPUT</code> 输出链，从本机发出的数据包通过此链</li><li><code>FORWARD</code> 转发链，本机转发的数据包通过此链。</li><li><code>POSTROUTING</code> 路由后链，数据包要离开本机时通过此链，通常用于源地址转换</li></ul><p>规则：任何链中都没有规则，可以自己添加。</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-L [chain]</td><td>列出指定链中的所有规则</td></tr><tr><td>-A [chain]</td><td>在指定链的末尾添加一条规则</td></tr><tr><td>-I [chain] [index]</td><td>在指定链的指定处插入一条规则</td></tr><tr><td>-D [chain] [index]</td><td>删除指定链中的指定规则</td></tr><tr><td>-R [chain] [index]</td><td>将指定链中的指定规则替换为新规则</td></tr><tr><td>-F [chain]</td><td>清空指定链中的所有规则</td></tr><tr><td>-P [chain] [target]</td><td>设置指定链的默认规则，例如 DROP，ACCEPT 等。</td></tr><tr><td>-t [table]</td><td>选择表</td></tr></tbody></table></div><p>处理动作 target</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>ACCEPT</td><td>允许数据包通过，并且不会再去匹配当前链中的其他规则</td></tr><tr><td>DROP</td><td>直接丢弃数据包， 不会返回任何的消息</td></tr><tr><td>REJECT</td><td>拒绝数据包通过，并向发送者返回错误信息</td></tr><tr><td>SNAT</td><td>对数据包进行源地址转换</td></tr><tr><td>DNAT</td><td>对数据包进行目的地址转换</td></tr><tr><td>MASQUERADE</td><td>和 SNAT 的作用相同，区别在于它不需要指定—to-source；</td></tr><tr><td>REDIRECT</td><td>转发数据包到本机另一个端口</td></tr></tbody></table></div><p>规则匹配条件于指定动作的相关参数与含义</p><p>iptables 命令规则匹配条件与指定动作的相关参数与含义</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-s</td><td>数据包的源 IP 地址</td></tr><tr><td>-d</td><td>数据包的目的 IP 地址</td></tr><tr><td>-p</td><td>数据包的协议</td></tr><tr><td>—sport</td><td>数据包的源端口</td></tr><tr><td>—dport</td><td>数据包的目的端口</td></tr><tr><td>-i</td><td>数据包的输入网卡</td></tr><tr><td>-o</td><td>数据包的输出网卡</td></tr><tr><td>-j</td><td>指定动作，例如 DROP， ACCEPT 等</td></tr><tr><td>-m</td><td>匹配扩展模块，例如 state， conntrack 等</td></tr></tbody></table></div><h3><span id="33-ssh-tunnel">3.3 SSH Tunnel</span></h3><p>隧道协议实现专用网络通信。</p><p>SSH Tunnel建立后，应用程序连接到一个被SSH客户端监听的本地端口。</p><h2><span id="0x02-实验步骤">0x02 实验步骤</span></h2><h3><span id="41-配置实验环境">4.1 配置实验环境</span></h3><p>Host U外部主机 VM1：A</p><p>Gateway网关 VM2：B</p><p>Host V内部主机VM3：C</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t [table] -A [chain] -s [<span class="built_in">source</span>] -j [target] -o [interface]</span><br></pre></td></tr></table></figure><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络创新安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第八周学习日志</title>
      <link href="/2023/10/25/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AB%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/25/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AB%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淑芬第七周学习日志</title>
      <link href="/2023/10/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%B8%83%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%B8%83%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>第四章 导数的计算与应用</p><span id="more"></span><h1><span id="0x01-导数的计算">0x01 导数的计算</span></h1><h2><span id="导数的定义与单侧导数">导数的定义与单侧导数</span></h2><h3><span id="导数的定义">导数的定义</span></h3><p>$y=f(x)$在 $x_0$的某邻域 $U(x_0;\delta)=(x_0-\delta,x_0+\delta)$有定义，如果极限$\lim_{\Delta x\rightarrow 0} \frac{\Delta y}{\Delta x} = \lim_{\Delta x\rightarrow 0}\frac{f(x_0+\Delta x)- f(x_0)}{\Delta x}$ 存在，该极限为 $f(x)$在点 $x_0$处的导数，称 $y=f(x)$在 $x_0$处可到。</p><p>记为 $f’(x_0)$或 $y’(x)|_{x=x_0}$ 或 $\frac{df(x)}{dx}|_{x=x_0}$</p><h3><span id="其他等价形式">其他等价形式</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231028171610099.png" alt="image-20231028171610099"></p><h3><span id="单侧导数">单侧导数</span></h3><p>$\lim_{h\rightarrow 0^+} \frac{f(x_0+h)-f(x_0)}{f(x_0)}=f’_+(x_0)$</p><p>$\lim_{h\rightarrow 0^-} \frac{f(x_0+h)-f(x_0)}{f(x_0)}=f’_-(x_0)$</p><p>分别称为 在$x=x_0$的左右导数</p><h3><span id="可导的条件">可导的条件</span></h3><h4><span id="定理1">定理1</span></h4><p>$f(x)$在 $x_0$可导 $\Leftrightarrow$ $f’_-(x_0)=f’_+(x_0)$</p><h4><span id="定义2-函数在区间上可导">定义2： 函数在区间上可导</span></h4><ol><li>$f(x)$定义在 $(a,b),\forall x_0 \in (a,b),f’(x_0)$存在，则称 $f(x)$在 $(a,b)$上可导</li><li>$f(x)$在 $(a,b)$上可导，且在a,b点单侧导数存在，则称 $f(x)$在 $[a,b]$上可导</li></ol><h4><span id="可导与连续的关系">可导与连续的关系</span></h4><p>可导必连续，连续不一定可导</p><p>注意 $a^x -1$的极限是 $x\ln a$别忘了 $\ln$</p><h2><span id="导数的四则运算法则">导数的四则运算法则</span></h2><h4><span id="定理">定理</span></h4><p>如果 $u(x),v(x)$在区间 $I$可导，则他们的和差积商也可导，并且：</p><ol><li>$[u(x)\pm v(x)]’ = u’(x)\pm v’(x)$</li><li>$[u(x)v(x)]’=u’(x)v(x)+u(x)v’(x)$</li><li>$(\frac{u(x)}{v(x)})’ = \frac{u’(x)v(x)-u(x)v’(x)}{v^2(x)}, \forall x\in I, v(x)\neq 0$</li></ol><h4><span id="推论">推论</span></h4><ol><li>$[\sum_{i=1}^n f_i(x)]’ = \sum_{i=1}^n f’_i(x)$</li><li>$[Cf(x)]’=Cf’(x)$</li><li>$[f_1f_2f_3]’=f_1’f_2f_3+f_1f_2’f_3+f_1f_2f_3’$</li></ol><h2><span id="复合函数的求导法则">复合函数的求导法则</span></h2><h4><span id="定理">定理</span></h4><p>如果 $u=\phi(x)$在点 $x_0$可导，而 $y=f(u)$在 $u_0=\phi(x_0)$可导，则复合函数 $y=f[\phi(x)]$在 $x_0$可导。导数为</p><p>$\frac{dy}{dx} |_{x=x_0} = (\frac{df(u)}{du}|_{u=u_0})(\frac{d\phi(x)}{dx}|_{x=x_0})=f’(u_0)\cdot \phi’(x_0)$ </p><h4><span id="推广">推广</span></h4><p>链式法则</p><h4><span id="反函数求导法则">反函数求导法则</span></h4><p>$x=f(y)$在区间 $I_y$内单调可导，且 $f’(y)\neq 0$，那么反函数 $y=f^{-1}(x)$在 $I_x$内也可导</p><p>$[f^{-1}(x)]’=\frac{1}{f’(y)}$</p><h2><span id="高阶导数">高阶导数</span></h2><h4><span id="定义">定义</span></h4><p>二阶导数记作$f’’(x),y’’(x),\frac{d^2 y}{dx^2},\frac{d^2 f(x)}{dx^2}$</p><p>n阶导数记作 $f^{(n)}(x),y^{(n)}(x), \frac{d^{n} y}{dx^2},\frac{d^{n} f(x)}{dx^2}$</p><h4><span id="例题">例题</span></h4><p>n阶导数的求解过程中可以通过找周期性来实现求解。</p><p>如果一时不会做的话可以简单求一下一阶导、二阶导来找找思路，之后用数学归纳法来证明最终结论</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029085205603.png" alt="image-20231029085205603"></p><p>可以作为公式来用</p><h4><span id="定理-莱布尼兹求导公式">定理 莱布尼兹求导公式</span></h4><script type="math/tex; mode=display">(f\cdot g)^{(n)} = \sum_{k=0}^n C^k_n f^{(n-k)}g^{(k)}</script><p>组合数常用公式 $C^k_n+C^{k-1}_n = C^k_{n+1}$</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029085945333.png" alt="image-20231029085945333"></p><h3><span id="高阶导数的计算">高阶导数的计算</span></h3><p>对整个方程式求n阶导，根据莱布尼兹公式来进行化简。</p><h2><span id="参数方程和隐函数求导">参数方程和隐函数求导</span></h2><h3><span id="参数方程的一阶导数方法">参数方程的一阶导数方法</span></h3><p>$x=\varphi(t)$严格单调可导，$\varphi(t)\neq 0$，则 $t=\varphi^{-1}(x)$存在且可导。</p><p>设 $y=\psi(t)$，则 $\frac{dy}{dx}=\frac{\psi’(t)}{\varphi’(t)}$</p><h4><span id="二阶导数">二阶导数</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029092623945.png" alt="image-20231029092623945"></p><p>主要是掌握dy/dx的转换方式，各种导数现求就行</p><h3><span id="隐函数求导">隐函数求导</span></h3><h4><span id="定义">定义</span></h4><p>若 $F(x,y)=0$，当任意 $x\in I$，总存在唯一 $y$满足方程，则称 $F(x,y)=0$在 $I$上确定了一个隐函数</p><h3><span id="求导方法总结">求导方法总结</span></h3><ol><li>基本函数求导</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029093020601.png" alt="image-20231029093020601"></p><ol><li>求导方法总结</li></ol><p>函数四则运算、复合函数求导、反函数求导、高阶导数求导</p><h1><span id="0x02-中值定理">0x02 中值定理</span></h1><h2><span id="罗尔定理-rolle">罗尔定理 Rolle</span></h2><h3><span id="极值与极值点">极值与极值点</span></h3><p>设 $f(x)$定义在集合 $I$，存在 $U(x_0,\delta)\subset I$</p><ol><li>$\forall x \in U(x_0;\delta), f(x)\leq f(x_0)$，则称 $x_0$为极大值点</li><li>$\forall x \in U(x_0;\delta), f(x)\geq f(x_0)$，则称 $x_0$为极小值点</li></ol><h4><span id="驻点">驻点</span></h4><p>在点 $x_0$处 $f’(x_0)=0$，则称 $x_0$是 $f(x)$的一个驻点。</p><h4><span id="费马引理-fermat">费马引理 Fermat</span></h4><p>设 $f(x)$在集合 $I$上，$x_0$为 $I$的内点，$x=x_0$可导且 $x_0$为 $f(x)$的极值点，则 $f’(x_0)=0$</p><h4><span id="罗尔定理">罗尔定理</span></h4><p>$f(x)$在 $[a,b]$上连续，$(a,b)$上可导，且 $f(a)=f(b)$，则 $\exists \xi \in (a,b), s.t. f’(\xi) = 0$</p><p>注意：三个条件任有一个不满足结论可能不成立</p><h3><span id="应用">应用</span></h3><ol><li>可以根据要证明的函数关系式构造新的函数来使用Rolle定理</li><li>相当于根据导数式猜出原式</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029110726632.png" alt="image-20231029110726632"></li></ol><h2><span id="拉格朗日中值定理-lagrange">拉格朗日中值定理 Lagrange</span></h2><p>设 $f(x)$在 $[a,b]$上连续， $(a,b)$上可导，则存在 $\xi \in (a,b)，s.t. \frac{f(b)-f(a)}{b-a}=f’(\xi)$或 $f(b)-f(a)=f’(\xi)(b-a)$</p><h4><span id="等价形式">等价形式</span></h4><ol><li>$f(b)-f(a)=f’(a+\theta(b-a))(b-a), 0&lt;\theta&lt;1$</li><li>$f(a+h)-f(a)=f’(a+\theta h)h, 0&lt; \theta&lt;1$</li></ol><p><strong>思考题</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029111531912.png" alt="image-20231029111531912"></p><h4><span id="推论">推论</span></h4><p>$f(x)$在 $[a,b]$上连续，在 $(a,b)$内可导，则 $f(x)\equiv c, \forall x\in [a,b] \Leftrightarrow f’(x)=0, x\in(a,b)$</p><p>例题：</p><ol><li>利用拉格朗日中值定理去找边界的之间的关系</li><li>直接找到f(x1)-f(x2)与（x1-x2)的关系</li></ol><p>注： $f(x)$在集合 $I$上导函数有界，则 $f(x)$在 $I$上一致连续</p><h3><span id="应用">应用</span></h3><p>例题：</p><ol><li>同样是数学归纳法，从高往低算，因为它第二个条件给的是n阶导；</li><li></li><li>构造函数比较难构造啊</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029114212628.png" alt="image-20231029114212628"></p><h2><span id="柯西中值定理-cauchy">柯西中值定理 Cauchy</span></h2><p>$f(x),g(x)$在 $[a,b]$上连续，$(a,b)$内可导，$g’(x)\neq0$，则 $\exists \xi \in (a,b),s.t. \frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(\xi)}{g’(\xi)}$</p><p>证明过程都是构造函数，构造二者乘上对方的y的差值</p><h4><span id="等价形式">等价形式</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029115736845.png" alt="image-20231029115736845"></p><p><strong>思考题</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231029115834597.png" alt="image-20231029115834597"></p><h3><span id="三个定理的关系">三个定理的关系</span></h3><p>从最简单的形式逐步推向更复杂的性质。</p><h3><span id="应用">应用</span></h3><p>例题：</p><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231104094905156.png" alt="image-20231104094905156"></li></ol><p>注意观察柯西定理与题目中给出相等条件是否有关系</p><ol><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231104095349705.png" alt="image-20231104095349705"></p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231104095826211.png" alt="image-20231104095826211"></p></li><li></li></ol><h2><span id="函数单调性">函数单调性</span></h2><h3><span id="1-函数单调性判别定理">1 函数单调性判别定理</span></h3><h4><span id="定理-1">定理 1</span></h4><p>假设 $f(x)$在 $[a,b]$上连续，$(a,b)$内可导，则 $f(x)$ 在 $[a,b]$上递增（减）的充要条件是：$f’(x)\geq 0 (\leq 0),x \in (a,b)$</p><h4><span id="定理-2">定理 2</span></h4><p>$f(x)$在 $[a,b]$上连续，$(a,b)$内可导，则</p><ol><li>若$f’(x)&gt;0,x\in(a,b),f(x)$在 $[a,b]$上严格递增函数；</li><li>若$f’(x)&lt;0,x\in(a,b),f(x)$在 $[a,b]$上严格递减函数；</li></ol><p>注：严格单调递增函数也可能出现导数为0的情况，$y=x^3$</p><h4><span id="定理-3">定理 3</span></h4><p>$f(x)$在 $[a,b]$上连续，$(a,b)$内除有限个点外，$f’(x)\geq 0 (\leq 0)$，则$f(x)$在 $[a,b]$上严格递增（减）函数；</p><h4><span id="定理-4">定理 4</span></h4><p>设 $f(x)$在 $[a,b]$上连续，$(a,b)$内可导，则 $f(x)$ 在 $[a,b]$上严格单调递增（减）的充要条件是：</p><ol><li>$f’(x)\geq 0, \forall x\in (a,b);$</li><li>在 $(a,b)$的任意子开区间内，$f’(x)$不恒为零</li></ol><h3><span id="2-函数单调区间分析应用例题">2 函数单调区间分析应用例题</span></h3><p>一阶导数为零和不存在的点将函数的定义域分为了若干区间</p><p><strong>思考题</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231104102612484.png" alt="image-20231104102612484"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231104102647335.png" alt="image-20231104102647335"></p><h1><span id="极值问题">极值问题</span></h1><h2><span id="1-函数极值判定定理">1 函数极值判定定理</span></h2><h4><span id="定理1">定理1</span></h4><p>$f(x)$在 $[a,b]$上连续，$x_0\in(a,b)$</p><ol><li>若在 $x\in(x_0-\delta,x_0),f’(x)&gt;0;x\in(x_0,x_0+\delta),f’(x)&lt;0 \Rightarrow f(x_0)$为极大值</li><li>若在 $x\in(x_0-\delta,x_0),f’(x)&lt;0;x\in(x_0,x_0+\delta),f’(x)&gt;0 \Rightarrow f(x_0)$为极小值</li><li>若在 $x_0$两侧 $f’$不变号，则不是极值点</li></ol><p>注：该定理为充分条件，因为可能在 $x_0$邻域导数震荡，比如说 $y=sin(\frac{1}{x})$</p><h4><span id="定理-2">定理 2</span></h4><p>$f(x)$在 $[a,b]$上连续，$x_0\in(a,b),f’(x_0)=0,f’’(x_0)$存在，则：</p><ol><li>若 $f’’(x_0)&lt;0,f(x_0)$是极大值；</li><li>若 $f’’(x_0)&gt;0,f(x_0)$是极小值；</li><li>若 $f’’(x_0)=0,f(x_0)$不定。</li></ol><h2><span id="2-函数极值求解">2 函数极值求解</span></h2><p>求导找导数为0与不存在的点，找极值点，带入得极值</p><h2><span id="3-函数的最大-最小值">3 函数的最大、最小值</span></h2><h2><span id="凹凸函数与jansen定理">凹凸函数与Jansen定理</span></h2><h4><span id="定义">定义</span></h4><p>$y=f(x),x\in I, \forall x_1,x_2\in I, x_1\neq x_2,\forall \lambda_1,\lambda_2&gt;0,\lambda_1+\lambda_2=1$</p><ol><li>$f(\lambda_1x_1+\lambda_2x_2) \leq \lambda_1f(x_1)+\lambda_2f(x_2)$称 $f(x)$在I上为凸函数；</li><li>$f(\lambda_1x_1+\lambda_2x_2) &lt; \lambda_1f(x_1)+\lambda_2f(x_2)$严格凸函数</li></ol><p>凹函数定义相反</p><h4><span id="jansen不等式">Jansen不等式</span></h4><p>$y=f(x),x\in I, \forall x_1,x_2,\cdots,x_n\in I$，任意非负实数 $\{\lambda_i\}^n_{i=1}$满足 $\lambda_1+\cdots+\lambda_n=1$</p><ol><li>$f(x)$在 $I$上为凸函数，则有 $f(\sum^n_{i=1}\lambda_ix_i) \leq \sum^n_{i=1}\lambda_if(x_i)$</li><li>严格凸，则不带等号</li></ol><p>凹函数相反</p><h2><span id="凹凸函数判定定理">凹凸函数判定定理</span></h2><h4><span id="定理-1">定理 1</span></h4><p>$f$ 在I上是凸函数 $\Leftrightarrow \forall x_1&lt;x&lt;x_2 \in I, \frac{f(x)-f(x_1)}{x-x_1}\leq \frac{f(x_2)-f(x_1)}{x_2-x_1}\leq \frac{f(x_2)-f(x)}{x_2-x}$</p><p>严格就把 $\leq$换为 $&lt;$</p><p>凹函数相反</p><h4><span id="定理-2">定理 2</span></h4><p>设 $f(x)$在 $[a,b]$上连续，$(a,b)$内可导，则：</p><ol><li>$f(x)$在 $[a,b]$上为凸函数 $\Leftrightarrow f’(x)$在 $(a,b)$上单调递增</li><li>二者均严格时也成立</li><li>凹函数相反 </li></ol><h4><span id="定理-3">定理 3</span></h4><p>设 $f(x)$在 $[a,b]$上连续，$(a,b)$内二阶可导，则：</p><ol><li>$f(x)$在 $[a,b]$上为凸函数 $\Leftrightarrow f’’(x)\geq 0, \forall x \in (a,b)$</li><li>严格凸函数 $\Leftrightarrow f’’(x)\geq 0, \forall x \in (a,b)$，$(a,b)$的任意开子区间内，$f’’(x)$不恒为0</li></ol><h2><span id="洛必达法则">洛必达法则</span></h2><h3><span id="1-frac00">1 $\frac{0}{0}$</span></h3><p>设 $f(x),g(x)$定义在区间 $(x_0,x_0+\delta)$且 $g(x)\neq 0$, satisfy that:</p><ol><li>$\lim_{x\rightarrow x_0^+}f(x)=0,\lim_{x\rightarrow x_0^+}g(x)=0$</li><li>$f(x),g(x)$ derivable on interval $(x_0,x_0+\delta)$, and $g’(x)\neq 0$</li><li>$\lim_{x\rightarrow x_0^+}\frac{f’(x)}{g’(x)}=a$, a can be infinity</li></ol><p>then $\lim_{x\rightarrow x_0^+}\frac{f(x)}{g(x)}=\lim_{x\rightarrow x_0^+}\frac{f’(x)}{g’(x)}=a$</p><h3><span id="2-fracinftyinfty">2 $\frac{\infty}{\infty}$</span></h3><p>设 $f(x),g(x)$定义在区间 $(x_0,x_0+\delta)$且 $g(x)\neq 0$, satisfy that:</p><ol><li>$\lim_{x\rightarrow x_0^+}f(x)=\infty,\lim_{x\rightarrow x_0^+}g(x)=\infty$</li><li>$f(x),g(x)$ derivable on interval $(x_0,x_0+\delta)$, and $g’(x)\neq 0$</li><li>$\lim_{x\rightarrow x_0^+}\frac{f’(x)}{g’(x)}=l$, l can be infinity</li></ol><p>then $\lim_{x\rightarrow x_0^+}\frac{f(x)}{g(x)}=\lim_{x\rightarrow x_0^+}\frac{f’(x)}{g’(x)}=l$</p><p>求解极限的过程中可以通过换元、等价无穷小替换的方式进行</p><h3><span id="应用">应用</span></h3><ol><li>$0\cdot \infty$ <ul><li>$\Rightarrow \frac{1}{\infty}\cdot\infty $ or $0\cdot \frac{1}{0}$</li></ul></li><li>$\infty - \infty$<ul><li>$\Rightarrow \frac{1}{0}-\frac{1}{0} \Rightarrow \frac{0-0}{0\cdot0}$</li></ul></li><li>$0^0,1^\infty,\infty^0$<ul><li>take the logarithm and get the result $a$</li><li>the answer is $e^a$</li></ul></li></ol><h3><span id="函数作图">函数作图</span></h3><h4><span id="定义">定义</span></h4><p>函数凹凸的分界点为拐点</p><h4><span id="定理">定理</span></h4><p>$f(x)$ is second order derivable on $U(x_0,\delta_1)$, and $x=x_0$ is inflection point, then $f’’(x_0)=0$</p><h4><span id="定理">定理</span></h4><p>$f(x)$ has a third derivative on $U(x_0,\delta)$, and $f’’(x_0)=0, f’’’(x_0)\neq 0$, then $(x_0,f(x_0))$ is the inflection point of $f(x)$</p><h4><span id="draw-the-graph-of-the-function">Draw the graph of the function</span></h4><p>Step 1: analysis the domain of definition, parity, symmetry of the function  $y=f(x)$</p><p>Step 2: calculate the asymptotic line</p><p>Step 3: calculate the first, second derivative and find the point where the first or the second derivative equals  zero or doesn’t exist. Let the set of these point be $\{x_i\}^n_{i=1}$</p><p>Step 4: $\{x_i\}^n_{i=1}$ commutes the domain of function into $n+1$ subintervals and analysis the monotonicity and convexity of each interval.</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231104165706165.png" alt="image-20231104165706165"></p><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理与信息隐藏第七周学习日志</title>
      <link href="/2023/10/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E7%AC%AC%E4%B8%83%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E7%AC%AC%E4%B8%83%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>图像变换</p><span id="more"></span><h2><span id="0x01-概述">0x01 概述</span></h2><p>图像变换的目的：</p><ul><li>高效、快速地对图像进行处理和分析</li><li>为顶层应用提供特征</li></ul><p>图像变换用二位线性系统描述</p><p>待处理图像$f(x,y)$，处理后图像$g(x,y)$，输入和输出的关系表示为$g(x,y)=\psi[f(x,y)]$</p><p>对于一维实际系统，变量为时间，输出是过去和现在的函数，因果系统；</p><p>图像处理的二维系统为非因果系统。</p><p>数字图像处理的算法一般都为线性的，为了高效、快速地对图像进行处理和分析，需要将原有的图像空间以某种形式转换到另外一些空间，并利用这些性质进行一定的加工。</p><h2><span id="0x02-图像的线性运算">0x02 图像的线性运算</span></h2><h3><span id="21-二维连续线性系统">2.1 二维连续线性系统</span></h3><p>系统连续：其冲激响应为$(x,y)$的连续函数；</p><p>叠加原理：$\psi[af_1(x,y)+bf_2(x,y)]=a\psi[f_1(x,y)]+b\psi[f_2(x,y)]=ag_1(x,y)+bg_2(x,y)$</p><h4><span id="二维狄拉克冲激函数">二维狄拉克冲激函数</span></h4><script type="math/tex; mode=display">\delta(x,y)= \begin{cases}         \infty \  \ x=0,y=0 \\        0 \ \ \ \ else\end{cases}</script><p>性质：</p><script type="math/tex; mode=display">\iint_{-\infty,-\infty}^{\infty,\infty} \delta(x,y)dxdy=1  （筛选性）\\\delta(x-\alpha,y-\beta)= \begin{cases}         \infty \  \ x=\alpha,y=\beta \\         0 \ \ \ \ else\end{cases} （可分离性）</script><h4><span id="二位冲激响应函数">二位冲激响应函数</span></h4><p>以二位狄拉克冲激函数作为输入时系统的输出响应函数</p><script type="math/tex; mode=display">h(x,y;\alpha,\beta) = \psi[\delta(x-\alpha,y-\beta)]</script><p>在光学系统里，此冲激响应一般称为点扩散函数 PSF Point Spread Function</p><h4><span id="空间不变系统-位移不变系统">空间不变系统 位移不变系统</span></h4><script type="math/tex; mode=display">h(x,y;\alpha,\beta) = h(x-\alpha,y-\beta)</script><h4><span id="卷积">卷积</span></h4><ul><li><p>连续情况</p><ul><li><script type="math/tex; mode=display">s(t) = \int x(a)w(t-a)da\\ \Downarrow \\s(t) = (x*w)(t)</script></li></ul></li></ul><ul><li><p>离散情况</p><ul><li><script type="math/tex; mode=display">s[t]=(x*w)(t) = \sum_{a=-\infty}^{\infty}x[a]w[t-a]</script></li></ul></li><li><script type="math/tex; mode=display">g(x,y)=f(x,y)*h(x,y)</script></li></ul><h4><span id="相关">相关</span></h4><p><strong>自相关</strong></p><script type="math/tex; mode=display">\begin{align}R_{ff}(x,y)& =f(x,y)\circ f(x,y)\\& =f(x,y)*f(-x,-y) \\& = \iint f(\alpha,\beta)f(x+\alpha,y+\beta)d\alpha d\beta\end{align}</script><p><strong>互相关</strong></p><script type="math/tex; mode=display">\begin{align}R_{fg}(x,y)& =f(x,y)\circ g(x,y)\\& =f(x,y)*g(-x,-y) \\& = \iint f(\alpha,\beta)g(x+\alpha,y+\beta)d\alpha d\beta\end{align}</script><h4><span id="图像的卷积二维离散卷积">图像的卷积：二维离散卷积</span></h4><p>根据图像处理的顺序，采用互相关</p><h3><span id="22-二维连续傅里叶变换">2.2 二维连续傅里叶变换</span></h3><h4><span id="一维情况">一维情况</span></h4><p>若实变量函数$f(x)$是连续可积的，即：$\int_{-\infty}^{\infty}|f(x)|dx&lt;\infty$且$F(u)$是可积的，则傅里叶变换对一定存在</p><script type="math/tex; mode=display">\mathcal{F\{f(x)\}} = F(u) = \int_\infty^\infty f(x)e^{-j2\pi ux}dx \\\mathcal{F^{-1}\{F(x)\}} = f(x) = \int_\infty^\infty F(u)e^{j2\pi ux}du</script><p>如果f(x)考虑为实函数，它的傅里叶变换通常是复数形式，$F(u)=R(u)+jI(u)$，也可以表示为$F(u)=|F(u)|e^{j\phi(u)}$</p><p>$|F(u)|=\sqrt{R^2(u)+I^2(u)}$称为傅里叶谱，或频谱；</p><p>$\phi(u)=arctg[\frac{I(u)}{R(u)}]$称为$f(x)$的相角</p><h4><span id="二维情况">二维情况</span></h4><p>若实变量函数$f(x,y)$是连续可积的，即：$\int_{-\infty}^{\infty}|f(x,y)|dxdy&lt;\infty$且$F(u,v)$是可积的，则傅里叶变换对一定存在</p><script type="math/tex; mode=display">\mathcal{F\{f(x,y)\}} = F(u,v) = \int_\infty^\infty f(x,y)e^{-j2\pi(ux+vy) }dxdy \\\mathcal{F^{-1}\{F(u,v)\}} = f(x,y) = \int_\infty^\infty F(u,v)e^{j2\pi(ux+vy)}dudv</script><p>$|F(u,v)|=\sqrt{R^2(u,v)+I^2(u,v)}$称为傅里叶谱，或频谱；</p><p>$\phi(u,v)=arctg[\frac{I(u,v)}{R(u,v)}]$称为$f(x,y)$的相位;</p><p>$E(u,v)={R^2(u,v)+I^2(u,v)}$ 功率谱</p><h2><span id="0x03-二维离散傅里叶变换及其性质">0x03 二维离散傅里叶变换及其性质</span></h2><h3><span id="1-概述">1 概述</span></h3><p>直接卷积和相关运算在时域中处理计算量大，很难实时处理</p><p>Discrete Fourier Transform DFT 建立了离散时域和离散频域之间的联系，处理方便，计算量小，提高速度。</p><h3><span id="2-二维离散傅里叶变换">2 二维离散傅里叶变换</span></h3><script type="math/tex; mode=display">F(u) = \sum_{x=0}^{N-1}f(x)e^{-j2\pi ux/N} \\f(x) = \frac{1}{N} \sum_{u=0}^{N-1}F(u)e^{-j2\pi ux/N}</script><p>x，u就是离散的整数值</p><script type="math/tex; mode=display">F(u,v) = \sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi ( ux/M + vy/N)} \\f(x,y) = \frac{1}{MN} \sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{-j2\pi ( ux/M + vy/N)}</script><h3><span id="3-二维离散傅里叶变换的性质">3 二维离散傅里叶变换的性质</span></h3><ol><li>线性：设a,b为常量</li><li>可分离性：一个二维傅里叶变换可以分解为两个以为傅里叶变换1<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231020100105232.png" alt="image-20231020100105232"></li></ul></li><li>平移性<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231020100047732.png" alt="image-20231020100047732"></li></ul></li><li>周期性和共轭对称性<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231020100251251.png" alt="image-20231020100251251"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231020100301552.png" alt="image-20231020100301552"></li></ul></li><li>旋转不变性<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231020100323400.png" alt="image-20231020100323400"></li></ul></li><li>分配性和比例性<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231020100406357.png" alt="image-20231020100406357"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231020100419775.png" alt="image-20231020100419775"></li></ul></li><li>平均值<ul><li></li></ul></li></ol><h3><span id="4-应用傅里叶变换注意的问题">4 应用傅里叶变换注意的问题</span></h3><p>复数运算费时，高频衰减快</p><h2><span id="0x04-图像变换的">0x04 图像变换的</span></h2><h3><span id="1-代数表达式">1 代数表达式</span></h3><h2><span id="0x05-离散沃尔什哈达玛变换">0x05 离散沃尔什——哈达玛变换</span></h2><h3><span id="1-一维离散沃尔什变换">1 一维离散沃尔什变换</span></h3><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯中文文本分类</title>
      <link href="/2023/10/18/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
      <url>/2023/10/18/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>贝叶斯文本分类实现分类中文文本</p><span id="more"></span><h2><span id="0x01-数据集">0x01 数据集</span></h2><h3><span id="数据集下载">数据集下载</span></h3><p>本文采用了清华NLP组提供的THUCNews新闻文本分类数据集的子集<br>数据下载链接：<br>THUCNews数据子集：<a href="https://pan.baidu.com/s/1hugrfRu">https://pan.baidu.com/s/1hugrfRu</a> 密码：qfud</p><h3><span id="数据集分析">数据集分析</span></h3><p>分为十类：</p><ul><li>[‘体育’, ‘财经’, ‘房产’, ‘家居’, ‘教育’, ‘科技’, ‘时尚’, ‘时政’, ‘游戏’, ‘娱乐’]</li><li>每个分类6500条数据，总共65000条数据</li></ul><p>数据集共三个文件：</p><ol><li>train 训练集 5000*10条</li><li>val 验证集 500*10条</li><li>test 测试集 1000*10条</li></ol><h2><span id="0x02-初始版本">0x02 初始版本</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">    <span class="comment"># 该函数返回的第一个变量是进行词条切分后的文档集合</span></span><br><span class="line">    <span class="comment"># 函数返回的第二个变量是一个类别标签的集合</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>(<span class="params">contents, label:<span class="built_in">list</span></span>) -&gt; (<span class="built_in">list</span>,<span class="built_in">list</span>):</span><br><span class="line">    <span class="comment"># @postinglist: 每一个文本进行分词后的结果</span></span><br><span class="line">    <span class="comment"># @classvec: 文本变量的标签</span></span><br><span class="line">    <span class="comment"># 数据集中分为了10类，这里的postinglist我打算使用训练集的所有数据。</span></span><br><span class="line">    <span class="comment"># 类别的数字为0-9</span></span><br><span class="line">    postingList = contents.to_list()</span><br><span class="line">    postingList = [item.split() <span class="keyword">for</span> item <span class="keyword">in</span> postingList]</span><br><span class="line">    classVec = label    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> postingList, classVec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建词汇表</span></span><br><span class="line">    <span class="comment"># 集合结构内元素的唯一性，创建一个包含所有词汇的词表。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVocabList</span>(<span class="params">dataSet</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    vocabSet = <span class="built_in">set</span>([])  <span class="comment"># 建立一个空列表</span></span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        vocabSet = vocabSet | <span class="built_in">set</span>(document) <span class="comment"># 合并两个集合</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setOfWords2Vec</span>(<span class="params">vocabList, inputSet</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    returnVec = [<span class="number">0</span>]*<span class="built_in">len</span>(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the word: %s is not in my Vocabulary!&quot;</span> % word)</span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行训练， 这里就是计算： 条件概率 和 先验概率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trainNB0</span>(<span class="params">trainMatrix, trainCategory</span>):</span><br><span class="line">    numTrainDocs = <span class="built_in">len</span>(trainMatrix)  <span class="comment"># 计算总的样本数量</span></span><br><span class="line">    <span class="comment"># 计算样本向量化后的长度， 这里等于词典长度。</span></span><br><span class="line">    numWords = <span class="built_in">len</span>(trainMatrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 计算先验概率</span></span><br><span class="line">    pClass = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> trainCategory:</span><br><span class="line">        pClass[each] += <span class="number">1</span></span><br><span class="line">    pClass = [each / <span class="built_in">float</span>(numTrainDocs) <span class="keyword">for</span> each <span class="keyword">in</span> pClass]</span><br><span class="line">    <span class="comment"># 进行初始化， 用于向量化后的样本 累加， 为什么初始化1不是全0， 防止概率值为0.  </span></span><br><span class="line">    pNums = [np.ones(numWords) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 初始化求条件概率的分母为2， 防止出现0，无法计算的情况。</span></span><br><span class="line">    pDenoms = [<span class="number">2.0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 遍历所有向量化后的样本， 并且每个向量化后的长度相等， 等于词典长度。</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTrainDocs):</span><br><span class="line">        <span class="comment"># 统计标签为1的样本： 向量化后的样本的累加， 样本中1总数的求和， 最后相除取log就是条件概率。 </span></span><br><span class="line">        pNums[trainCategory[i]] += trainMatrix[i]</span><br><span class="line">        pDenoms[trainCategory[i]] += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求条件概率。</span></span><br><span class="line"></span><br><span class="line">    pVects = [np.log(pNums[i] / pDenoms[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 返回条件概率 和 先验概率</span></span><br><span class="line">    <span class="keyword">return</span> pVects, pClass</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_max_index</span>(<span class="params">lst</span>):</span><br><span class="line">    max_value = <span class="built_in">max</span>(lst)</span><br><span class="line">    max_index = lst.index(max_value)</span><br><span class="line">    <span class="keyword">return</span> max_index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里分类的逻辑需要改</span></span><br><span class="line"><span class="comment"># 通过条件概率 和 先验概率 对新的样本进行向量化后分类。哪个类别的概率大，则属于哪个类别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classifyNB</span>(<span class="params">vec2Classify, pVs, pClass1</span>):</span><br><span class="line">    <span class="comment"># 向量化后的样本 分别 与 各类别的条件概率相乘 加上先验概率取log，之后进行大小比较, 输出类别。</span></span><br><span class="line"></span><br><span class="line">    ps = [<span class="built_in">sum</span>(vec2Classify * pVs[i]) + np.log(pClass1[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pVs))]</span><br><span class="line">    <span class="keyword">return</span> get_max_index(ps)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testingNB</span>(<span class="params">train_content, label, test_content</span>):</span><br><span class="line">    categories = [<span class="string">&#x27;体育&#x27;</span>, <span class="string">&#x27;财经&#x27;</span>, <span class="string">&#x27;房产&#x27;</span>, <span class="string">&#x27;家居&#x27;</span>, <span class="string">&#x27;教育&#x27;</span>, <span class="string">&#x27;科技&#x27;</span>, <span class="string">&#x27;时尚&#x27;</span>, <span class="string">&#x27;时政&#x27;</span>, <span class="string">&#x27;游戏&#x27;</span>, <span class="string">&#x27;娱乐&#x27;</span>]</span><br><span class="line">    <span class="comment"># 生成训练样本 和 标签</span></span><br><span class="line">    listOPosts, listClasses = loadDataSet(train_content, label)</span><br><span class="line">    <span class="comment"># 创建词典</span></span><br><span class="line">    myVocabList = createVocabList(listOPosts)</span><br><span class="line">    <span class="comment"># 用于保存样本转向量之后的</span></span><br><span class="line">    trainMat=[]</span><br><span class="line">    <span class="comment"># 遍历每一个样本， 转向量后， 保存到列表中。</span></span><br><span class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">    <span class="comment"># 计算 条件概率 和 先验概率</span></span><br><span class="line">    pVs, pClass = trainNB0(np.array(trainMat), np.array(listClasses))</span><br><span class="line">    <span class="comment"># 给定测试样本 进行测试</span></span><br><span class="line">    testEntry = test_content.to_list()</span><br><span class="line">    testEntry = [item.split() <span class="keyword">for</span> item <span class="keyword">in</span> testEntry]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">len</span>(testEntry):</span><br><span class="line">        thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry[i]))</span><br><span class="line">        <span class="built_in">print</span>(testEntry,<span class="string">&#x27;classified as: &#x27;</span>, categories[classifyNB(thisDoc, pVs, pClass)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data_tfidf_2.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        tfidf_data = pickle.load(f)</span><br><span class="line">    X = tfidf_data[<span class="number">0</span>]</span><br><span class="line">    y = tfidf_data[<span class="number">1</span>] <span class="comment"># X为特征矩阵，y为标签 X.shape[0]为样本的数量，X.shape[1]为特征的数量,y代表了每个样本所属第几类</span></span><br><span class="line">    train_contents = tfidf_data[<span class="number">3</span>]</span><br><span class="line">    test_contents = tfidf_data[<span class="number">4</span>]</span><br><span class="line">    testingNB(train_contents, y,test_contents)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="0x03-加速">0x03 加速</span></h2><ol><li>全局变量优化</li><li>模块和函数属性访问优化</li><li>将训练的结果保存下来</li></ol><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全协议第七周学习日志</title>
      <link href="/2023/10/17/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E4%B8%83%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/17/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E4%B8%83%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>安全多方计算</p><p>秘密共享</p><span id="more"></span><h1><span id="安全多方计算">安全多方计算</span></h1><h2><span id="0x01-基本概念">0x01 基本概念</span></h2><ul><li>信任环境或整体安全定义通常由真实-理想模型来表达</li><li>该模型下的安全性：真实环境下的敌手无法产生比理想环境下的攻击者更多的危害</li><li>根据攻击者能力定义两种不同攻击者的安全模型<ul><li>半诚实模型（更关注性能</li><li>恶意行为模型（更关注安全</li><li>大规模的安全多方计算产品，通常只考虑半诚实模型</li></ul></li><li>方法主要分为两类：<ul><li>基于噪音的安全计算方法<ul><li>代表是差分隐私</li></ul></li><li>非噪音方法<ul><li>编码或加密</li><li>代表性工作：混淆电路、同态加密、密钥分享</li></ul></li><li>优点：安全性有保证</li><li>缺点：计算量、通讯量大</li></ul></li><li>安全多方计算技术是一系列技术组成的协议栈，按层次分为2层<ul><li>支撑技术层<ul><li>MPC基础技术实现</li></ul></li></ul></li></ul><h2><span id="0x02">0x02</span></h2><h2><span id="0x03-基础技术">0x03 基础技术</span></h2><h3><span id="秘密分享-ss-secret-sharing">秘密分享 SS Secret Sharing</span></h3><h3><span id="不经意传输-ot-oblivious-transfer">不经意传输 OT oblivious transfer</span></h3><h3><span id="混淆电路-gc-garbled-circuit">混淆电路 GC Garbled Circuit</span></h3><h3><span id="同态加密-he-homomorphic-encryption">同态加密 HE Homomorphic Encryption</span></h3><h2><span id="0x04-应用">0x04 应用</span></h2><h1><span id="秘密分享">秘密分享</span></h1><h2><span id="0x01-基本概念">0x01 基本概念</span></h2><h1><span id="认证密钥协商协议">认证密钥协商协议</span></h1><p>​    在实际应用系统中，一般使用公钥密码或其他方法来确立一个适用于对称密码的共享密钥，即会话密钥 session key。建立这种仅用于一次会话的会话密钥机制就是密钥交换协议。所谓密钥交换 key exchange也称密钥协商 key agreement 是一种协议。</p><p>​    利用这种协议，通信双方在一个<strong>公开的</strong>信道上通过相互传递某些信息来<strong>共同建立</strong>一个<strong>共享的</strong>秘密密钥。</p><h2><span id="1-两方dh密钥协商">1 两方DH密钥协商</span></h2><h2><span id="2-mti密钥交换">2 MTI密钥交换</span></h2><h2><span id="3-ecmqv-密钥交换">3 ECMQV 密钥交换</span></h2><h2><span id="4-基于身份的密钥协商">4 基于身份的密钥协商</span></h2><h2><span id="5-三方密钥交换协议">5 三方密钥交换协议</span></h2><h2><span id="6-多方密钥交换协议">6 多方密钥交换协议</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 安全协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理第六周学习日志</title>
      <link href="/2023/10/13/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/13/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>数学基础：概率论、信息论</p><span id="more"></span><h2><span id="0x01-概率论基础">0x01 概率论基础</span></h2><h3><span id="二项式分布">二项式分布</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013141054803.png" alt="image-20231013141054803"></p><p>自然语言处理中，一般以句子为处理单位。假设一个句子独立于它前面的其他语句，句子的概率分布近似认为符合二项式分布。</p><h3><span id="期望">期望</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013141209244.png" alt="image-20231013141209244"></p><h3><span id="方差">方差</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013141507936.png" alt="image-20231013141507936"></p><h2><span id="0x02-信息论基础">0x02 信息论基础</span></h2><h3><span id="熵">熵</span></h3><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第六周学习日志</title>
      <link href="/2023/10/11/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/11/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>对称加密</p><span id="more"></span><h2><span id="0x01-perfect-indistinguishability">0x01 Perfect Indistinguishability</span></h2><h2><span id="0x02-security-definition-of-encryption">0x02 Security Definition of Encryption</span></h2><h3><span id="definition-34-function-negligibility">Definition 3.4 function negligibility</span></h3><ul><li>A function $f : Z^+\rightarrow Z^+ $ is <strong>polynomical</strong> if there exists <em>c</em> such that $f(n) &lt; n^C$ for large enough <em>n</em> </li></ul><h3><span id="necessity-of-relaxations">Necessity of Relaxations</span></h3><ol><li>limit the time to defend the attack from an unbounded attacker</li><li>allow a very small probability of success to </li></ol><h3><span id="defintion-37-private-key-encryption-scheme">Defintion 3.7 Private-key encryption scheme</span></h3><h2><span id="0x03-eav-secure-encryption-schemes">0x03 EAV-Secure Encryption Schemes</span></h2><p>uniformity is not a property of a string, but a property of a distribution.</p><p>pseudorandomness is a property of a distribution not a string.</p><h2><span id="0x04-multiple-encryptions">0x04 Multiple Encryptions</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学竞赛代码记录</title>
      <link href="/2023/10/10/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AB%9E%E8%B5%9B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/10/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AB%9E%E8%B5%9B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>记录emp-ot的代码情况</p><span id="more"></span><h2><span id="论文伪代码">论文伪代码</span></h2><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012105749879.png" alt="image-20231012105749879"></p><p>表一：COT函数</p><p>$\Delta$由S生成</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012105916449.png" alt="image-20231012105916449"></p><p>表二：流程图</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110027949.png" alt="image-20231012110027949"></p><p>表三：SPCOT</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110243621.png" alt="image-20231012110243621"></p><p>表四：MPCOT </p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110340328.png" alt="image-20231012110340328"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110550394.png" alt="image-20231012110550394"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110646401.png" alt="image-20231012110646401"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110738103.png" alt="image-20231012110738103"></p><h2><span id="0x02-修改思路">0x02 修改思路</span></h2><p>将 <code>spcot_recver</code> <code>spcot_sender</code> <code>iknp</code>  <code>base_cot</code> <code>co</code> <code>cot</code>放入TCO</p><p>将 <code>mpcot_reg</code> ``</p><p>lib BaseOT.h 与 emp ot.h\co.h 干的一件事</p><p>emp inkp 在 lib 的Iknp中有文件，分为了rcv\send</p><p>emp base_cot 引用Iknp </p><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
          <category> 密码学竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全协议第六周学习日志</title>
      <link href="/2023/10/10/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/10/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>形式化分析工具 <code>Scyther</code>的安全协议实例分析</p><p>可证明安全理论</p><span id="more"></span><h2><span id="0x01-scyther-工具简介">0x01 Scyther 工具简介</span></h2><p>用于自动验证安全协议的工具</p><h2><span id="0x02-scyther-使用方法">0x02 Scyther 使用方法</span></h2><h3><span id="描述语法">描述语法</span></h3><h2><span id="0x03-scyther-应用分析实例">0x03 Scyther 应用分析实例</span></h2><h1><span id="可证明安全理论">可证明安全理论</span></h1><h2><span id="不可区分性cpa">不可区分性CPA</span></h2><p>不可区分性 indistinguishability IND</p><p>0</p><h1><span id="比特承诺">比特承诺</span></h1><h2><span id="协议简介">协议简介</span></h2><h3><span id="基本思想">基本思想</span></h3><ul><li>Alice承诺者， Bob验证者</li><li>A发送给B一个证明</li></ul><p>两个阶段：承诺阶段、打开阶段</p><p>两个安全性质：隐藏性、绑定性</p><h2><span id="常用比特承诺协议">常用比特承诺协议</span></h2><h2><span id="协议应用">协议应用</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 安全协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第六周学习日志</title>
      <link href="/2023/10/08/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/08/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>前言</p><p>关系数据库标准语言SQL</p><span id="more"></span><h2><span id="31-sql概述">3.1 SQL概述</span></h2><ul><li>SQL Structured Query Language<ul><li>结构化查询语言，是关系数据库的标准语言</li></ul></li><li>SQL是一个通用的、功能极强的关系数据库语言</li></ul><h3><span id="311-sql的起源和发展">3.1.1 SQL的起源和发展</span></h3><h3><span id="312-sql语言">3.1.2 SQL语言</span></h3><ol><li>综合统一<ul><li>数据定义DDL、数据操纵DML、数据控制DCL功能于一体，还有事务控制语言TCL</li><li>Data Definition Language: Create/Alter/Drop—schema定义</li><li>Data Manipulation Language: Insert/Select/Update/Delete — 数据查询及修改</li><li>Data Control Language: Grant/Revoke—权限修改</li><li>Transaction Control Language: Begin Transaction/Commit/Rollback—数据修改的原子性</li><li>可以独立完成数据库生命周期中的全部活动</li><li>可根据需要随时逐步修改模式，不影响运行</li><li>数据操作统一</li></ul></li><li>高度非过程化</li><li>面向集合的做做方法</li><li>以同一种语法结构提供多种使用方法<ul><li>SQL独立语言</li><li>SQL嵌入式语言</li><li>更多的采用数据库驱动程序API</li></ul></li><li>语言简洁<ul><li>核心功能只用9个动词<ul><li>Create、Alter、Drop</li><li>Insert、Delete、Update、Select</li><li>Grant、Revoke</li></ul></li></ul></li></ol><h3><span id="313-sql基本概念">3.1.3 SQL基本概念</span></h3><ul><li>基本表<ul><li>本身独立存在的表</li><li>SQL中一个关系对应一个基本表</li><li>一个基本表对应一个存储文件</li><li>一个表可以有若干索引</li></ul></li><li>存储文件<ul><li>逻辑结构 schema 组成了关系数据库的模式</li><li>物理结构</li><li>文件路径和文件名可由用户配置或指定</li><li></li></ul></li><li>视图<ul><li>从一个或几个基本表通过查询而导出的表</li><li></li><li>视图是虚表</li><li></li></ul></li></ul><h2><span id="32-学生-课程数据库">3.2 学生-课程数据库</span></h2><ul><li>学生-课程模式 S-T：<ul><li>学生表：Student(Sno, Sname, Ssex, Sage, Sdept)</li><li>课程表：Course(Cno,Cname,Cpno,Ccredit)</li><li>学生选课表：SC(Sno,Cno,Grade)</li></ul></li></ul><h2><span id="33-数据定义">3.3 数据定义</span></h2><h3><span id> </span></h3><ul><li>SQL 的数据定义功能<ul><li>模式定义<ul><li>定义结构和命名空间</li><li>RDBMS提供了一个层次化的数据库对象命名机制</li></ul></li><li>表定义</li><li>视图和索引的定义</li></ul></li></ul><h3><span id="331-模式的定义与删除">3.3.1 模式的定义与删除</span></h3><h4><span id="定义模式">定义模式</span></h4><p>定义模式实际上定义了一个命名空间</p><p>The schema containing object can be table, column, data type, view, stored procedures, relationships, primary key, foreign key. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>SCHEMA_NAME<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>USER_NAME<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="删除模式">删除模式</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>SHEMA_NAME<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE<span class="operator">|</span>RESTRICT<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>CASCADE: 级联</li><li>RESTRICT：限制</li></ul><h4><span id="数据库连接的基本参数">数据库连接的基本参数</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013160605003.png" alt="image-20231013160605003"></p><p>Oracle授权：</p><blockquote><p>GRANT CONNECT,RESOURCE,DBA TO <user_name></user_name></p></blockquote><h3><span id="332-基本表的定义-删除与修改">3.3.2 基本表的定义、删除与修改</span></h3><ul><li><p>定义基本表</p><blockquote><p>CREATE TABLE &lt;表名&gt;</p><p>(&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;],&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;],…,[&lt;表级约束条件&gt;])    </p></blockquote><ul><li></li></ul></li></ul><ol><li>数据类型<ul><li>域的概念：SQL用数据类型来实现</li><li>定义表的属性时，需要指明其数据类型及长度</li><li>选用哪种数据类型<ul><li>物理意义与格式</li><li>取值范围</li><li>是否允许为空</li></ul></li><li>字符串类型</li><li>日期与时间类型</li></ul></li></ol><h4><span id="修改基本表">修改基本表</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161732128.png" alt="image-20231013161732128"></p><h4><span id="删除基本表">删除基本表</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161751823.png" alt="image-20231013161751823"></p><h3><span id="333-索引的建立与删除">3.3.3 索引的建立与删除</span></h3><ul><li>建立索引的目的：加快查询速度</li><li>常见索引<ul><li>顺序文件上的索引</li><li>B+树索引</li><li>hash索引</li><li>bitmap索引</li></ul></li></ul><h4><span id="建立索引">建立索引</span></h4><ul><li>数据库管理员或表的属主可以建立索引</li><li>关系数据库管理系统自动完成维护索引</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161837333.png" alt="image-20231013161837333"></p><h4><span id="修改索引">修改索引</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161852062.png" alt="image-20231013161852062"></p><h4><span id="删除索引">删除索引</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161909044.png" alt="image-20231013161909044"></p><h3><span id="334-数据字典">3.3.4 数据字典</span></h3><p>数据字典是关系数据库管理系统内部的一组系统表，记录了数据库中所有定义信息</p><h2><span id="34-数据查询">3.4 数据查询</span></h2><ul><li>语句格式</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161932540.png" alt="image-20231013161932540"></p><h3><span id="341-单表查询">3.4.1 单表查询</span></h3><ol><li>选择表中若干列<ul><li>使用列别名改变查询结果的列标题</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013162507827.png" alt="image-20231013162507827"></li></ul></li><li>选择表中若干元组<ul><li>消除取值重复的行：指定DISTINCT关键字</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013162632798.png" alt="image-20231013162632798"></li><li>%代表任意长度的字符串</li><li>_代表任意单个字符</li><li>MySQL/Oracle缺省的转义字符是’\’</li><li>IS NULL 不能用 = 代替</li></ul></li><li>ORDER BY 子句<ul><li>ASC：升序（缺省）</li><li>DESC：降序</li></ul></li><li>聚集函数<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013163400697.png" alt="image-20231013163400697"></li></ul></li><li>GROUP BY子句<ul><li>分组：细化聚集函数的作用对象</li><li>按指定的一列或多列值分组，值相等的为一组</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013164746552.png" alt="image-20231013164746552"></li><li>HAVING作用于组</li></ul></li></ol><p>COUNT(*)会统计NULL的记录数量</p><h3><span id="342-连接查询">3.4.2 连接查询</span></h3><h3><span id="343-嵌套查询">3.4.3 嵌套查询</span></h3><h3><span id="344-集合查询">3.4.4 集合查询</span></h3><h3><span id="345-基于派生表的查询">3.4.5 基于派生表的查询</span></h3><h3><span id="346-select语句的一般形式">3.4.6 Select语句的一般形式</span></h3><h2><span id="35-数据更新">3.5 数据更新</span></h2><h2><span id="36-空值的处理">3.6 空值的处理</span></h2><h2><span id="37-视图">3.7 视图</span></h2><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Environment Blog</title>
      <link href="/2023/10/08/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Environment-Blog/"/>
      <url>/2023/10/08/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Environment-Blog/</url>
      
        <content type="html"><![CDATA[<h2><span id="q1e-release-file-for-httpsmirrorstunatsinghuaeducnubuntudistsbionic-updatesinrelease-is-not-valid-yet-invalid-for-another-6h-46min-10s-updates-for-this-repository-will-not-be-applied">Q1：E: Release file for  is not valid yet (invalid for another 6h 46min 10s). Updates for this repository will not be applied.</span></h2><p>参考教程：<a href="https://askubuntu.com/questions/1096930/sudo-apt-update-error-release-file-is-not-yet-valid">sudo apt 更新错误：“发布文件尚未生效” - 询问 Ubuntu (askubuntu.com)</a></p><h2><span id="q2e-unable-to-correct-problems-you-have-held-broken-packages">Q2：E: Unable to correct problems, you have held broken packages.</span></h2><p>当apt破损时，可能的一个原因是由于 <code>/etc/apt/source.list</code>的源不是ubuntu 20.04的</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 实践知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习日志</title>
      <link href="/2023/10/07/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E8%B7%B5/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/07/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E8%B7%B5/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络内容安全第五周学习日志PLUS</title>
      <link href="/2023/10/05/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97PLUS/"/>
      <url>/2023/10/05/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97PLUS/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>文本分类算法的学习，未完成</p><span id="more"></span><h1><span id="文本挖掘文本分类算法">文本挖掘——文本分类算法</span></h1><h2><span id="1-评价指标">1 评价指标</span></h2><p>文本自动分类的定义：在给定的分类体系下，根据文本的内容自动地确定文本关联的类别。</p><p>从数学角度来看，文本分类是一个映射的过程，它将未标明类别的文本映射到已有的类别中，该映射可以是一一、一对多的映射</p><p>文本分类基本步骤：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005135232112.png" alt="image-20231005135232112"></p><p>评价指标</p><ul><li>准确率 P precision<ul><li>正确分类样本所占的比例</li></ul></li><li>召回率 R recall<ul><li>分母是所有真正的正类测试样本</li></ul></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140046034.png" alt="image-20231005140046034"></li><li>F-Measure<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140842378.png" alt="image-20231005140842378"></li></ul></li></ul><p>所有类的总体评价 </p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140913540.png" alt="image-20231005140913540"></p><p>宏平均 Macro</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140933313.png" alt="image-20231005140933313"></p><p>微平均 Micro</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140957431.png" alt="image-20231005140957431"></p><h2><span id="2-特征选择">2 特征选择</span></h2><p>目的：</p><ul><li>避免过拟合 over fitting ，提高分类精确度<ul><li>对训练文档适应的很好，但是对训练集之外的文档差许多，则产生了over-fitting problem</li><li>希望表现对训练集和未知文档基本一致</li></ul></li><li>通过降维，大大节省计算空间和时间</li></ul><p>特征提取的方法</p><ul><li>文档概率法 DF document frequency</li><li>信息增益法 information gain</li><li>互信息法 mutual information </li><li>开方拟合检验 the $\chi ^ 2$ test</li></ul><p><strong>DF</strong></p><p>基于DF的启发式要点：</p><ul><li>太频繁的词项没有区分度<ul><li>Term的DF大于某个阈值则去掉</li></ul></li><li>太稀有的词项独立表达的类别信息不强<ul><li>稀有词项的全局影响力不大</li><li>在训练集中，某些文档如果有某个稀有词项，他们通常也会有一些常见词项</li></ul></li><li>和通常信息获取观念有些抵触：稀有的更有代表性？这个是只获取的观念是稀有的则更有代表性吗:cry:</li></ul><p><strong>RSJ</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005211538258.png" alt="image-20231005211538258"></p><h2><span id="3-分类算法">3 分类算法</span></h2><h3><span id="31-knn分类">3.1 KNN分类</span></h3><h3><span id="32-贝叶斯分类">3.2 贝叶斯分类</span></h3><p>分类思想是使用贝叶斯公式，验证先验概率和类比的条件概率来估计文档d对类别ci的后验概率，以此实现对文档d的类别归属判断。</p><p>贝叶斯公式：</p><script type="math/tex; mode=display">\text{P(B|A) = }\frac{\text{P}(A\and B)}{P(A)}=\frac{\text{P}(A| B)P(B)}{P(A)}</script><ul><li><p>设各个类别的集合为$\{c_1,c_2,\cdots,c_n\}$</p></li><li><p>设E为实例的描述</p></li><li><p>确定E的类别</p><ul><li><script type="math/tex; mode=display">P(c_i|E)=\frac{P(c_i)P(E|c_i)}{P(E)}</script></li></ul></li><li><p>$P(E)$可以根据下式确定</p><ul><li><script type="math/tex; mode=display">\sum^{n}_{i=1}P(c_i|E)=\sum^{n}_{i=1}\frac{P(c_i)P(E|c_i)}{P(E)}=1</script></li><li><script type="math/tex; mode=display">P(E) =\sum^{n}_{i=1}{P(c_i)P(E|c_i)}</script></li></ul></li><li><p>需要知道</p><ul><li>先验概率</li><li>条件概率</li></ul></li><li>先验概率易从数据中获取<ul><li>如果文档集合D中，属于$c_i$的样例数为$n_i$</li><li>则有 $P(c_i)=n_i/|D|$</li></ul></li></ul><h4><span id="朴素的贝叶斯分类">朴素的贝叶斯分类</span></h4><ul><li><p>如果假定样例的特征是独立的，可以写为</p><ul><li><script type="math/tex; mode=display">P(E|c_i)=P(e_1\and e_2 \and \cdots \and e_m|c_i) = \Pi ^ {m}_{j=1}P(e_j|c_i)</script></li><li><p>这样只需要知道每个特征和类别的$P(e_j|c_i)$</p></li><li><p>如果只计算单个特征的分布，大大减少了计算量</p></li></ul></li></ul><h3><span id="33-svm分类">3.3 SVM分类</span></h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络内容安全第五周学习日志</title>
      <link href="/2023/10/05/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/05/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>文本挖掘——文本预处理</p><span id="more"></span><h1><span id="文本挖掘文本预处理">文本挖掘——文本预处理</span></h1><h2><span id="1-文本挖掘的背景">1 文本挖掘的背景</span></h2><p>文本挖掘与数据挖掘的区别：</p><p>文本挖掘主要针对的是非结构话或半结构化的无确定形式且缺乏机器可理解的语义；</p><p>数据挖掘主要针对的是数据库中结构化的数据，并利用关系表等存储结构来发现知识。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005065448006.png" alt="image-20231005065448006"></p><h2><span id="2-分词">2 分词</span></h2><p><strong>文本特征预处理</strong></p><p>定义：文本特征指的是关于文本的元数据</p><p>分类：</p><ul><li>描述性特征：文本的名称、日期、大小、类型等</li><li>语义性特征：文本的作者、标题、机构、内容等</li></ul><p><strong>特征抽取</strong></p><ul><li>预处理<ul><li>洗掉html的tag标签</li><li>stop words 去除， 词根还原</li><li>中文的分词、词性标注、短语识别</li><li>词频统计 <ul><li>$TF_{i,j}$特征i在文档j中出现次数，词频</li><li>$DF_i$所有文档集合中出现特征i的文档数目，文档频率</li></ul></li></ul></li><li>文本表示：向量空间模型</li><li>降维技术<ul><li>特征选择</li><li>特征重构</li></ul></li></ul><p><strong>中文特征词的粒度</strong></p><ul><li>Character： 字</li><li>Word： 词</li><li>Phrase： 短语</li><li>Concept： 概念</li><li>N-gram： N元组</li><li>某种规律性模式</li></ul><p><strong>词语标记</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005072521009.png" alt="image-20231005072521009"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005073346665.png" alt="image-20231005073346665"></p><p><strong>词语标记算法</strong></p><ul><li>输入：一段文本</li><li>输出：单词串</li><li>算法：<ol><li>对一个待分析的字符串S，从左到右进行扫描，读入当前字符(char)到候选词数组(w[i])，并将指针前移, i++</li><li>看char是否为词分隔符</li><li>T: if W is not space, 将W从起始位置到i-1位置的字符作为一个词汇单位输出，同时将S中的W部分删去，清空W，转1；如果char是词分隔符，且W是空格，将S中W部分删去，清空W，转1</li><li>F：看指针是否已经知道字符流尾部</li><li>T：将当前W从起始位置到i-1位置的字符作为一个词汇输出</li><li>F：转1</li></ol></li></ul><p><strong>词性还原</strong></p><p>屈折型语言词与变化形式：</p><ul><li>屈折变化 take -&gt; took -&gt; takes</li><li>派生变化 happy -&gt; happily</li><li>复合变化 6-year-old</li></ul><p>词性还原的目的：将上述变化还原</p><p>常见问题：</p><ul><li>半规则变化 flied -&gt; fly + ~ed</li><li>不规则变化 good -&gt; better</li><li>歧义现象 better -&gt; good + ~er or well + ~er</li></ul><p>所需知识库</p><ul><li>词典 Dict</li><li>前缀表 PrefixList</li><li>后缀表 SuffixList</li><li>有关屈折词尾变形的规则 Rules</li></ul><p>算法：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005090409133.png" alt="image-20231005090409133"></p><p>词性还原做到的程度：</p><ul><li>词干层： Impossibilities -&gt; impossibility + ies</li><li>词根层： impossibilities -&gt; im + poss + ibil + it + ies</li><li>分析成都取决与自然语言处理系统的深度<ul><li>不解决未登录词，分析到词干层</li><li>解决未登录词，分析到 词根层</li></ul></li></ul><p>汉语词法分析面临的问题：</p><ul><li>叠词、离合词、词缀<ul><li>恶心心</li><li>游泳：游了一会泳</li><li></li></ul></li><li>词语的切分歧义<ul><li>交集型歧义： 有|意见、有意|见</li><li>组合型歧义：马上、 马|上</li><li>混合型歧义：人|才能、人才|能、人|才|能</li><li></li></ul></li><li>未登录词</li></ul><p>伪歧义：歧义字段单独拿出来看有歧义，但在真实语境中仅有一种切分形式可接受。</p><p><strong>汉语分词</strong></p><p>分词的基本方法</p><ul><li>最大匹配法<ul><li>正向最大匹配法<ul><li>左至右，最长词</li></ul></li><li>逆向最大匹配法<ul><li>右至左，最长词</li></ul></li><li>双向最大匹配法<ul><li>依次正向反向，一致输出，不然采用其他方法排岐</li></ul></li><li>能发现部分交集型歧义，无法发现组合型歧义</li></ul></li><li>概率方法<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005104754401.png" alt="image-20231005104754401"></li><li>提高计算效率：根据最佳左邻词判断</li></ul></li></ul><h2><span id="3-文档模型">3 文档模型</span></h2><h3><span id="31-布尔模型">3.1 布尔模型</span></h3><p>每个词在一篇文档中是否出现，对应权值为0或1</p><h3><span id="32-词袋模型">3.2 词袋模型</span></h3><p><strong>N-gram语法模型</strong></p><p>N表示n个词语，n元语法模型通过n个词语的概率判断句子的结构。</p><p>算法思想：</p><p>将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度是N的字节片段序列。每个字节片段称为gram。对所有gram的出现频度进行统计，并且按照实现设定好的阈值进行过滤，形成关键gram列表，也就是文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。</p><p>基于马尔科夫假设，即每个词的出现只与前一个词有关，而与其他词不相关。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005110948948.png" alt="image-20231005110948948"></p><p>计算句子出现的概率时为了使首次有意义，加入一个或多个起始符$w_0=<bos>$同理句尾加入$<eos>$</eos></bos></p><h3><span id="33-向量空间模型-vsm">3.3 向量空间模型 VSM</span></h3><p>将文档表达为一个矢量，看作向量空间中的一个点。</p><p>权重计算方法：</p><ul><li>布尔权重</li><li>TFIDF型权重<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005111333178.png" alt="image-20231005111333178"></li></ul></li><li>基于熵概念的权重<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005111407480.png" alt="image-20231005111407480"></li></ul></li></ul><h2><span id="4-文档相似度计算">4 文档相似度计算</span></h2><p>查询与文档之间的相关性</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005111615655.png" alt="image-20231005111615655"></p><p>基于VSM的相关度计算方法</p><ul><li>欧氏距离</li><li>向量内积</li><li>向量夹角余弦</li></ul><p>文本序列：</p><p><strong>序列比较</strong>：</p><ol><li>两条长度相近的序列相似找出序列的差别</li><li>一条序列是否包含另一条序列</li><li>两条序列中是否有非常相同的子序列</li><li>一条序列与另一条序列逆序相似</li></ol><p>相似度：它是两个序列的函数，其值越大，表示两个序列越相似</p><p>距离：距离越大，两个序列的相似度越小</p><p><strong>编辑距离</strong>：</p><p>用来计算从原串转换到目标串所需要的最少的插入，删除和替换的数目</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淑芬第五周学习日志</title>
      <link href="/2023/10/04/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/04/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>第三章 函数极限与连续</p><span id="more"></span><h1><span id="第三章-函数极限与连续">第三章 函数极限与连续</span></h1><h2><span id="1-函数极限的定义与基本性质">1 函数极限的定义与基本性质</span></h2><h3><span id="函数极限定义">函数极限定义</span></h3><h4><span id="函数极限存在定义">函数极限存在定义</span></h4><script type="math/tex; mode=display">U(x_0;\delta)=\{x| \ |x-x_0|<\delta \} \\U^0(x_0;\delta)=\{x| \ 0 < |x-x_0|<\delta \} \\</script><p>设$f(x)$定义在$U^0(x_0;\delta’),L$为一个实数，$\forall \epsilon&gt;0, \exists \delta(x)&lt;\delta’, 当0&lt;|x-x_0|&lt;\delta, 有|f(x)-L|&lt;\epsilon$</p><p>称$x\rightarrow x_0$时，$f(x)$以$L$为极限，记为$\lim_{x\rightarrow x_0}f(x) = L$</p><p>用符号语言表述为$\forall \epsilon&gt;0,\exists \delta(\epsilon)&gt;0,0 &lt; |x-x_0| &lt; \delta, |f(x)-L|&lt;\epsilon$</p><ol><li>$f(x)$在$x_0$可以无定义（毕竟是去心邻域</li><li>函数极限为局部性质，<strong>仅和$x_0$附近取值有关</strong></li><li>$\delta(x)$随着$\epsilon$变化而变化</li></ol><h4><span id="函数极限不存在定义">函数极限不存在定义</span></h4><p>$\lim_{x\rightarrow x_0}f(x) \neq L$定义：</p><ul><li>$\exists \epsilon_0&gt;0,\forall \delta(\epsilon_0)&gt;0,\exists x’,0 &lt; |x’-x_0| &lt; \delta, |f(x’)-L|\geq \epsilon$</li></ul><p>$\lim_{x\rightarrow x_0}f(x)$不存在定义：</p><ul><li>$\forall L\in R,\exists \epsilon_0&gt;0,\forall \delta(\epsilon_0)&gt;0,\exists x’,0 &lt; |x’-x_0| &lt; \delta, |f(x’)-L|\geq \epsilon$</li></ul><blockquote><p>注意如果要证明不存在的时候这个 $\forall L \in R$</p></blockquote><h3><span id="函数极限基本性质">函数极限基本性质</span></h3><h4><span id="性质1">性质1</span></h4><p>若$\lim_{x\rightarrow x_0}f(x)$存在则极限唯一。</p><h4><span id="性质2-局部有界性">性质2 局部有界性</span></h4><p>$f(x)$定义在$U^0(x_0;\delta_1)$且$\lim_{x\rightarrow x_0}f(x) = A$，则存在邻域$U^0(x_0;\delta) \subset U^0(x_0;\delta_1),s.t. f(x)$在$U^0(x_0;\delta)$内有界</p><h4><span id="性质3-局部保序性">性质3 局部保序性</span></h4><p>设$\lim_{x\rightarrow x_0}f(x)=A,\lim_{x\rightarrow x_0}g(x)=B$则：</p><ol><li>若$A&gt;B,\exists\delta&gt;0, x\in U^0(x_0;\delta)$时$f(x)&gt;g(x)$</li><li>若$\exists\delta&gt;0,x\in U^0(x_0;\delta)$时，$f(x)\geq g(x)$，则$A\geq B$</li><li>$\lim_{x\rightarrow x_0}f(x) = A&gt;0$，则$\exists \delta&gt;0, x\in U^0(x_0;\delta):f(x)&gt;0 $</li></ol><h2><span id="2-函数极限的四则运算与夹逼定理">2 函数极限的四则运算与夹逼定理</span></h2><h3><span id="极限的四则运算性质">极限的四则运算性质</span></h3><p>设$f(x),g(x)$定义在$U^0(x_0;\delta),\lim_{x\rightarrow x_0}f(x)=A,\lim_{x\rightarrow x_0}g(x)=B$，则</p><ol><li>$\lim_{x\rightarrow x_0}[f(x) \pm g(x)] = A\pm B$</li><li>$\lim_{x\rightarrow x_0}[f(x)\cdot g(x)] = A\cdot B$</li><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)} = \frac{A}{B}$，其中$B\neq 0$</li></ol><h3><span id="夹逼定理">夹逼定理</span></h3><p>如果当$x \in U^0(x_0;\delta)$时，满足：</p><ol><li>$g(x)\leq f(x)\leq h(x)$</li><li>$\lim_{x\rightarrow x_0}g(x)=A,\lim_{x\rightarrow x_0}h(x)=A$</li></ol><p>那么$\lim_{x\rightarrow x_0}f(x)=A$</p><h2><span id="3-复合函数的极限">3 复合函数的极限</span></h2><h4><span id="定理">定理</span></h4><p>设$\lim_{x\rightarrow x_0}f(x)=A,\lim_{t\rightarrow t_0}g(t)=x_0$且$U^0(t_0;\delta_1)$内$g(t)\neq x_0$，则$\lim_{t\rightarrow t_0}f(g(t))=\lim_{x\rightarrow x_0}f(x)=A$</p><ul><li>如果$f(x)$在$x=x_0$没有定义，$U^0(t_0;\delta_1)$内$g(t)\neq x_0$不能少，否则复合函数$f(g(t))$没有意义</li></ul><h3><span id="应用">应用</span></h3><p>$\lim_{x\rightarrow 0}\frac{\sin x}{x}=1$</p><hr><h2><span id="典型例题">典型例题</span></h2><h3><span id="1-有理函数极限">1 有理函数极限</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231015174735098.png" alt="image-20231015174735098"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231015174857086.png" alt="image-20231015174857086"></p><hr><h2><span id="4-海涅与柯西定理">4 海涅与柯西定理</span></h2><h3><span id="海涅定理">海涅定理</span></h3><p>设$f(x)$定义在$U^0(x_0;\delta_1)$，则$\lim_{x\rightarrow x_0}f(x)=A$的充分必要条件是$\forall \{x_n\}\subset U^o(x_0;\delta_1),\lim_{n\rightarrow\infty}x_n=x_0$都有$\lim_{n\rightarrow \infty}f(x_n)=A$</p><p>海涅原理建立了数列极限与函数极限的关系</p><p>则推出极限不存在的情况：</p><ol><li>挑出了两个数列的极限存在且不等</li><li>挑出了一个极限不存在的数列</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231015201141080.png" alt="image-20231015201141080"></p><h3><span id="柯西定理">柯西定理</span></h3><p>$f(x)$定义在$U^o(x_0;\delta^*),\lim_{x\rightarrow x_0}f(x)$存在的充要条件是：</p><p>$\forall \epsilon&gt;0,\forall x_1,x_2\in U^o(x_0;\delta^*),0&lt;|x_1-x_0|&lt;\delta,0&lt;|x_2-x_0|&lt;\delta:|f(x_1)-f(x_2)|&lt;\epsilon$</p><h2><span id="5-函数极限其他形式与结论">5 函数极限其他形式与结论</span></h2><h3><span id="6类函数极限">6类函数极限</span></h3><ol><li>$\lim_{x\rightarrow x_0}f(x)$</li><li>$\lim_{x\rightarrow x_0^-}f(x)$</li><li>$\lim_{x\rightarrow x_0^+}f(x)$</li><li>$\lim_{x\rightarrow -\infty}f(x)$</li><li>$\lim_{x\rightarrow +\infty}f(x)$</li><li>$\lim_{x\rightarrow \infty}f(x)$<ul><li>满足：局部有界性、局部保序性、复合函数极限、四则运算、夹逼定理、海涅原理、柯西定理</li></ul></li></ol><h4><span id="定义1-自变量趋于正无穷时函数极限的定义">定义1 自变量趋于正无穷时函数极限的定义</span></h4><p>设$f(x)$定义在$[a,+\infty)$，$A$为给定的数，若$\forall \epsilon &gt; 0,\exists M &gt; a, \forall x&gt;M: |f(x)-A|&lt;\epsilon$，则称当$x\rightarrow +\infty$时$f(x)$极限为$A$</p><h4><span id="定义2-自变量趋于负无穷时函数极限的定义">定义2 自变量趋于负无穷时函数极限的定义</span></h4><p>设$f(x)$定义在$(-\infty,a]$，$A$为给定的数，若$\forall \epsilon &gt; 0,\exists M &gt; a, \forall x&lt;-M: |f(x)-A|&lt;\epsilon$，则称当$x\rightarrow -\infty$时$f(x)$极限为$A$</p><h4><span id="定义3-自变量趋于正无穷时函数极限的定义">定义3 自变量趋于正无穷时函数极限的定义</span></h4><p>设$f(x)$定义在$(-\infty,+\infty)$，$A$为给定的数，若$\forall \epsilon &gt; 0,\exists M &gt; a, \forall |x|&gt;M: |f(x)-A|&lt;\epsilon$，则称当$x\rightarrow \infty$时$f(x)$极限为$A$</p><p>注：$\lim_{x\rightarrow \infty}f(x)=A \Leftrightarrow \lim_{x\rightarrow-\infty}f(x)=\lim_{x\rightarrow+\infty}f(x)=A$</p><h4><span id="定义-水平渐近线">定义 水平渐近线</span></h4><p>直线 $y=L$称为曲线 $y=f(x)$的水平渐近线，如果 $\lim_{x\rightarrow \infty}f(x)=L$或 $\lim_{x\rightarrow -\infty}f(x)=L$或 $\lim_{x\rightarrow +\infty}f(x)=L$</p><p>注意一个曲线的渐近线不一定只有一条</p><h4><span id="定义-斜渐近线">定义 斜渐近线</span></h4><p>直线 $y=ax+b$称为$y=f(x)$的斜渐近线，如果条件至少有一个满足：</p><p>$\lim_{x\rightarrow \infty}f(x)-ax-b=0, \lim_{x\rightarrow +\infty}f(x)-ax-b=0,\lim_{x\rightarrow +\infty}f(x)-ax-b=0$ </p><hr><h2><span id="典型例题">典型例题</span></h2><h3><span id="例1-proof-lim_xrightarrowinfty1frac1xxe">例1： $proof: \lim_{x\rightarrow\infty}(1+\frac{1}{x})^x=e$</span></h3><p>基于 $\lim_{n\rightarrow+\infty}(1+\frac{1}{n})^n =e$，夹逼定理</p><p>分别对 $x&gt;0,x&lt;0$展开讨论</p><h3><span id="例2lim_xrightarrow-0fracln1xxlim_xrightarrow-0ln1xfrac1xlnlim_xrightarrow-01xfrac1xln-e-1">例2：$\lim_{x\rightarrow 0}\frac{\ln(1+x)}{x}=\lim_{x\rightarrow 0}\ln(1+x)^{\frac{1}{x}}=\ln(\lim_{x\rightarrow 0}(1+x)^{\frac{1}{x}})=\ln e = 1$</span></h3><p>利用 $\ln x$的连续性</p><h3><span id="例3-lim_xrightarrow-0fracax-1xln-a">例3： $\lim_{x\rightarrow 0}\frac{a^x-1}{x}=\ln a$</span></h3><p> <img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022094535617.png" alt="image-20231022094535617"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022094917896.png" alt="image-20231022094917896"></p><p> <img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022095211102.png" alt="image-20231022095211102"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022100135500.png" alt="image-20231022100135500"></p><h3><span id="幂指函数的极限">幂指函数的极限</span></h3><p>$\lim u(x)^{v(x)} $，其中$u(x)&gt;0$</p><ol><li>$\lim u(x) &gt; 0, \lim v(x)$存在：$\lim u(x)^{v(x)}=\lim u(x)^{\lim v(x)}$</li><li>$u,v$连续时，$u^v$也连续，$u(x_0)&gt;0$：$\lim u(x_0)^{v(x_0)}$</li><li>$1^\infty$型：$u^v=((1+(u-1))^{\frac{1}{u-1}})^{v(u-1)}$<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022105126192.png" alt="image-20231022105126192"></li></ul></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022105849842.png" alt="image-20231022105849842"></li></ol><h2><span id="6-连续函数">6 连续函数</span></h2><h3><span id="连续函数定义">连续函数定义</span></h3><h4><span id="函数连续定义">函数连续定义</span></h4><p>设$f:(a,b)\rightarrow R$，若对$x_0 \in (a,b), \lim_{x\rightarrow x_0}f(x)=f(x_0)$则称$f(x)$在$x_0$处连续；</p><p>$\forall \epsilon &gt; 0, \exists \delta &gt; 0, |x-x_0| &lt; \delta: |f(x)-f(x_0)|&lt;\epsilon$</p><h4><span id="函数左右连续定义">函数左右连续定义</span></h4><p>设$f:(a,b)\rightarrow R$，若$x_0 \in (a,b), \lim_{x\rightarrow x_0^-}f(x)=f(x_0)$则称左连续；</p><p>设$f:(a,b)\rightarrow R$，若$x_0 \in (a,b), \lim_{x\rightarrow x_0^+}f(x)=f(x_0)$则称右连续。</p><h5><span id="推论">推论：</span></h5><p>$f(x)$在$x_0$处连续 $\Leftrightarrow$既左连续又右连续</p><h4><span id="连续函数性质">连续函数性质</span></h4><p>设$f:(a,b)\rightarrow R$，若对$x_0 \in (a,b), \lim_{x\rightarrow x_0}f(x)=f(x_0)$，则有</p><ol><li>局部有界性：若$f(x)$在$x_0 \in (a,b)$连续，则存在$U(x_0;\delta)\subset (a,b), \ f(x)$在$U(x_0;\delta)$有界</li><li>局部保号性：若$f(x_0)$为正，则$f(x)$在附近时也为正（负亦然</li><li>四则运算性质：$f,g$连续，则四则运算后的也连续</li><li>复合函数连续<ul><li>复合函数连续性比极限少了$t_0$处取值的限制</li><li>复合连续函数的极限是可以换位置的</li></ul></li><li>反函数连续：设$f(x)$在区间$I$上单调递增的连续函数，则$f^{-1}$在$f(I)$上也严格单调递增</li></ol><h4><span id="区间连续定义">区间连续定义</span></h4><ol><li>$f(x)$在$(a,b)$上任一点连续，则在$(a,b)$连续</li><li>$f(x)$在$(a,b)$上任一点连续，且在$x=a,x=b$右左连续则在$[a,b]$连续</li></ol><h4><span id="初等函数的连续性">初等函数的连续性</span></h4><ol><li>三角函数及反三角函数在定义域内时连续的。</li><li>对数函数、幂函数、指数函数定义域内连续</li></ol><h3><span id="函数间断点分类">函数间断点分类</span></h3><h4><span id="第一类间断点">第一类间断点</span></h4><p>如果$f(x)$在点$x_0$处左右极限都存在，若</p><ol><li>$f(x_0 - 0) \neq f(x_0 + 0)$ 跳跃间断点</li><li>$f(x_0 - 0) = f(x_0 + 0) \neq f(x_0)$ 可去间断点</li></ol><h4><span id="第二类间断点">第二类间断点</span></h4><p>左右极限至少有一个不存在</p><h3><span id="利用函数连续性求极限">利用函数连续性求极限</span></h3><p>$f(x)$在$x_0$连续，那么$ \lim_{x\rightarrow x_0}f(x)=f(x_0)=f(\lim_{x\rightarrow x_0}x)$</p><p>连续函数：极限符号和函数符号可以交换次序</p><h2><span id="一致连续函数">一致连续函数</span></h2><h3><span id="函数一致连续定义">函数一致连续定义</span></h3><h4><span id="定义1-函数逐点连续">定义1 函数逐点连续</span></h4><p>设 $f:E\rightarrow R,\forall x_0\in E:\forall \epsilon&gt;0,\exists\delta(\epsilon,x_0)&gt;0,\forall x\in E,|x-x_0|&lt;\delta:|f(x)-f(x_0)|&lt;\epsilon$，则称函数在集合E逐点连续</p><h4><span id="定义2-函数一致连续">定义2 函数一致连续</span></h4><p>$\forall \epsilon&gt;0,\exists \delta(\epsilon)&gt;0, \forall x_1,x_2 \in E, |x_1-x_2| &lt;\delta: |f(x_1)-f(x_2)| &lt; \epsilon$$称f$在 $E$上一致连续</p><h4><span id="定义3-函数不一致连续">定义3 函数不一致连续</span></h4><p>$\exists \epsilon_0&gt;0,\forall \delta&gt;0, \exists x_1,x_2 \in E, |x_1-x_2| &lt;\delta: |f(x_1)-f(x_2)| \geq \epsilon_0$ </p><h3><span id="函数一致连续的判定定理">函数一致连续的判定定理</span></h3><h4><span id="判定定理">判定定理</span></h4><p>$f:E\rightarrow R$，$f$在 $E$上一致连续的充要条件是：$\forall \{x_n’\},\{x_n’’\}\in E,\lim_{n\rightarrow \infty}|x_n’-x_n’’|=0:\lim_{n\rightarrow\infty}(f(x_n’)-f(x_n’’))=0$</p><h4><span id="推论">推论</span></h4><p>$f:E\rightarrow R$，$f$在 $E$上不一致连续的充要条件是：</p><p>$\exists \{x_n’\},\{x_n’’\}\in E,\lim_{n\rightarrow \infty}|x_n’-x_n’’|=0:\lim_{n\rightarrow\infty}(f(x_n’)-f(x_n’’))\neq 0$</p><h2><span id="典型例题">典型例题</span></h2><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022212850358.png" alt="image-20231022212850358"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022213235479.png" alt="image-20231022213235479"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022213343691.png" alt="image-20231022213343691"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022213846161.png" alt="image-20231022213846161"></p><h2><span id="7-无穷小与无穷大阶的比较">7 无穷小与无穷大阶的比较</span></h2><h3><span id="1-无穷小阶的比较">1 无穷小阶的比较</span></h3><h4><span id="定义-无穷小阶的比较">定义 无穷小阶的比较</span></h4><p>设 $f(x),g(x)$定义在$U^o(x_0;\delta)$，当 $x\rightarrow x_0$时为无穷小</p><ol><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=0$，高阶无穷小</li><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=l\neq0$，同阶无穷小</li><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=1$，等价无穷小， $f\sim g(x\rightarrow x_0)$</li></ol><h3><span id="2-无穷大阶的比较">2 无穷大阶的比较</span></h3><h4><span id="定义-无穷小阶的量化">定义 无穷小阶的量化</span></h4><p>若 $\lim_{x\rightarrow x_0}\frac{f(x)}{(x-x_0)^k}=l\neq0$，$f$是 <code>k</code>阶无穷小</p><p>注：$x\rightarrow \infty,\pm\infty$，选 $g(x)=\frac{1}{x^k}$</p><h3><span id="3-无穷小和无穷大的运算性质">3 无穷小和无穷大的运算性质</span></h3><p>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=0 \Rightarrow f(x)=o(g(x))$</p><p>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=l\neq 0 \Rightarrow f(x)=O(g(x))$</p><p>$\lim_{x\rightarrow x_0}{f(x)}=0 \Rightarrow f(x)=o(1)$</p><p>$o(x^m)+o(x^n)=o(x^{min(m,n)})$</p><p>$o(x^m)o(x^n)=o(x^{m+n})$</p><p>$O(x^m)+O(x^n)=O(x^{min(m,n)})$</p><p>$O(x^m)O(x^n)=O(x^{m+n})$</p><h4><span id="等价代换定理">等价代换定理</span></h4><p>若$f(x),g(x),h(x)$在 $x_0$某邻域有定义 $f(x)\sim g(x) \ (x\rightarrow x_0)$</p><ol><li>$\lim_{x\rightarrow x_0}g(x)h(x)=a \Rightarrow \lim_{x\rightarrow x_0}f(x)h(x)=a$</li><li>$\lim_{x\rightarrow x_0}\frac{h(x)}{g(x)}=a \Rightarrow \lim_{x\rightarrow x_0}\frac{h(x)}{f(x)}=a$</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231022230405085.png" alt="image-20231022230405085"></p><h3><span id="无穷大阶的比较">无穷大阶的比较</span></h3><h4><span id="定义-无穷大">定义 无穷大</span></h4><p> 设 $f(x)$在 $U^o(x_0;\delta)$内有定义：</p><ol><li>$\forall M&gt;0, \exists \delta &gt; 0, 0&lt;|x-x_0|&lt;\delta:|f(x)|&gt;M$，则称 $f(x)$是 $x\rightarrow x_0$时的无穷大，记为 $\lim_{x\rightarrow x_0}{f(x)}=\infty$</li><li>正无穷</li><li>负无穷</li></ol><p>无界变量不一定是无穷大</p><h4><span id="定义-无穷大量阶的比较">定义 无穷大量阶的比较</span></h4><ol><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=0$，高阶无穷大</li><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=l\neq0$，同阶无穷大</li><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)}=1$，等价无穷大， $f\sim g(x\rightarrow x_0)$</li></ol><h4><span id="量化">量化</span></h4><p>若 $\lim_{x\rightarrow x_0}\frac{f(x)}{(x-x_0)^{-k}}=l\neq0$，$f$是 <code>k</code>阶无穷大</p><p>若是 $x\rightarrow \infty$，则 $\lim_{x\rightarrow \infty}\frac{f(x)}{x^{-k}}=l\neq0$</p><h2><span id="8-闭区间上连续函数的性质">8 闭区间上连续函数的性质</span></h2><h3><span id="1-一致连续性">1 一致连续性</span></h3><h4><span id="定理1-康托定理">定理1 康托定理</span></h4><p>若 $f(x) \in C[a,b]$，则 $f(x)$在 $[a,b]$上一致连续</p><p><strong>证明过程的理解：为什么一定得是有限闭区间</strong></p><h4><span id="推论1">推论1</span></h4><p>$f$在 $(a,b)$内一致连续，则 $f(a+0),f(b-0)$存在</p><h4><span id="推论2">推论2</span></h4><p>$f \in C(a,b) \  f(a+0),f(b-0)$存在，则$f$在 $(a,b)$一致连续</p><h4><span id="推论3">推论3</span></h4><p>$f(x)$在 $(a,b)$内一致连续 $\Leftrightarrow$ $f(x)$在 $(a,b)$连续，$f(a+0),f(b-0)$存在</p><h3><span id="2-有界性">2 有界性</span></h3><h4><span id="定理1">定理1</span></h4><p>若 $f\in C[a,b]$，则 $f$在 $[a,b]$上有界</p><h4><span id="推论">推论</span></h4><p>$f$在 $[a,b]$一致连续，$f(x)$在 $(a,b)$上有界</p><h4><span id="定理2">定理2</span></h4><p>$f\in C[a,b]$，则 $f$必能取到最大值和最小值 </p><h4><span id="定理3-零点定理">定理3 零点定理</span></h4><p>若 $f\in C[a,b], f(a)\cdot f(b)&lt;0$则$\exist \xi \in (a,b),s.t. f(\xi)=0$</p><h3><span id="3-最大值与最小值定理">3 最大值与最小值定理</span></h3><h3><span id="4-中值定理">4 中值定理</span></h3><p>假设函数 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/132e57acb643253e7810ee9702d9581f159a1c61" alt="f"> 在闭区间 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c4b788fc5c637e26ee98b45f89a5c08c85f7935" alt="[a,b]"> 连续且在开区间<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d7e5710198f33b00695903460983021e75860e2c" alt="(a,b)"> 可微，则存在一点<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f2232d55f873fb8712440c86bbc83574990b9b6" alt="{\displaystyle c,\,a&lt;c&lt;b}">，使得</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d2f0ffc5f9bd9ddb9e157bcc15fac0f8662f0b1" alt="{\displaystyle f&#39;(c)={\frac {f(b)-f(a)}{b-a}}}"></p><h3><span id="5-介值定理">5 介值定理</span></h3><h4><span id="定理4-介值定理">定理4 介值定理</span></h4><p>设 $f\in C[a,b],\lambda$是介于 $f(a),f(b)$之间的任意实数，则存在 $c\in(a,b),s.t.f(c)=\lambda$</p><h4><span id="推论">推论</span></h4><p>若 $f\in C[a,b]$，则 $f$能取到 $M,m$之间的任何值。$m=f(\xi),M=f(\eta)$</p><h4><span id="推论-广义介值定理">推论 广义介值定理</span></h4><p>$f\in C[a,b],x_1,x_2,\cdots,x_n\in[a,b], \forall \lambda_i\in R^+,\lambda_1+\lambda_2+\cdots+\lambda_n=1,$则存在一点$\eta \in[a,b],s.t. f(\eta)=\lambda_1f(x_1)+\cdots+\lambda_nf(x_n)$</p><h2><span id="附录">附录</span></h2><h3><span id="a-三角函数公式汇总">A. 三角函数公式汇总</span></h3><p><a href="https://zhuanlan.zhihu.com/p/390928056">考生必记：三角函数公式汇总+记忆（没有比这更全） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全协议第五周学习日志</title>
      <link href="/2023/10/04/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/04/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>电子商务安全</p><span id="more"></span><h1><span id="电子商务安全协议">电子商务安全协议</span></h1><h2><span id="1-电子商务协议简介">1 电子商务协议简介</span></h2><p>电子商务是客户 customer， 商家 merchant ，银行 bank 和为各方所信任的第三方认证机制 CA之间的信息流、资金流、物流的交互关系。个方式通过遍及全球的、开放的、不安全的Internet联系的。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006213550239.png" alt="image-20231006213550239"></p><p>安全隐患可以概括为三个方面：</p><ul><li>计算机系统安全<ul><li>硬件系统和软件系统的安全</li></ul></li><li>数据安全<ul><li>大量的商务数据</li></ul></li><li>交易安全<ul><li>交易在网上进行</li></ul></li></ul><p>可能存在的安全问题：</p><ul><li>假冒</li><li>交易抵赖</li><li>篡改信息</li><li>信息泄露<ul><li>盗取或解惑交易信息</li></ul></li></ul><p>参与者的安全需求：</p><ul><li>匿名性<ul><li>不可观察性：与该交易无关的参与者和系统之外的攻击者不能获取交易的有用信息</li><li>无关联性：任何人不能将支付者在交易时提交的信息关联起来。</li></ul></li><li>保密性</li><li>完整性<ul><li>信息传输和存储</li></ul></li><li>不可否认性</li><li>可认证性</li><li>有效性</li></ul><p>安全机制：</p><ul><li>数字签名技术</li><li>加密技术</li><li>数字时间戳技术</li><li>防火墙技术</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006222248094.png" alt="image-20231006222248094"></p><h2><span id="2-常见电子商务协议">2 常见电子商务协议</span></h2><h3><span id="ssl协议">SSL协议</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007082948816.png" alt="image-20231007082948816"></p><ol><li>接通阶段：用户通过登录电子商务网站，建立客户与服务器之间的连接</li><li>密码交换阶段</li><li>密码会谈阶段</li><li>检验阶段：检验密码的正确性</li><li>客户认证阶段：验证客户资料的真实性</li><li>结束阶段：客户与服务器之间开始传输数据</li></ol><p>记录协议为SSL连接提供两种服务：机密性和报文完整性</p><ol><li>机密性：SSL记录协议会协助双方产生一把共有的密钥，利用这把密钥来对SSL所传送的数据做传统式加密</li><li>消息完整性：SSL记录协议会协助双方产生另一把共有的密钥，利用这把密钥来计算出消息认证码</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007084217481.png" alt="image-20231007084217481"></p><ul><li>加密算法：DES、3DES】RC4、AES等加密算法</li><li>密钥交换：DH、RSA、ECDHE</li><li>Hash：MD5、SHA1</li></ul><p>合法性认证：握手阶段采用公钥技术进行数字认证</p><p>数据加密：采用对称密钥加密传输数据</p><p>完整性：hash</p><p>电子商务往往是用户、网站、银行三家协作完成，SSL协议并不能协调各方面的安全传输和信任关系；并且SSL不对应用层的数据进行签名，不支持完善的防抵赖功能</p><h3><span id="set协议">SET协议</span></h3><p>基于信用卡支付模式而设计的</p><p>SET协议是一个基于可信第三方认证中心的方案，基本原理时采用公钥密码体制和X.509数字证书标准，主要用于保障电子交易中支付过程和支付信息的机密性、商家和客户的合法的身份认证</p><p>核心技术：双重数字签名技术、安全数字证书技术、数字信封、数字时间戳等</p><h4><span id="系统结构">系统结构</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007085629410.png" alt="image-20231007085629410"></p><p><strong>支付网关</strong>: 银行与Internet之间专用系统，负责接收处理从商家传来的扣款信息，并通过专线送给银行；银行通过该系统将支付信息的处理结果反馈给商家</p><p><strong>收单银行</strong>：商家建立账户并处理支付卡认证和支付的金融机构</p><p><strong>发卡银行</strong>：负责为持卡人建立账户并发放支付卡的金融机构</p><h4><span id="交易流程">交易流程</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007090238071.png" alt="image-20231007090238071"></p><p>在保留对用户信用卡认证的前提下又增加了对商家身份的认证</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007090907988.png" alt="image-20231007090907988"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091009060.png" alt="image-20231007091009060"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091017878.png" alt="image-20231007091017878"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091028915.png" alt="image-20231007091028915"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091040960.png" alt="image-20231007091040960"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091050081.png" alt="image-20231007091050081"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091058476.png" alt="image-20231007091058476"></p><h4><span id="技术细节">技术细节</span></h4><p>双重数字签名技术：第5步，先签名后加密，再签名</p><p>数字时间戳：数字签名中加入时间戳服务</p><p>安全数字证书</p><p>数字信封：对称密码和非对称密码的串联</p><h4><span id="协议分析">协议分析</span></h4><p>满足原则：</p><ul><li>匿名性</li><li>机密性、完整性</li><li>不可否认性、身份认证</li></ul><p>复杂性：</p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007092447008.png" alt="image-20231007092447008"></li></ul><p>折中办法：用户和商家SSL、商家和银行SET</p><p>协议存在的问题：</p><ul><li>售后服务</li><li>数据处理</li><li>无法针对借记卡</li></ul><h2><span id="3-协议对比-set与ssl">3 协议对比： SET与SSL</span></h2><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007092800794.png" alt="image-20231007092800794"></p><h2><span id="4-其他电子商务协议">4 其他电子商务协议</span></h2><p>3-D Sercure协议</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 安全协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理与信息隐藏第四周学习日志</title>
      <link href="/2023/10/03/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/03/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="2-图像信息的基本知识">2 图像信息的基本知识</span></h1><h2><span id="22-图像数字化">2.2 图像数字化</span></h2><p>图像数字化：将代表图像的连续信号转变为离散信号</p><p><strong>采样</strong>：图像在空间上的离散化</p><p><strong>量化</strong>：对样点灰度值的离散化过程。</p><p>为了适应数字计算机的处理，必须对连续图像函数进行<strong>空间和幅值</strong>数字化</p><p><strong>均匀量化</strong>：将样本连续灰度值等间隔分层量化方式</p><p><strong>非均匀量化</strong>：不等间隔分层量化方式</p><p><strong>量化误差</strong>：以有限个离散值来近似表示无限多个连续值，量化器输出与输入之间必然存在误差</p><p>量化分层越多，量化误差越小，但编码时占用比特数越多</p><p>按人的视觉特点的非均匀量化</p><h2><span id="23-图像的噪声分析">2.3 图像的噪声分析</span></h2><h3><span id="231-噪声">2.3.1 噪声</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/噪声.png" alt="img1"></p><p>高斯噪声是应用最广的噪声模型</p><h3><span id="232-图像噪声的分类">2.3.2 图像噪声的分类</span></h3><p>根据噪声的产生原因</p><ul><li>外部噪声</li><li>内部噪声</li></ul><p>根据统计理论观点</p><ul><li>平稳噪声：不随时间变化</li><li>非平稳噪声：随</li></ul><p>根据噪声幅度分布</p><ul><li>高斯噪声</li><li>瑞利噪声</li><li>伽马噪声</li></ul><p>根据频谱形状</p><ul><li>白噪声：频谱均匀分布</li><li>1/f噪声：频谱与频率成分反比</li><li>三角噪声：与频率平方成正比的噪声</li></ul><p>根据噪声与图像的结合方式</p><ul><li>加性噪声：输出图像为S(t)+n(t)</li><li>乘性噪声：S(t)(1+n(t))</li></ul><p>为了分析处理方便，</p><ol><li>往往将乘性噪声近似认为是加性噪声</li><li>信号和噪声是互相统计独立的</li></ol><h2><span id="24-图像质量评价">2.4 图像质量评价</span></h2><h3><span id="241-概述">2.4.1 概述</span></h3><p>图像质量评价的主要方法：</p><ul><li>客观评价方法<ul><li>实现容易</li><li>可消除不确定行</li><li>不一定反应真实质量</li></ul></li><li>主观评价方法<ul><li>实现困难</li><li>受其他因素影响大</li><li>像评估的最终目标</li></ul></li></ul><h3><span id="242-图像质量的主观评价">2.4.2 图像质量的主观评价</span></h3><p>主观评价方法：</p><ol><li>由ITU制定了图像主观评价的标准</li><li>至少挑选10观察者</li><li>测试条件应尽可能与使用条件相匹配</li><li>调查</li><li>设计评分表</li><li>结果分析，MOS Mean Option Score， DMOS Differential Mean Option Score</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/DMOS.png" alt="img2"></p><p>DMOS值越大说明视频越好</p><p><strong>灰度图像的失真度量</strong></p><ol><li><p>归一化的均方误差</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/NMSE.png" alt="img3"></p></li><li><p>峰值均方误差</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/PMSE.png" alt="img4"></p></li><li><p>等效的峰值信噪比</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/PSNR.png" alt="img5"></p></li></ol><h3><span id="243-图像保真度的测量">2.4.3 图像保真度的测量</span></h3><p>保真度并与一定能够反应图像主观质量</p><p><strong>亮度的量度</strong></p><p>人的感觉亮度和亮度y基本称对数关系</p><script type="math/tex; mode=display">\Delta(L_1,L_2) = \log_B{(y+\Delta y)} - \log_B(y)</script><p><strong>彩色的量度</strong></p><p>人的彩色感觉：红、绿、蓝</p><ul><li>RGB模式：加式模式</li><li>CMYK模式：印刷彩色，减式模式，反射光</li></ul><h2><span id="25-彩色图像基本知识">2.5 彩色图像基本知识</span></h2><ol><li><p>YIQ</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/YIQ.png" alt="img6"></p></li><li><p>YUV</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/YUV.png" alt="img7"></p></li><li><p>YCbCr</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/YCbCr.png" alt="img8"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第四周学习日志</title>
      <link href="/2023/09/30/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/30/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>数据库第二章关系数据库</p><span id="more"></span><h1><span id="第二章-关系数据库">第二章 关系数据库</span></h1><h2><span id="21-关系数据结构及形式化定义">2.1 关系数据结构及形式化定义</span></h2><h3><span id="211-关系">2.1.1 关系</span></h3><p>单一的数据结构——关系</p><ul><li><p>现实世界的<strong>实体以及实体间的各种联系</strong>均用关系来表示</p></li><li><p>关系的组成：同一类实体型的实例集合</p></li><li><p>关系之间的联系：实体与实体之间、实体的属性之间存在某种关联关系</p></li></ul><p>逻辑结构——二维表表头（关系模式）</p><ul><li>从用户角度，关系模型中数据的逻辑结构是一张二维表的表头，描述表的组成关系</li></ul><p>建立在集合论和关系代数的基础上</p><h4><span id="1-域-domain">1. 域 Domain</span></h4><p>域是一组具有<strong>相同数据类型</strong>的<strong>值的集合</strong></p><ul><li>值的集合是有限、且不重复</li><li>集合中的元素不重复</li><li>同一数据类型</li></ul><h4><span id="2-笛卡尔积-cartesian-product">2. 笛卡尔积 Cartesian Product</span></h4><p>给定一组域$D_1,D_2,\cdots,D_n$，允许其中某些域是相同的</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005214516139.png" alt="image-20231005214516139"></p><ul><li>所有域的所有取值的一个组合</li><li>组合结果不允许重复</li></ul><p>元组 Tuple</p><ul><li>笛卡尔积中的每一个元素叫做一个元组</li></ul><p>分量 Component</p><ul><li>笛卡尔积元素中每一个值di叫做一个分量</li></ul><p>基数 Cardinal number</p><ul><li>集合中包含的元素个数</li></ul><p>笛卡尔积表示方法</p><ul><li>表示为一张二维表</li><li>每行对应一个元组，每列对应一个域</li></ul><h4><span id="3-关系-relation">3. 关系 Relation</span></h4><h5><span id="1-关系">1 关系</span></h5><p>$D_1 \times D_2 \times \cdots \times D_n$的子集叫做在域$D_1,D_2,\cdots,D_n$上的关系，表示为$R(D_1,D_2,\cdots,D_n)$</p><ul><li>R：关系名</li><li>n：关系的目或度</li></ul><h5><span id="2-元组">2 元组</span></h5><p>关系中的每个元素是关系中的元组，通常用t表示</p><h5><span id="3-单元关系与二元关系">3 单元关系与二元关系</span></h5><p>n=1单元；n=2二元</p><h5><span id="4-关系的表示">4 关系的表示</span></h5><p>关系是一个二维表，表的每行对应一个元组，每列对应一个域</p><h5><span id="5-属性">5 属性</span></h5><p>关系中不同列可以对应相同的域</p><p>每列必须有一个名字，称为属性</p><p>n目关系必有n个属性</p><h5><span id="6-码键">6 码/键</span></h5><ul><li>候选键/码 Candidate key<ul><li>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</li></ul></li><li>全码/键 All-key<ul><li>关系模式的所有属性组是这个关系模式的候选码，称为全码</li></ul></li></ul><p>在关系模型中，候选键或候选码是某个关系的一组属性所组成的集合，它需要同时满足以下两个条件</p><ol><li>这个属性集合始终能够确保在关系中能唯一标识元组</li><li>在这个属性集合中找不出真子集额能够满足条件1</li></ol><p>满足上面第一个条件的属性集合称为超键 Super Key， 我们也可以把候选键定义为最小超键，即不含有多余属性的超键。</p><p>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，他就不具有这样的性质了，这样的属性组称为候选码。</p><ul><li><p>主码/主键</p><ul><li>若一个关系有多个候选码，选定其中一个为主码</li><li>优先选择数字类型的候选键</li></ul></li><li><p>主属性</p><ul><li>候选码的诸属性称为主属性</li><li>不包含在任何候选码中的属性称为非主属性或非码属性</li></ul></li><li><p>外键</p><ul><li>一个实体的主键被另外一个实体使用，以表达不同实体元组之间的关系</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006090213940.png" alt="image-20231006090213940"></p></li></ul><p>实体之间的关系依赖主键——外键关联实现</p><p>关系数据库支持的实体间关系类型</p><ul><li>1对1：主键与外键相同，或者一个实体的主键作为另外一个实体的外键</li><li>一对多 或者多对一：一实体的主键作为多实体的外键</li></ul><p>多对多的实体关系存在如下问题：</p><ul><li>数据冗余</li><li>自底向上遍历可能会产生多个父节点，导致具体实例的父子关系难以区分</li></ul><p>主键外键区别</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006093514629.png" alt="image-20231006093514629"></p><h5><span id="7-三类关系">7 三类关系</span></h5><ol><li>基本关系 （基本表或基表）<ul><li>实际存在的表，是实际存储数据的逻辑表示</li></ul></li><li>查询表<ul><li>查询结果对应的表</li></ul></li><li>视图表<ul><li>由基本表或其他视图导出的表，虚表，不对应实际存储的数据</li></ul></li></ol><h5><span id="8-基本关系的性质">8 基本关系的性质</span></h5><ol><li>列是同质的：列中分量来自同一域</li><li>不同的列可出自同一个域</li><li>列的顺序无所谓，列的次序可以任意交换</li><li>任意两个元组的候选码不能相同，元组相同指的是两个元组的每个分量都相同</li><li>行的顺序无所谓，行的次序可以任意交换</li><li>分量必须取原子值</li></ol><h3><span id="212-关系模式">2.1.2 关系模式</span></h3><h4><span id="1-什么是关系模式">1 什么是关系模式</span></h4><ul><li>关系模式 Relation Schema 是型 Type，是结构</li><li>关系是值 （二维表</li><li>同一关系模式下，可以有很多关系</li><li>关系模式是关系的结构，关系是关系模式在某一时刻的数据</li><li>关系模式是稳定的，关系是随时间变化的</li><li>关系模式是对关系的描述<ul><li>元组集合的结构<ul><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映像关系</li></ul></li><li>完整性约束条件</li></ul></li></ul><h4><span id="2-定义关系模式">2 定义关系模式</span></h4><p>关系模式可以形式化地表示为：$R(U,D,DOM,F)$</p><ul><li>R - 关系名</li><li>U - 组成该关系的属性名集合</li><li>D - U中元素所来自的域</li><li>DOM - 属性向域的映像集合</li><li>F - 属性间数据的依赖关系的集合</li></ul><p>通常可以简记为 $R(U) \ or \ R(A_1,A_2, \cdots, A_n)$ (A是属性名)</p><h4><span id="3-关系模式与关系">3 关系模式与关系</span></h4><p>关系模式</p><ul><li>对关系结构的描述</li><li>静态的、稳定的</li></ul><p>关系</p><ul><li>关系模式在某一时刻的状态或内容</li><li>动态的、随时间不断变化的</li></ul><p>关系模式和关系往往统称为关系</p><h3><span id="213-关系数据库">2.1.3 关系数据库</span></h3><p>在一个给定应用领域中， 所有关系的集合构成一个关系数据库</p><p>关系数据库的型与值：</p><ul><li>型：关系数据库模式，是对关系数据库结构的描述</li><li>值：关系模式在某一时刻对应的关系的集合，通常称为关系数据库RDB</li></ul><h3><span id="214-关系模型的存储结构">2.1.4 关系模型的存储结构</span></h3><p>关系数据库的物理组织</p><ul><li>有的关系数据库管理系统一个表对应一个操作系统文件，将物理数据组织交给操作系统完成</li><li>有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理</li></ul><h2><span id="22-关系操作">2.2 关系操作</span></h2><h3><span id="221-基本的关系操作">2.2.1 基本的关系操作</span></h3><ul><li>查询操作 8种 5种基本<ul><li>选择、投影、链接、除、并、差、交、笛卡尔积</li><li>选择、投影、并、差、笛卡尔积 5种基本操作</li></ul></li><li>数据更新：插入、删除、修改</li></ul><p>关系操作的特点</p><ul><li>集合操作方式：操作的对象和结果都是集合，一次一集合的方式</li></ul><h3><span id="222-关系数据库语言的分类">2.2.2 关系数据库语言的分类</span></h3><p>关系代数语言</p><ul><li>用对关系的运算来表达查询要求，对关系代数表达式求值</li><li>ISBL  Information System Base Language</li></ul><p>关系演算语言：用谓词表达查询要求（选学</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006101847955.png" alt="image-20231006101847955"></p><p>具有关系代数和关系演算双重特点的语言：SQL</p><h2><span id="23-关系的完整性">2.3 关系的完整性</span></h2><p>关系的三类完整性约束：</p><ul><li>实体完整性和参照完整性<ul><li>关系模型必须满足的完整性约束条件，关系的两个不变性，应该由关系系统自动支持</li></ul></li><li>用户定义的完整性<ul><li>具体领域中的语义约束</li></ul></li></ul><h3><span id="231-实体完整性">2.3.1 实体完整性</span></h3><h4><span id="规则21-实体完整性规则-entity-integrity">规则2.1 实体完整性规则 Entity Integrity</span></h4><ul><li>若属性A是基本关系R的主属性，则A不能取空值</li><li>NULL：不知道、不存在、无意义的值<ul><li>有空值的时候需要特殊处理</li><li>不能参与算数、比较、逻辑运算</li></ul></li></ul><p>规则说明：</p><ul><li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，具有某种唯一性标识</li><li>关系模型中以主键作为唯一性标识</li><li>诸属性不能取空值</li></ul><h3><span id="232-参照完整性">2.3.2 参照完整性</span></h3><h4><span id="1-关系间的引用">1 关系间的引用</span></h4><h4><span id="2-外键码">2 外键/码</span></h4><p>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码$K_s$相对应,则称F是R的外码</p><p>基本关系R称为参照关系</p><p>基本关系S称为被参照关系或目标关系</p><p>关系R和S 不一定是不同的关系</p><p>目标关系S的主码和参照关系的外码必须定义在同一个域上</p><p>外码不一定要与对应的主码同名</p><h4><span id="3-参照完整性规则">3 参照完整性规则</span></h4><h5><span id="规则22-参照完整性规则">规则2.2 参照完整性规则</span></h5><p>若属性F是基本关系R的外码，F与基本关系S的主码$K_s$相对应,则对于R中的每个元组在F上的值必须为：</p><ul><li>或者等于S中某个元组的主码值$K_s$</li><li>或者取空值</li></ul><p>关系数据库不支持多对多联系——数据冗余少</p><h3><span id="233-用户定义的完整性">2.3.3 用户定义的完整性</span></h3><p>针对某一具体关系数据库的约束条件</p><ul><li>数据必须满足的语义要求</li></ul><p>关系模型应提供定义和检验这类完整性的机制</p><h2><span id="24-关系代数">2.4 关系代数</span></h2><p>关系代数是一种抽象的查询语言，它用关系运算表达查询</p><p>关系代数</p><ul><li>对象、结果均为关系</li><li>运算符有两类：集合运算符、专门的关系运算符</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006105723229.png" alt="image-20231006105723229"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006105744866.png" alt="image-20231006105744866"></p><h3><span id="241-传统的集合运算">2.4.1 传统的集合运算</span></h3><h4><span id="并-union">并 Union</span></h4><ul><li>R和S<ul><li>具有相同的目n即两个关系都有n个是个也许不该</li><li>相应的属性取自同一个域</li></ul></li><li>R $\cup$ S<ul><li>仍为n目关系，由属于R或属于S的元组组成</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006110424830.png" alt="image-20231006110424830"></li><li>结果不允许重复</li></ul></li></ul><h4><span id="差-difference">差 Difference</span></h4><ul><li>R and S<ul><li>具有相同的目n</li><li>相应的属性取自同一个域</li></ul></li><li>R - S<ul><li>仍为n目关系，由属于R但不属于S的元组组成</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006110608171.png" alt="image-20231006110608171"></li></ul></li><li>语义：是…但不含…</li></ul><h4><span id="交-intersection">交 Intersection</span></h4><ul><li>R and S<ul><li>具有相同的目n</li><li>相应的属性取自同一个域</li></ul></li><li>R $\cap$ S<ul><li>仍为n目关系，由属于R且属于S的元组组成</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006110737469.png" alt="image-20231006110737469"></li></ul></li></ul><h4><span id="笛卡尔积-cartesian-product">笛卡尔积 Cartesian Product</span></h4><p>元素是元组</p><ul><li>R：n目关系，$k_1$个元组</li><li>S：m目关系，$k_2$个元组</li><li>R $\times$ S<ul><li>列： (n+m)列</li><li>行：$k_1 \times k_2$个元组</li></ul></li></ul><h3><span id="242-专门的关系运算">2.4.2 专门的关系运算</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111238808.png" alt="image-20231006111238808"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111315271.png" alt="image-20231006111315271"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111325605.png" alt="image-20231006111325605"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111605603.png" alt="image-20231006111605603"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111853380.png" alt="image-20231006111853380"></p><h4><span id="1-选择">1 选择</span></h4><p>又称为限制或过滤</p><p>含义</p><ul><li>在关系R中选择满足给定条件的诸元组</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112403358.png" alt="image-20231006112403358"></li><li>F ：选择条件，逻辑表达式，取值为true or false<ul><li>基本形式为 X1 $\theta$ Y1</li><li>$\theta$ 为比较运算符，可以为$\le ,\ge,&gt; ,&lt; ,= or &lt;&gt;$</li></ul></li></ul><p>从行的角度的运算</p><p>优先次序：<img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112643180.png" alt="image-20231006112643180"></p><h4><span id="2-投影">2 投影</span></h4><p>从R中选择出若干属性列组成新关系</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112723318.png" alt="image-20231006112723318"></p><p>列的角度的运算</p><p>投影之后不仅取消了原关系中的某些列，还可能取消某些元组</p><h4><span id="3-连接">3 连接</span></h4><p>也成为$\theta$连接</p><ul><li>只是对单个关系进行操作，实际应用中涉及多个表的操作</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112845740.png" alt="image-20231006112845740"></p><ul><li>A和B：分别为R和S上度数相等界可比的属性组</li></ul><p>两种常用连接运算</p><ul><li><p>等值连接 $\theta$ 为 <code>=</code></p><ul><li>两个关系中比较的分量可以是不同的属性组</li></ul></li><li><p>自然连接 </p><ul><li>两个关系中进行比较的分量必须是相同的属性组</li><li>在结果中把重复的属性列去掉</li><li>含义<ul><li>R和S具有相同的属性组</li><li>U是R和S的全体属性集合</li></ul></li><li>同时从行与列的角度进行</li><li>操作步骤<ol><li>对两个表进行广义笛卡尔积</li><li>从广义笛卡尔积中选取在相同列上值相同的元组</li><li>去掉重复的列</li><li>根据需求做投影操作，得到最终结果</li></ol></li></ul></li></ul><p><strong>悬浮元组</strong></p><p>两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，被舍弃的元组称为悬浮元组。</p><p><strong>外连接</strong></p><p>如果把悬浮元组也保存在结果关系中，其他属性上填空值，就叫外连接</p><p>左外连接：</p><ul><li>只保留左边关系R的悬浮元组</li><li>以左边关系R为基准，右边关系S不匹配的元组为NULL</li></ul><p>右外连接相反。</p><p><code>外连接 = 自然连接 + 失配的元组</code></p><p>外连接形式：</p><ul><li>左外连接 = 自然连接 + 左侧表失配元组</li><li>右外连接 = 自然连接 + 右侧表失配元组</li><li>全外连接 = 自然连接 + 两侧表失配元组</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006152506295.png" alt="image-20231006152506295"></li></ul><h4><span id="4-除运算">4 除运算</span></h4><p>给定关系R(X, Y) S(Y, Z)，其中 X，Y，Z为属性组</p><p>R中的Y与S中的Y可以有不同的属性名，但是必须出自相同的域集。一般的有$\pi_y(S) \subseteq \pi_y(R)$成立，否则结果为空集。</p><p>R与S的除运算得到了一个新的关系P(X)，P时R中满足下列条件的元组在X上的投影：</p><ul><li>元组在X上分量值x的象集$Y_x$包含S在Y上投影的集合，记作：<img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006153143548.png" alt="image-20231006153143548"></li></ul><p>除操作是从行和列的角度进行的</p><p><strong>数学公式</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006153512116.png" alt="image-20231006153512116"></p><p>一般的有$\pi_x(S) \subseteq \pi_y(R)$成立</p><p>构造$S^{‘} = \pi_x(S) \times \pi_y(R)$</p><ul><li>用例子理解一下</li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006154328941.png" alt="image-20231006154328941"></p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006154135461.png" alt="image-20231006154135461"></p></li></ul><h2><span id="25-关系演算">2.5* 关系演算</span></h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全创新实验学习日志</title>
      <link href="/2023/09/29/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/29/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>MD5碰撞、CA-PKI建立教程、apache服务器建立教程</p><span id="more"></span><blockquote><p>目前来看网络安全创新实验中给出的例子还是很不错的，既能够初步明白怎么用，还能在具体的应用环境中实现。-20230929</p></blockquote><h1><span id="lab-2">Lab-2</span></h1><h2><span id="44-md5算法碰撞实验">4.4 MD5算法碰撞实验</span></h2><h3><span id="441-md5碰撞工具的使用">4.4.1 MD5碰撞工具的使用</span></h3><p>快速MD5碰撞生成工具来生成两个拥有相同MD5值的不同文件。这两个文件的开始部分是相同的。因此需要指定前缀：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Lab2/hashclash/ipc_workdir/</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;prefix&quot;</span> &gt; [prefix_file]</span><br><span class="line">../scripts/poc_no.sh [prefix_file]</span><br></pre></td></tr></table></figure><p>可以通过一下命令来验证文件是否内容不同而MD5值相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比较两个文件是否相同</span><br><span class="line">diff -q collision1.bin collision2.bin</span><br><span class="line">ghex -C collision1.bin</span><br><span class="line"><span class="built_in">md5sum</span> collision1.bin collision2.bin</span><br></pre></td></tr></table></figure><p>如果是64字节的倍数，则会正常处理；如果不是64的倍数，则会去除多余的部分。</p><h2><span id="442-md5特性探究">4.4.2 MD5特性探究</span></h2><p>两个相同MD5值的文件加上相同的后缀T会生成两个具有相同哈希值的文件。</p><blockquote><p>cat file1 file2 &gt; file3</p></blockquote><p>将两个文件合并到另一个文件</p><h2><span id="443-产生相同md5哈希值的两个可执行文件">4.4.3 产生相同MD5哈希值的两个可执行文件</span></h2><p>利用gcc编译文件的命令如下：</p><blockquote><p>gcc [input_file] -o [output_file]</p></blockquote><p>编译后的文件可以直接运行</p><blockquote><p>./program.out</p></blockquote><p>赋予执行权限</p><blockquote><p>chmod +x [file_name]</p></blockquote><p>验证是否满足要求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> program_col1.bin program_col2.bin</span><br><span class="line"><span class="built_in">echo</span> $(./program_col1.bin) | <span class="built_in">md5sum</span></span><br><span class="line"><span class="built_in">echo</span> $(./program_col2.bin) | <span class="built_in">md5sum</span></span><br></pre></td></tr></table></figure><p>接下来用head/tail命令来分割文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将a.out前3200byte输入到prefix文件中</span><br><span class="line"><span class="built_in">head</span> -c 3200 a.out &gt; prefix</span><br><span class="line">// a.out 后 100字节输入到suffix</span><br><span class="line"><span class="built_in">tail</span> -c 100 a.out &gt; suffix</span><br><span class="line">// a.out 从第3300字节开始至结尾的内容输入到suffix文件中</span><br><span class="line"><span class="built_in">tail</span> -c +3300 a.out &gt; suffix</span><br></pre></td></tr></table></figure><h1><span id="lab-3">Lab-3</span></h1><h2><span id="43-pki实验">4.3 PKI实验</span></h2><p>PKI利用CA将用户身份与公钥结合，解决公钥可信性问题。</p><p>CA是一个签发电子证书的可信实体。</p><h3><span id="431-建立ca">4.3.1 建立CA</span></h3><p>将<code>openssl</code>提供的配置文件<code>/usr/lib/ssl/openssl.cnf</code>拷贝进入目录，并且根据配置文件中的要求（[CA_default]）创建以下文件夹或文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir =./demoCA# dir, store all files</span><br><span class="line">certs=$dir/certs    # dir, store all certs</span><br><span class="line">crl_dir    =$dir/crl    # dir, store the list of revocation key list</span><br><span class="line">new_certs_dir    =$dir/newcerts #dir, store new certs</span><br><span class="line">database =$dir/index.txt  #file, the index file of database</span><br><span class="line">serial   =$dir/serial   #file, store relevant serial number</span><br></pre></td></tr></table></figure><p>其中，<code>index.txt</code>仅需创建一个空文件，<code>serial</code>文件创建后需要输入偶数位的16进制数字</p><p>之后CA先生成自签名证书，该证书证明CA是可信的，并称为根证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># openssl req生成自签名证书</span></span><br><span class="line">openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf</span><br><span class="line"><span class="comment"># -new 创建一个证书请求文件，若之后指定了-x509，代表创建自签名证书文件</span></span><br><span class="line"><span class="comment"># -keyout [file]  指定自动创建私钥时私钥的输出文件</span></span><br><span class="line"><span class="comment"># -out [file] 指定证书请求或自签名证书的输出文件</span></span><br><span class="line"><span class="comment"># config [file]  指定req命令的配置文件</span></span><br></pre></td></tr></table></figure><blockquote><p>自签名 SSL 证书是一种数字证书，未经公开信任的证书颁发机构 (CA) 签名。自签名证书被认为不同于传统的 CA 签名证书，因为它们是由负责与证书关联的网站或软件的公司或开发人员创建、颁发和签名的，而不是 CA。</p><p>在高层次上，这些自签名证书基于与 X.509 证书中使用的相同的加密私钥和公钥对体系结构。但是，这些数字证书没有受信任的第三方 CA 的验证。发行过程中缺乏独立验证会产生额外的风险，这就是自签名证书的问题。对于面向公众的网站和应用程序，它们被认为是不安全的。</p></blockquote><p>可以用 <code>openssl x509 -noout -text -in ca.crt</code>来查看证书信息</p><h3><span id="432-利用ca签发证书">4.3.2 利用CA签发证书</span></h3><p>网站PKILab.com，需要从CA处取得电子证书：</p><p>首先，生成自己的公私钥对 <code>openssl genrsa -aes128 -out server.key 2048</code></p><p>生成公私钥对后，同时将私钥用AES128加密存储在<code>server.key</code>文件中。</p><p>通过 <code>openssl rsa -in server.key -text</code>查看密钥信息</p><p>其次，PKILab.com需要生成证书请求文件（CSR）。该文件包含了PKILab.com的公钥，并被发送给CA，请求CA对公钥进行签名：</p><p><code>openssl req -new -key server.key -out server.csr -config openssl.cnf</code></p><p>CA收到csr请求文件后，利用自己的私钥ca.key与证书ca.crt，签名并生成server.crt:</p><p><code>openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -config openssl.cnf</code></p><h3><span id="433-验证ca签发证书的签名">4.3.3 验证CA签发证书的签名</span></h3><p>证书文件分为三部分，Data域、Signature Algorithm域、Signature Value域，Date域为证书的基本信息部分，也称作TBSCertificate（To-Be-Signed Certificate）。</p><p>寻找TBSCertificate位置的指令：<code>openssl x509 -in server.crt -inform pem -outform pem -out server.pem</code></p><p>以ASN.1格式解析PEM文件：<code>openssl asn1parse -i -in server.pem</code></p><p>根据解析信息提取TBSCertificate，保存为<code>server.tbs</code>文件：<code>openssl asn1parse -in server.pem -strparse 5 -out server.tbs</code></p><h3><span id="434-将证书用于https-web服务器">4.3.4 将证书用于HTTPS Web服务器</span></h3><p>首先，配置DNS服务。为了让虚拟机能够解析该域名，需要将<code>127.0.0.1 PKILab.com</code>填入虚拟机<code>/etc/hosts</code>文件中。</p><p>然后，基于之前生成的证书，使用指令建立一个Web简单服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将密钥与证书合成为一个文件</span><br><span class="line"><span class="built_in">cp</span> server.key server.pem</span><br><span class="line"><span class="built_in">cat</span> server.crt &gt;&gt; server.pem</span><br><span class="line">//直接将crt拼接到pem后面</span><br><span class="line">// 利用 server.pem 建立一个Web服务器</span><br><span class="line">openssl s_server -cert server.pem -www</span><br></pre></td></tr></table></figure><h1><span id="homework-1">Homework-1</span></h1><h2><span id="11-产生两个程序行为不同的可执行文件">1.1 产生两个程序行为不同的可执行文件</span></h2><h2><span id="12-建立基于apache的https网站">1.2-建立基于Apache的HTTPS网站</span></h2><p>首先需要修改Apache配置文件，<strong>指定网站文件以及网站密钥与证书的存储位置。</strong></p><p>举个栗子~</p><p>要建立一个<code>example.com</code>的网站，需要在<code>/var/www</code>文件夹中新建一个名为<code>example</code>的文件夹，并在其中新建一个<code>index_https.html</code>。</p><p>之后就到了<strong>修改配置文件</strong><code>/etc/apache2/sites-available/&lt;your web&gt;.conf</code>的时候了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:<span class="number">443</span>&gt;</span><br><span class="line"># *表示该配置适用与所有IP与<span class="number">443</span>端口的请求</span><br><span class="line"> ServerName example.com   </span><br><span class="line"> DocumentRoot /var/www/example</span><br><span class="line"> DirectoryIndex index_https.html</span><br><span class="line"></span><br><span class="line"> SSLEngine on</span><br><span class="line"> SSLCertificateFile   <span class="meta"># input the absolute path of the cert of your website </span></span><br><span class="line"> SSLCertificateKeyFile  <span class="meta"># input the absolute path of the key of your website</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">SSLCipherSuite AES256-SHA # 指定加密组件</span><br></pre></td></tr></table></figure><blockquote><p> 至于网站证书应该如何生成以及密钥文件应该如何生成，请看Lab-3</p><p>AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1. Set the ‘ServerName’ directive globally to suppress this message<br>解决方案：</p><p>在/etc/apache2/apache2.cnf中添加</p><p>ServerName  your_server_name</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apachectl configtest</span><br><span class="line">sudo a2enmod ssl</span><br><span class="line">sudo a2ensite default-ssl</span><br><span class="line">sudo service apache2 start 或者 sudo service apache2 restart</span><br></pre></td></tr></table></figure><h1><span id="lab-5">Lab 5</span></h1><h2><span id="实验原理">实验原理</span></h2><h3><span id="31-路由追踪">3.1 路由追踪</span></h3><p>用于获取一个网络数据包从源地址到目的地址的路径信息。</p><blockquote><p>类Unix（Linux、Mac OS）： traceroute;</p><p>Windows：tracert</p></blockquote><p>依赖于数据包的存活时间TTL字段，路由器在路由时会将TTL的值-1，丢弃值为0的包，并返回ICMP超时错误消息；</p><p>路由追踪工具发送TTL值逐渐增加的数据包，初始值为1，同时TTL值相同的包会发送3次。</p><p>基于路由跟踪工具实现方式的不同，数据包到达目的地址时返回的ICMP信息类型也不同；</p><p><code>traceroute</code>默认基于UDP实现，使用一个大于<code>30000</code>的端口号，然而大多数主机关闭了UDP服务，主机会将数据包丢弃而不返回任何信息，因此可以使用基于ICMP的实现，<code>tracert</code>指令通过该方式实现；</p><p>也可以使用<code>traceroute</code>命令添加特定参数指定实现方式，该方式源地址发送的时是ICMP echo request，目的地发送一个ICMP echo reply</p><p><del>话说，计网应该学过这个</del></p><h2><span id="32-主机扫描">3.2 主机扫描</span></h2><h3><span id="321-主机扫描">3.2.1 主机扫描</span></h3><p>​    主机扫描是网络扫描的基础。攻击者利用主机扫描获得网络中活动的主机，然后以他们为目标进行后续的攻击。主机扫描的思想是向目标主机发送特定的数据包，若目标主机有回应，则认为该主机是活动的。常见的主机扫描技术包括Ping扫描以及对局域网的ARP扫描等。</p><p>​    最简单的ping扫描技术是ICMP echo request 发送至多个主机，现在很多防火墙光率ICMP报文，以避免来自外部的对站点或主机的嗅探。</p><p>​    TCP SYN报文也可被用来进行主机发现与扫描，发送SYN报文，根据SYN、ACK标志数据包确认远程主机处于活动状态。</p><p>​    ARP是根据IP地址获取物理地址的TCP/IP协议，发送ARP请求报文，如果该IP地址成功接收该报文且为活动状态，即会响应并发回自身MAC地址。只适用于局域网内的主机扫描。</p><h3><span id="322-端口扫描">3.2.2 端口扫描</span></h3><p>​    经过主机扫描获取活动主机的相关信息后，需对目标主机进行端口扫描，获取其开放端口信息。</p><p>​    TCP Connect扫描时最简单的端口扫描技术，基于TCP三次握手发现活动端口，扫描方式不隐蔽，大量的连接请求会被记录到系统服务日志中，容易被屏蔽。 技术有TCP SYN扫描、TCP ACK扫描、TCP FIN扫描、X-mas扫描、Null扫描等。</p><ul><li>TCP SYN扫描是最受欢迎的扫描，执行的很快。</li><li>TCP ACK扫描不能确定端口的开放状态，目标若为配置防火墙规则对ACK数据包进行过滤，无论其状态是否开放都将返回RST数据包相应。然而 ack扫描可以通过探测端口的连接是否被过滤来探测防火墙规则与配置；</li><li>这两类扫描过程未建立完整的tcp连接，被称为半开放扫描。速度快，不容易被记录进日志。</li></ul><h3><span id="323-系统扫描">3.2.3 系统扫描</span></h3><p>​    得到开放端口后，需要确定使用的操作系统，决定了攻击者后续采取的攻击方式。常用的OS扫描技术实际上是基于TCP/IP协议栈的指纹识别。扫描程序将一系列TCP和UDP数据包发送给目标主机，并将说到的回应数据包与数据库内已知OS指纹比对，匹配出目标主机的OS。</p><h3><span id="324-服务扫描">3.2.4 服务扫描</span></h3><p>​    得到开放端口后，还需要确定该端口提供的服务。因为目标主机可能将常见服务部署在非标准的端口上，利用服务扫描技术可以正确识别这些端口上的服务。</p><p>​    服务扫描程序根据不同服务的特点发送特定的数据包，也可以利用常见的服务于端口号的映射表来基于端口扫描的结果报告主机上运行的服务。这种方式不一定是准确的，因为远程主机可能对服务指定非默认端口。</p><h3><span id="325-网络扫描工具">3.2.5 网络扫描工具</span></h3><p>​    网络映射器 Network Mapper, Nmap 是一个强大的网络扫描工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap [scan <span class="built_in">type</span>(s)] [options] [target]</span><br><span class="line"><span class="comment"># target表示要扫描的对象，IP地址、网段、主机号等</span></span><br><span class="line"><span class="comment"># 支持自定义扫描模式、参数，部分参数需要sudo权限</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-sN</td><td>ping 扫描，主机发现</td></tr><tr><td>-sT</td><td>TCP 连接扫描</td></tr><tr><td>-sS</td><td>TCP SYN 扫描</td></tr><tr><td>-sA</td><td>TCP ACK 扫描</td></tr><tr><td>-sU</td><td>UDP 连接扫描</td></tr><tr><td>-O</td><td>操作系统扫描</td></tr><tr><td>-sV</td><td>开放端口的系统服务以及版本扫描</td></tr></tbody></table></div><h1><span id="lab-6-缓冲区溢出攻击实验">Lab-6 缓冲区溢出攻击实验</span></h1><h2><span id="三-实验原理">三、实验原理</span></h2><h3><span id="31-操作系统中的函数调用">3.1 操作系统中的函数调用</span></h3><p>冯·诺伊曼结构采用存储程序原理，将数据和代码存储在内存中。代码在内存中以数据形式存储。</p><p>例如 <code>xor eax,eax</code>表示 <code>eax</code>寄存器的值与自己进行异或操作，用机器码表示为 <code>0x31 0xc0</code>其中 <code>0x31</code>是异或操作，<code>0xc0</code>是 <code>eax</code>寄存器。</p><p>同时，CPU使用寄存器来暂存指令、数据和地址。以32位系统为例，常用的寄存器包括通用寄存器（<code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>）、偏移寄存器（<code>EBP</code>、<code>ESI</code>、<code>EDI</code>、<code>ESP</code>），其中：</p><ul><li>通用寄存器用来操作数据，保存算术逻辑运算结果、传送数据；</li><li><code>EBP</code>存放基址指针，指向系统栈最上面一个栈帧的及地址，该地址保存上一级调用者的<code>EBP</code></li><li><code>ESP</code>存放栈指针，指向系统栈最上面一个栈帧的顶部；</li><li><code>EIP</code>存放指令指针，指向下次将要执行的指令；</li></ul><p>栈是一种存储运行程序中函数调用时重要信息的数据结构，LIFO。在Intel系统中，栈从<strong>高地址往低地址堆叠</strong>。函数的每次调用会在系统站中堆叠一个栈帧 Stack Frame，该栈帧包括参数 Parameter、返回地址 Return Address、前一栈帧的指针 Previous Frame Pointer以及该函数的局部变量Local Variables。</p><h3><span id="32-缓冲区溢出漏洞">3.2 缓冲区溢出漏洞</span></h3><p>Buffer Overflow，例如定义 buffer[10]，写入数据的长度大于10，造成缓冲区溢出，<strong>传入的其余数据继续向上填充</strong>，若传入的数据填充了返回地址段，返回地址被改写，指向新的内存地址。</p><p>Shellcode是一段获取shell程序的代码，通常用机器语言编写，以十六进制表示。NOP No Operation指令，即 <code>0x90</code>告诉CPU不做任何操作，跳到下一条指令。缓冲区溢出攻击中通常选用Shellcode作为攻击的恶意代码。有时，攻击者并不能知道恶意代码在内存中的准确地址，会在恶意代码前加入大段NOP指令，来提高攻击成功率。</p><p>风险C语言函数：</p><ul><li>gets()</li><li>strcpy(char *Dst, char *Src)</li><li>strcat(char *Dst, char *Src)</li><li>sprint(char *buffer, const char *format, [argument, $\cdots$])</li></ul><p>防御机制：内存地址空间随机化 Address Space Layout Randomization, ASLR、 GCC编译器 StackGuard保护机制、编译声明不可执行栈、shell程序检查UID等</p><h3><span id="33-gdb调试工具">3.3 GDB调试工具</span></h3><p>用来查看程序执行过程中的运行信息，如程序的地址空间结构等。</p><p>调试一个程序，需要在编译该程序时加入 <code>-ggdb</code>参数，以产生调试工具GDB所必要的调试信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o sample -ggdb sample.c</span><br><span class="line">gdb sample</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>break [function-name]</td><td>设置断点</td></tr><tr><td>info break</td><td>查看断点信息</td></tr><tr><td>delete [break-point(s)]</td><td>删除断点</td></tr><tr><td>run [program-args]</td><td>运行</td></tr><tr><td>continue</td><td>运行直至下一个断点</td></tr><tr><td>step</td><td>执行下一步</td></tr><tr><td>next</td><td>执行下一个函数</td></tr><tr><td>info registers [reg-name]</td><td>查看具体寄存器信息</td></tr><tr><td>print [variable-name]</td><td>查看变量</td></tr><tr><td>backtrace [full]</td><td>查看栈追踪</td></tr><tr><td>x/nfu [variable-or-address]</td><td>查看内存<br>n：需要显示的内存单元的个数，默认为 1<br> f：显示的格式，默认为 x，即十六进制<br>u：一个内存单元的字节数，默认为 w，即 4 字节</td></tr></tbody></table></div><h2><span id="四-实验步骤">四、实验步骤</span></h2><h3><span id="41-实验环境配置">4.1 实验环境配置</span></h3><p>环境所需依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc gdb lib32z1 libc6-dev-i386 \</span><br><span class="line">lib32ncurses5-dev</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux32</span><br><span class="line">/bin/bash</span><br><span class="line"><span class="built_in">cd</span> xxx</span><br></pre></td></tr></table></figure><p>进入32位环境</p><h3><span id="42-gdb使用练习">4.2 GDB使用练习</span></h3><p>关闭地址空间随机化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure><p>编译 <code>sample.c</code>程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -w -g -fcf-protection=none -o sample sample.c</span><br></pre></td></tr></table></figure><p>其中 <code>-m32</code>代表编译32位程序，<code>-fno-stack-protector</code>代表关闭栈保护机制，<code>-w</code>用来忽略编译过程中的部分警告，<code>-g</code>表示产生符号调试工具GDB所必要的符号信息，<code>-fcf-protection=none</code>禁用控制流传输指令的目标地址是否有效，<code>-o</code>指定编译后的可执行文件名。</p><p>首先，进去gdb，设置断点并运行程序，用 <code>step</code>来单步执行程序。可以使用 <code>disassemble &lt;function_name&gt;</code>来反汇编该函数</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231025141949122.png" alt="image-20231025141949122"></p><p>反汇编的输出为函数的汇编代码，每一行是一条汇编指令，指令前还附带该指令的内存地址，箭头所指位置是0x56556277地址的指令，作用是调用 <code>sample_function</code>函数。当他返回时，他应该执行下一条指令，即 地址为0x5655627c的指令。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231025142339162.png" alt="image-20231025142339162"></p><p><code>info reg</code> 查看寄存器信息，该命令显示了寄存器的值及解码值，本实验只用到第一个值（<font color="red">为什么？</font>），即寄存器的十六进制值。可以看到栈指针 esp指向0xffffcf10，基址指针ebp指向0xffffcf28，指令指针eip指向0x56556277，也就对应的调用 <code>sample_function()</code>这条指令，说明下一条被执行的指令就是这个。</p><p>进入 <code>sample_function()</code>函数之前，反汇编该函数：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231025143139941.png" alt="image-20231025143139941"></p><p>得到的汇编代码中，<code>&lt;+0&gt;</code> <code>&lt;+1&gt;</code> <code>&lt;+4&gt;</code>三条指令常见于GCC编译器为大多数函数生成的汇编代码中。它将当前基址指针保存于栈中 <code>push %ebp</code>，将基质指针指向当前栈的顶部 <code>mov %esp, %ebp</code>，然后向下移动栈指针，为局部变量分配空间 <code>sub $0x14, %esp</code></p><blockquote><p>汇编语言中， <code>$</code>这个符号通常用于表示立即数，用于将一个常数值直接传递给指令而不是从内存中读取。</p></blockquote><p><code>&lt;+3&gt;</code> <code>&lt;+7&gt;</code> <code>&lt;+12&gt;</code>这三条指令也是GCC添加的，他们将程序栈的地址记录并保存在一个独立的内存区域（Global Offset Table，GOT，全局偏移量表），使得程序在每次运行时可以被加载到不同的内存区域中并正确运行。</p><p>具体细节如下：将ebx保存到栈中，调用 <code>__x86.get_pc_thunk.bx</code>的子程序，该程序通过执行汇编指令 <code>mov %esp, %ebx</code>，将当前栈顶地址加载到EBX中，下一行则将一个数字 <code>0x2e0b</code>与EBX相加，并把保存结果到EBX中。这里加的数字与GOT有关，自此，函数的起始位置与GOT相关联。</p><p>接下来的代码时基于函数的C代码产生的。</p><p>进入 <code>sample_function</code>函数时，首先，一个返回地址会被call指令压入栈顶，此时的ESP指向的是返回地址的位置，之后将 EBP压入栈顶，然后将EBP设为ESP的值</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231026004023538.png" alt="image-20231026004023538"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231026004226386.png" alt="image-20231026004226386"></p><h3><span id="43-缓冲溢出攻击">4.3 缓冲溢出攻击</span></h3><h1><span id="作业2">作业2</span></h1><h2><span id="缓冲区溢出攻击">缓冲区溢出攻击</span></h2><p>构造一个shellcode， 实现进入root权限，具体的shellcode代码为实验6中提供的代码。</p><p>之后在适当位置插入攻击代码，初步猜测是将shellcode插入在buffer尾部; 发现不是那么简单。</p><p>要开始想想了</p><p>对于<code>x/32xw $esp</code>的感觉是，它展示了内存中的对应地址的数据是什么。</p><p>缓冲区溢出攻击会将程序的返回地址府改为攻击代码。</p><p>初步的认识是 <code>x/xw $ebp</code>返回的蓝色地址是实质上保存的地址，白色部分是该地址对应的内容</p><p>所以，我猜测攻击的方式是在sprintf()之后看看esp到达哪里了，之后做个差看看应该在那个位置</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络创新安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第四周学习日志</title>
      <link href="/2023/09/27/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/27/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>不可辨认安全</p><span id="more"></span><p><strong>randomness extractor</strong></p><ul><li>Ext(X,seed)</li></ul><p>One-time pad</p><ul><li>limitations<ul><li>the key is <strong>as long as</strong> the message </li><li>only secure if each key is used to encrypt a <strong>single</strong> message</li><li>Trivially broken by a known-plaintext attack</li></ul></li></ul><p>Optimality of the one-time pad</p><p><strong>Theorem</strong></p><p>if (Gen,Enc,Dec) with message space M is perfectly secret, then $|K| \ge |M|$</p><h2><span id="1-perfect-indistinguishability">1 Perfect Indistinguishability</span></h2><p>We saw other drawbacks of perfect secrecy, like the long key length and so on. If we want to do better, we need to relax the definition.</p><p>The perfect secrecy requires that <strong>absolutely no information</strong> about the plaintext is leaked, even to eavesdroppers with <strong>unlimited computational power</strong>.</p><p>However, we can allow tiny probability of failure actually, for example, security fails with  probability &gt; $2^{-60}$, this possibility is so small that we needn’t to worry about being attacked.</p><h3><span id="roadmap">Roadmap</span></h3><p>we will give an alternate definition of perfect secrecy - Using a randomized experiment</p><p>That definition has a natural relaxation.</p><h3><span id="perfect-indistinguishability">Perfect indistinguishability</span></h3><ul><li>$\Pi = (Gen, Enc, Dec)$, message space $\mathcal{M}$, an adversary $\mathcal{A}$</li><li>Define a randomized exp’t $\text{Privk}^{\text{eav}}_{\mathcal{A},\Pi}$</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007143101027.png" alt="image-20231007143101027"></li><li>Adversary $\mathcal{A}$ succeeds if b = b’, and we say the experiment evaluates to 1 in this case</li><li>$\Pi$ if perfectly indistinguishability if no $\mathcal{A}$ can guess correctly with probability any better than 0.5</li></ul><h4><span id="def-26">Def. 2.6</span></h4><p>$\Pi$ is perfectly indistinguishable if for all attackers $\mathcal{A}$, it holds that </p><script type="math/tex; mode=display">\Pr[\text{Privk}^{\text{eav}}_{\mathcal{A},\Pi}] = \frac{1}{2}</script><h2><span id="2-security-definition-of-encryption">2 Security Definition of Encryption</span></h2><p>There are two approaches to relax perfect indistinguishability: Concrete security and Asymptotic security.</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007145801664.png" alt="image-20231007145801664"></p><p>$k \leftarrow Gen(1^\lambda)$表示输入的长度是$\lambda$</p><h3><span id="computational-indistinguishability">Computational indistinguishability</span></h3><h4><span id="concrete-security-version">concrete security version</span></h4><ul><li>$(t, \epsilon)$-indistinguishability:<ul><li>Security may fail with probability $\leq \epsilon$</li><li>Restrict attention to attackers running in time $\leq t$</li></ul></li><li>$\Pi$ is  $(t, \epsilon)$-indistinguishable if for all attackers $\mathcal{A}$ running in time at most t, it holds that $\Pr[\text{Privk}^{\text{eav}}_{\mathcal{A},\Pi}] \leq \frac{1}{2} + \epsilon$</li><li>Parameters $t,\epsilon$ are what we ultimately care about in the real world</li><li>does not lead to a clean theory<ul><li>sensitive to exact computational model</li><li>$\Pi$ can be $(t,\epsilon)$ -secure for may choices of $t,\epsilon$</li></ul></li></ul><h4><span id="asymptotic-security">asymptotic security</span></h4><ul><li>introduce security parameter n<ul><li>can view as the key length</li><li>fixed by honest parties at initialization<ul><li>allow users to tailor the security level </li></ul></li><li>known by adversary </li></ul></li><li>measure running times of all parties, the success probability of the adversary, as functions of n</li><li>asymptotic security version<ul><li>security may fail with probability negligible in n </li><li>restrict attention to attackers running in time polynomial in n</li></ul></li></ul><h5><span id="def-34-function-negligibility">Def 3.4 function negligibility</span></h5><ul><li>A function $f: Z^+ \rightarrow Z^+$ is at most polynomial if there exists c such that $f(n) &lt; n^c$ for large enough n</li><li>A function $f: Z^+ \rightarrow [0,1]$ is negligible if for every polynomial p it holds that $f(n) &lt; \frac{1}{p(n)}$ for large enough n</li></ul><h2><span id="3-eav-secure-encryption-schemes">3 EAV-Secure Encryption Schemes</span></h2><h2><span id="4-multiple-encryptions">4 Multiple Encryptions</span></h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全协议第四周学习日志</title>
      <link href="/2023/09/26/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/26/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>BAN逻辑</p><span id="more"></span><h1><span id="安全协议ban逻辑">安全协议（BAN逻辑）</span></h1><p>安全协议分析假设密码学原语是安全的</p><blockquote><p>学习目标</p><p>理解并掌握BAN逻辑的基本框架</p><p>能够基于BAN逻辑进行分析</p></blockquote><h2><span id="1-安全协议分析方法">1 安全协议分析方法</span></h2><p>安全协议分析目的：证明安全协议的证明<strong>执行过程满足安全需求定义</strong></p><p>安全协议分析活动不仅包含安全协议设计迭代过程中的安全协议分析阶段，也包含<strong>需求定义阶段</strong></p><ul><li>证明协议不安全，找反例</li><li>证明协议安全，困难</li></ul><p>有五种基本方法</p><ol><li>可证明安全理论与方法<ul><li>本质上是一种公理化研究方法</li><li>利用归约论断指出挫败方案或协议的唯一方法是破译或解决极微本原</li><li>具有明确的安全定义和计算化的语义，难以进行自动化分析</li></ul></li><li>形式化分析理论与方法<ul><li>使协议设计者通过系统分析，将注意力集中于接口、系统环境的假设、系统在不同条件下的状态、条件不满足是系统出现的情况及系统不变的属性，并通过系统验证，提供安全保证</li><li>常见三种形式化分析方法<ol><li><strong>以BAN类逻辑为代表的基于推理结构性方法</strong>，运用逻辑系统</li><li><strong>基于攻击结构性方法</strong></li><li><strong>基于证明结构性方法</strong></li></ol></li><li><strong>易于自动化分析，没有计算化的语义</strong></li></ul></li><li>混合理论与方法</li><li>零只是证明理论与方法<ul><li>证明者试图使验证者相信某个论断正确，却不想验证者提供任何有用的信息</li></ul></li><li>安全多方计算理论与方法</li></ol><h2><span id="2-ban逻辑的基本框架">2 BAN逻辑的基本框架</span></h2><p>BAN逻辑是一种分析认证协议的逻辑,是一种关于知识和信念的逻辑,包含每个主体各自维护的信念集合,以及从旧信念推导出新信念的推理规则集合</p><p>BAN逻辑旨在<strong>抽象层次上</strong>讨论认证协议的安全性</p><p>假设:</p><ol><li><p>时间假设</p><ol><li>协议分析中区分两个时间段，过去时间段和当前时间段</li><li>当前时间段开始于协议运行的开始阶段，所有在此时间之前发送的消息都认为是过去时间段发送的消息。</li><li>如果信仰在开始时成立，则在整个当前时间段都成立，而在过去时间段成立的信仰，在当前时间段不一定成立</li></ol></li><li><p>密钥假设</p><ol><li>加密系统是完善的，只有知道密钥的主体才能解读密文消息，任何不知道密钥的主体不能解读密文消息，也没有办法根据密文推导密钥。</li><li>密文块不能被篡改，也不能用几个小的密文块来拼凑成一个新的大的密文块，一个消息中的两个密文块被看作是分两次分别送达的。</li><li>密文中有足够的冗余信息，解密者可以根据解密的结果判断他是否已经正确解密</li><li>消息中有足够的冗余信息，使得主体可以判断该消息是否来源于自身。</li></ol></li><li><p>主题假设</p><ol><li>BAN逻辑还假设协议的参与主体是诚实的。</li></ol></li></ol><p><strong>重点部分:</strong></p><h3><span id="21-ban逻辑构建的语法和语义">2.1 BAN逻辑构建的语法和语义</span></h3><p>BAN逻辑是一种多类型的模态逻辑 many-sorted model logic</p><p>BAN逻辑的语义中主要包含下面三种处理对象：</p><ul><li>主体 principals</li><li>密钥 keys</li><li>公式 formula 也被称为语句或命题 statements</li></ul><p>在BAN逻辑中，</p><ul><li>A，B表示主体， S表示服务器</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004084412595.png" alt="image-20231004084412595"></li><li>$N_a,N_b,N_c$表示随机数</li><li>P、Q、R表示主体变量，K表示密钥变量，X、Y表示公式变量</li></ul><p>包含和取指一种命题连接词，用逗号表示</p><p><strong>BAN逻辑的10个基本逻辑构件</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004084704488.png" alt="image-20231004084704488"></p><h3><span id="22-ban逻辑的推理规则">2.2 BAN逻辑的推理规则</span></h3><p>BAN逻辑的推理规则共19条</p><ul><li><p>消息含义规则</p><ul><li>使主体推知其他主体发送过的消息——说明消息的出处</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004093214446.png" alt="image-20231004093214446">如果P相信$K_{PQ}$使P与Q的共享密钥，并且P曾经接受包含$K_{PQ}$加密的消息X，则P相信Q发送过消息X。</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004093439495.png" alt="image-20231004093439495">如果P相信Q具有密钥公钥$K_Q$，P曾经接受过由私钥加密的X，则P相信Q发送过消息X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004093815317.png" alt="image-20231004093815317">如果P相信PQ共享秘密Y，且P曾经接收过与秘密Y合成的消息X，则P相信Q发送过消息X</li></ol></li><li><p>随机数验证规则</p><ul><li>如果消息使当前发送的，那么消息的发送者应该相信该消息</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094056781.png" alt="image-20231004094056781">如果P相信X使新鲜的，且P相信Q曾经说过X，那么P相信Q相信X</li></ol></li><li><p>管辖规则</p><ul><li>扩展了主体的推知能力</li></ul><ol><li>使主体可以在基于其他主体已有的信仰之上推知新的信仰<img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094300249.png" alt="image-20231004094300249">如果P相信Q对于消息X具有管辖权，且P相信Q相信X，那么P相信X</li></ol></li><li><p>接收消息规则</p><ul><li>定义了主体在协议运行中对消息的获取</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094434132.png" alt="image-20231004094434132">如果P曾经接受过（X，Y)，那么P曾经受到过消息X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094533512.png" alt="image-20231004094533512">如果P曾经接受过带有秘密信息Y的\<x\>，那么P曾经接受过消息X</x\></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094749112.png" alt="image-20231004094749112">如果P相信PQ具有公共密钥$k_{PQ}$，且P接受过用$k_{PQ}$加密的X，那么P接受过X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094853674.png" alt="image-20231004094853674">如果P相信P具有密钥公钥k,且P接受过用k加密的消息X，那么P接受过消息X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004095021514.png" alt="image-20231004095021514">如果P相信Q具有密钥公钥k，且P接受过用私钥加密的X，那么P曾经接受过X</li></ol></li><li><p>新鲜性规则</p><ul><li>如果一个公式的一部分是新鲜的，则该公式的全部是新鲜的</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100038029.png" alt="image-20231004100038029">如果P相信X是新鲜的，则P相信消息（X，Y) 是新鲜的</li></ol></li><li><p>信仰规则</p><ul><li>反应了信念在消息的级联与分割的不同操作中的一致性以及信念在此类操作中的传递性</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100544696.png" alt="image-20231004100544696"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100552214.png" alt="image-20231004100552214"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100603723.png" alt="image-20231004100603723"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100610283.png" alt="image-20231004100610283"></li></ol></li><li><p>密钥与秘密共享规则</p><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100729020.png" alt="image-20231004100729020"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100737956.png" alt="image-20231004100737956"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100746413.png" alt="image-20231004100746413"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100756376.png" alt="image-20231004100756376"></li></ol></li></ul><h2><span id="3-应用ban逻辑分析协议的方法">3 应用BAN逻辑分析协议的方法</span></h2><p>基本原理：</p><ul><li>可形式化定义协议的目标，并确定协议初始时刻各参与者的知识和信任，通过协议里信息的发送和接受步骤产生新知识，运用推到规则来得到目标信任和新知识</li><li>如果得到最终的关于知识和信任的语句集里不包含所要得到的信任和知识的语句是，就表明协议存在安全缺陷</li></ul><h3><span id="31-理想化过程">3.1 理想化过程</span></h3><p>省略协议会话中的明文部分，理想化后的协议消息形式为$\{X_1\}_{K_1},\cdots,\{X_n\}_{K_n}$</p><p>指导方针：</p><ul><li>如果任何时候接收者得到了一个真实消息m后能推导出发送者必须相信X，那么m能被解释成一个公式X</li><li>现实中的随机数被转化为任意的新公式</li><li>假定在整个过程中发送这都相信这些公式： \<x\>_Y<ul><li>把Y作为一个秘密使用，仅当该秘密用作身份证明时有效</li><li>出于实用性目的，每个主体总是相信他作为消息产生的公式</li></ul></x\></li></ul><h3><span id="32-认证协议的基本假设">3.2 认证协议的基本假设</span></h3><p>描述协议运行开始时的初始条件</p><p>发送第一条消息以前的公式表示各主体在协议开始时的信条</p><ul><li>各主体之间共享了哪些密钥</li><li>哪些主体能产生新鲜的随机数</li><li>哪些主体在哪方面被信任</li></ul><h3><span id="33-ban逻辑分析协议解释">3.3 BAN逻辑分析协议解释</span></h3><p>用逻辑语言解释理想化后的协议语句</p><p>解释过程遵循以下原则：</p><ul><li>如果在P-&gt;Q:Y之前X成立，则之后X和QΔY都成立</li><li>如果根据推理规则，能从已知的X推导出Y，则X成立时Y必然成立</li><li>如果能从X得到Y，则X成立时Y也成立</li></ul><h3><span id="34-形式化协议目标">3.4 形式化协议目标</span></h3><p>一些对称密码体制的认证协议希望安全的交换会话密钥，形式化描述协议目标为：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004195834918.png" alt="image-20231004195834918"></p><p>确认对方也信任该会话密钥：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004195859976.png" alt="image-20231004195859976"></p><h3><span id="35-ban逻辑分析步骤">3.5 BAN逻辑分析步骤</span></h3><ol><li>对协议进行理想化处理，将协议的实际信息转换成BAN逻辑的公式</li><li>用逻辑语言描述协议初始状态，给出所有的基本假设</li><li>对协议进行解释，将协议会话转换为逻辑语言</li><li>用逻辑语言描述协议所需达到的目标</li><li>应用推理规则对协议进行形式化分析，从协议的开始进行退证，直至验证协议是否满足协议目标</li></ol><h2><span id="4-ban逻辑的应用实例">4 BAN逻辑的应用实例</span></h2><p>NS协议的分析</p><h2><span id="5-ban逻辑的缺陷及改进方向">5 BAN逻辑的缺陷及改进方向</span></h2><h3><span id="51-ban逻辑的缺陷">5.1 BAN逻辑的缺陷</span></h3><ol><li>BAN逻辑基于的基本假设——主题假设存在问题<ul><li>不一定总是诚实</li></ul></li><li>理想化过程存在问题<ul><li>BAN逻辑没有对协议的理想化过程提供标准的转换格式，过分依赖于分析者的直觉</li></ul></li><li>缺乏完备性</li><li>缺乏一个定义良好、确切的语义</li></ol><h3><span id="52-ban逻辑的改进方向">5.2 BAN逻辑的改进方向</span></h3><ul><li>确立一个可靠的语义</li><li>减少理想化步骤的模糊度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 安全协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络内容安全第四周学习日志</title>
      <link href="/2023/09/25/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/25/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2><span id="一-网络信息内容获取模型">一、网络信息内容获取模型</span></h2><p><del><em>PPT乱七八糟绷不住了</em></del></p><h3><span id="10-互联网信息类型">1.0 互联网信息类型</span></h3><ul><li>网络媒体形态<ul><li>广播式媒体<ul><li>新闻网站、论坛、博客</li></ul></li><li>交互式媒体<ul><li>社交媒体、搜索引擎等</li></ul></li></ul></li><li>网络媒体信息<ul><li>互联网网站公开发布的信息，用户通常可以基于通用网络浏览器获取</li></ul></li><li>网络通信信息<ul><li>实现与特定点通信或点对点通信所交互的信息</li></ul></li><li>发布信息类型<ul><li>文本</li><li>图像</li><li>音频</li><li>视频</li></ul></li><li>媒体发布方式<ul><li>匿名</li><li>身份认证</li></ul></li><li>网页形态<ul><li>静态</li><li>动态：含“？”或输入参数的URL</li></ul></li><li>信息交互协议</li><li>专业客户端软件</li></ul><h3><span id="11-网络信息内容获取模型">1.1 网络信息内容获取模型</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/网络环境下的信息内容获取模型.png" alt="img1"></p><p><strong>信息检索</strong> (Information Search， IS)是信息需求者主动搜寻所需要的信息</p><p><strong>信息推荐</strong></p><p><strong>信息交互</strong></p><p><strong>信息浏览</strong></p><h3><span id="12-网络媒体信息获取原理">1.2 网络媒体信息获取原理</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/网络信息获取流程.png" alt="img2"></p><p>网上采集算法（爬虫）</p><h3><span id="13-网络媒体信息获取的分类">1.3 网络媒体信息获取的分类</span></h3><ol><li>全网信息获取</li><li>定点信息获取</li><li>基于主题的信息获取和元搜索<ul><li>元搜索又称多搜索引擎<ul><li>搜索机制分为并行式和串行式</li></ul></li><li>高级检索功能：<ul><li>使用布尔逻辑符检索</li><li>域名过滤</li><li>等等</li></ul></li></ul></li></ol><p>信息获取的技术难点</p><ul><li>网络媒体信息：形态各异、信息类型多样</li><li>DDOS</li></ul><h2><span id="二-搜索引擎技术">二、搜索引擎技术</span></h2><ul><li>网络内容分析</li><li>网页索引</li><li>查询解析</li><li>相关性计算</li></ul><h3><span id="221-网上采集算法">2.2.1 网上采集算法</span></h3><p>爬虫</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/爬虫原理.png" alt="img3"></p><h4><span id="分类">分类</span></h4><ul><li>通用网络爬虫</li><li>聚焦网络爬虫</li><li>增量式网络爬虫</li><li>深层网络爬虫</li></ul><h4><span id="原理">原理</span></h4><ol><li>初始URL集合</li><li>信息获取</li><li>信息解析</li><li>信息判重<ol><li>URL判重</li><li>内容摘要判重</li></ol></li></ol><h4><span id="url爬取策略">URL爬取策略</span></h4><ul><li>深度优先遍历策略</li><li>广度优先遍历策略</li><li>反向链接数策略：一个网页被其他网页链接指向的数量</li><li>Partial PageRank策略</li><li>OPIC策略 online page importance computation </li><li>大站优先策略</li></ul><h3><span id="222-排级算法">2.2.2 排级算法</span></h3><h4><span id="pagerank">PageRank</span></h4><p>原理：民主表决</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/PR算法.png" alt="img4"></p><script type="math/tex; mode=display">\Pr(t) = (1-d) + d(\sum_{i=1}^{n}{\frac{\Pr(t_i)}{|t_i|}})</script><p>$\Pr(t_i)$入度; $|t_i|$出度 $d$影响因子</p><font color="red">入度为什么是概率呢？</font><p>优点：</p><ol><li>直接高效</li><li>主题集中</li></ol><p>缺点：</p><ol><li>忽略网页内容，干扰挖掘结果</li><li>结果范围窄</li><li>影响因子与网页获取数量缺乏科学性</li></ol><p>用来表现网页等级的一个标准，0-10，值越高越受欢迎</p><h4><span id="hits">HITS</span></h4><p><strong>Hub</strong>页面（枢纽页面）指向高质量链接的网页</p><p><strong>Authority</strong>页面（权威页面）相关领域高质量网页</p><p><strong>枢纽值</strong> Hub Scores = sum of all relevant Authority scores</p><p><strong>权威值</strong> Authority Scores = sum of all relevant Hub scores</p><p>基本思想：<strong>相互增强关系</strong></p><h5><span id="算法"><strong>算法</strong></span></h5><ol><li>构建根集合</li><li>扩展集合Base</li><li>计算扩展集base中所有页面的Hub值和Authority值</li><li>排序，结果输出</li></ol><p><strong>优点</strong></p><ol><li>知识范围扩大</li><li>搜索时部分地考虑了页面内容，挖掘结果科学性大大增强</li></ol><p><strong>缺点</strong></p><ol><li>效率低，实时性差</li><li>主题漂移</li><li>易被操纵者操纵结果</li><li>结构不稳定</li></ol><h3><span id="223-搜索引擎与垃圾消息关系">2.2.3 搜索引擎与垃圾消息关系</span></h3><p>垃圾信息制造手段</p><ul><li>提高排名技术 boosting<ul><li>关键字垃圾 term spamming</li><li>链接垃圾 link spamming</li></ul></li><li>隐藏技术 hiding<ul><li>隐藏Boosting技术</li><li>content hiding、 cloaking、 redirection</li></ul></li></ul><h2><span id="三-数据挖掘技术">三、数据挖掘技术</span></h2><p>数据挖掘：通过从数据库中抽取<strong>隐含的</strong>、<strong>未知的</strong>、<strong>具有潜在使用价值</strong>的过程</p><h3><span id="232-web挖掘技术">2.3.2 Web挖掘技术</span></h3><p>从大量<strong>非结构化、异构</strong>的Web信息资源中发现兴趣性的知识，包括概念、模式、规则、规律、约束及可视化等形式的非平凡过程。</p><p>挖掘过程</p><ol><li>资源发现</li><li>信息选择与预处理</li><li>综合过程</li><li>分析过程</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004222043807.png" alt="image-20231004222043807"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004222027301.png" alt="image-20231004222027301"></p><h3><span id="233-web文本挖掘技术">2.3.3 Web文本挖掘技术</span></h3><p>从Web文档和Web活动中发现、抽取感兴趣的、潜在有用的模式和隐藏的信息的过程</p><p>定义：从大量文本的集合C中发现隐含的模式p。如果将C当作输入，p当作输出，那么Web文本挖掘的过程就是从输入到输出的一个映射。</p><h2><span id="四-信息推荐技术">四、信息推荐技术</span></h2><p>信息推荐与信息检索的区别：</p><p>关注点上：信息检索侧重检索结果，信息推荐侧重服务对象</p><p>主动性上：信息检索侧重用户主导，信息推荐侧重系统主导</p><h3><span id="241-信息推荐概念和形式化定义">2.4.1 信息推荐概念和形式化定义</span></h3><p>非形式化定义：利用电子商务网站向客户提供商品信息和建议，帮助用户决定应购买什么产品，模拟销售人员帮助客户完成购买过程。</p><p>信息推荐有三个组成要素：<strong>推荐候选对象、用户、推荐方法</strong></p><p>形式化定义：</p><p>设C是所有用户的集合，S是所有可以推荐给用户的商品对象的集合，效用函数u()用以计算对象s对用户c的推荐度和产品的可得性，即：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004230008763.png" alt="image-20231004230008763"></p><p>R是一定范围内的全序的非负实数，信息推荐要研究的问题就是找到推荐度R最大的那些对象$s^*$，即：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004230108996.png" alt="image-20231004230108996"></p><blockquote><p>arg   是变元（即自变量argument）的英文缩写。<br>arg min 就是使后面这个式子达到最小值时的变量的取值<br>arg max 就是使后面这个式子达到最大值时的变量的取值</p></blockquote><h3><span id="242-信息推荐算法">2.4.2 信息推荐算法</span></h3><p><strong>基于内容推荐</strong></p><p><strong>根据用户已选择的对象</strong>，推荐其他类似属性的对象作为推荐</p><ul><li><strong>对象内容特征</strong> Content(s)：以对象的文字描述为主</li><li><strong>用户的资料模型</strong> ContentBasedProfile(c)：取决于机器学习方法</li><li>u(c,s) = score(ContentBasedProfile(c), Content(s))</li></ul><p><strong>协同过滤推荐</strong></p><p>推荐<strong>相似用户</strong>所选择的对象</p><ul><li>找到与当前用户相似的其他用户</li><li>计算对象s对于用户的效用值</li><li>利用效用值对所有s进行排序或加权操作，找到$s^*$</li></ul><p><strong>启发式方式</strong>：使用与新用户c相似的用户c’对一个对象的评价来预测效用</p><p>基于模型的方法：利用用户c对众多对象的评分来学习一个c的模型，然后使用概率方法对新的对象s的推荐效用进行预测</p><p>组合推荐：前/中/后融合组合推荐</p><p>后融合：结果层次上的融合</p><p>中融合：以一种推荐方法做框架，融合另一种推荐方法</p><p>前融合：直接融合</p><h2><span id="五-信息还原技术">五、信息还原技术</span></h2><h3><span id="251-电脑还原技术">2.5.1 电脑还原技术</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004231537426.png" alt="image-20231004231537426"></p><h3><span id="252-网页还原技术">2.5.2 网页还原技术</span></h3><ul><li>数据包捕获技术——网卡接收方式为混杂方式</li><li>协议还原技术<ul><li>数据包捕获、重组、存储、分发</li></ul></li><li>网页内容还原技术</li></ul><h3><span id="253-多媒体信息还原技术">2.5.3 多媒体信息还原技术</span></h3><ul><li>基于解码器</li><li>基于封装</li><li>基于远程线程注入</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工科数学分析第二章——数列极限</title>
      <link href="/2023/09/23/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/23/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%B7%A5%E7%A7%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>第2章 数列极限</p><span id="more"></span><h1><span id="第2章-数列极限">第2章 数列极限</span></h1><blockquote><p>为了避免形式主义的情况，这里主要记录一些容易以文字形式呈现或公式呈现不是特别困难的一些式子</p></blockquote><h2><span id="21-数列的极限">2.1 数列的极限</span></h2><h3><span id="211数列极限的定义">2.1.1数列极限的定义</span></h3><p>数列就是按照正整数编号的一列实数:</p><script type="math/tex; mode=display">a_1,a_2,\cdots,a_n,\cdots</script><p>通常记为$\{a_n\}_{n \geq 1}$或简记为$\{a_n\}$，其中$a_n$称为数列的通项</p><h4><span id="定义211">定义2.1.1</span></h4><p>设$\{a_n\}$是一个数列，a是一个给定的师叔，如果对任意给定的$\epsilon &gt; 0$，总存在一个正整数N，使得当$n&gt;N$时，$\left\vert a_n - a \right\vert &lt; \epsilon$，则称$\{a_n\}$收敛于a，或者称a为数列的极限，记为$\lim_{n \rightarrow \infty}{a_n = a}$</p><p>当数列有极限时，则称数列收敛，否则发散。</p><p><strong>e.g.</strong></p><p>设$a&gt;1$是给定的正数，证明$lim_{n \rightarrow \infty}{\frac{n}{a^n}} = 0$</p><p>由二项式定理证明指数表示成多项式的最高次幂高于任意的多项式</p><h3><span id="212极限定义的否定形式">2.1.2极限定义的否定形式</span></h3><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}{a_n \neq a} \Leftrightarrow \exists \epsilon_0 > 0, s.t. \forall N \in N^*, \exists n_0 > N, \left\vert {a_{n_0} - a}\right\vert \ge \epsilon_0</script><h2><span id="22-数列极限的性质和运算">2.2 数列极限的性质和运算</span></h2><h4><span id="定理221-极限唯一性">定理2.2.1 极限唯一性</span></h4><p>收敛数列的极限是唯一的</p><h4><span id="定义221">定义2.2.1</span></h4><p>给定$\{a_n\}$，如果存在一个实数A，s.t.对所有的n都有$a_n \le  A (a_n \ge A)$，则称此数列有上界(下界)，A称为该数列的一个上界（下界），如果该数列既有上界又有下界，则称该数列有界</p><h4><span id="定理222-有界性">定理2.2.2 有界性</span></h4><p>收敛数列都是有界的</p><h4><span id="定理223-保序性">定理2.2.3 保序性</span></h4><ol><li>设$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b}$，若$a&gt;b$，则$\exists N \in N^*, s.t. n&gt;N时, a_n&gt;b_n$</li><li>若$a_n\ge b_n(n=1,2,\cdots),\lim_{n\rightarrow\infty}{a_n}=a,\lim_{n\rightarrow\infty}{b_n=b}$，则$a\ge b$</li></ol><p><strong>推论（保号性）-简记</strong></p><ol><li>若a&gt;0,则$a_n &gt; 0$</li><li>若$a_n &gt; 0$,则a&gt;0</li></ol><h4><span id="定义222">定义2.2.2</span></h4><p>设$\{a_n\}$是一个数列，任给正整数列$n_1 &lt; n_2 &lt; n_3 &lt; \cdots$，称数列$a_{n_1},a_{n_2},a_{n_3},\cdots$为$\{a_n\}$的一个子列，记为$\{a_{n_k}\}$</p><h4><span id="定理224-数列极限与子列极限的一致性">定理2.2.4 数列极限与子列极限的一致性</span></h4><p>若$\{a_n\}$的极限为a，则他的任意子列极限也为a。</p><h4><span id="定理225-数列极限的四则运算">定理2.2.5 数列极限的四则运算</span></h4><ol><li>若$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b}$，则数列$\{a_n \pm b_n\}$收敛，极限为$a \pm b$</li><li>若$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b}$，则数列$\{a_n b_n\}$收敛，极限为ab</li><li>若$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b\neq0}$，则数列$\{\frac{a_n}{b_n}\}$收敛，极限为$\frac{a}{b}$</li></ol><h4><span id="定理226-夹逼定理">定理2.2.6 夹逼定理</span></h4><p>假设数列$\{a_n\}$、$\{b_n\}$、$\{c_n\}$，满足$a_n\le b_n \le c_n$，且$\lim_{n\rightarrow\infty}{a_n=c_n=a}$则$b_n$极限也为a</p><h2><span id="23-无穷小和无穷大">2.3 无穷小和无穷大</span></h2><h3><span id="231-无穷小">2.3.1 无穷小</span></h3><h4><span id="定义231-无穷小数列">定义2.3.1 无穷小数列</span></h4><p>若数列$\{a_n\}$的极限为0，则成这个数列为无穷小数列，简称无穷小</p><h4><span id="定理231">定理2.3.1</span></h4><ol><li>数列$\{a_n\}$为无穷小的充要条件是$\{|a_n|\}$是无穷小</li><li>两个无穷小数列的和或差依旧是无穷小数列</li><li>设$\{a_n\}$为无穷小，$\{c_n\}$为有界数列，则$\{a_nc_n\}$为无穷小数列</li><li>设$0\le a_n \le b_n$若$\{b_n\}$为无穷小，则$\{a_n\}$也为无穷小</li><li>$\lim_{n\rightarrow\infty}{a_n=a} \Leftrightarrow \{a_n -a \}无穷小$</li></ol><h3><span id="232-无穷大">2.3.2 无穷大</span></h3><h4><span id="定义232">定义2.3.2</span></h4><p>设$\{a_n\}$是一个数列，如果对任意给定的整数M，总存在正整数N，使得当$n&gt;N$时，有$|a_n| &gt; M$，则称$\{a_n\}$无穷大，记为$\lim_{n\rightarrow\infty}{a_n =  \infty}$</p><h4><span id="性质231">性质2.3.1</span></h4><ol><li>$\{a_n\}$无穷大，则$\{a_n\}$无界</li><li>任何无界数列都有无穷大的子列</li><li>若$\{a_n\}$极限为正无穷，$\{b_n\}$极限为正无穷，则它们的和数列或奇数列也为无穷数列</li></ol><h4><span id="性质232">性质2.3.2</span></h4><p>$\{a_n\}$无穷大 等价于 $\{\frac{1}{a_n}\}$无穷小</p><h3><span id="232-stolz定理">2.3.2 Stolz定理</span></h3><h4><span id="定理232-fracinftyinfty">定理2.3.2 $\frac{\infty}{\infty}$</span></h4><p>设$\{b_n\}$是严格递增趋于正无穷的数列，如果</p><script type="math/tex; mode=display">\lim_{n\rarr\infty} \frac{a_n - a_{n-1}}{b_n-b_{n-1}} = A</script><p>则$\lim_{n\rightarrow\infty}\frac{a_n}{b_n}=A$</p><h4><span id="定理233-frac00">定理2.3.3 $\frac{0}{0}$</span></h4><p>设$\{b_n\}$ $\{a_n\}$都是无穷小的数列且$\{b_n\}$严格单调，如果</p><script type="math/tex; mode=display">\lim_{n\rarr\infty} \frac{a_n - a_{n-1}}{b_n-b_{n-1}} = A</script><p>则$\lim_{n\rightarrow\infty}\frac{a_n}{b_n}=A$</p><h2><span id="24-单调数列的极限及其应用">2.4 单调数列的极限及其应用</span></h2><h4><span id="定义241-单调数列">定义2.4.1 单调数列</span></h4><p>$a_n \le a_{n+1}$单调递增，$a_n &lt; a_{n+1}$ 严格单调</p><h4><span id="定理241-单调有界定理">定理2.4.1 单调有界定理</span></h4><p>若$\{a_n\}$单调递增且有上界，则数列收敛，递减类似</p><p>e.g. 2.4.3</p><font color="red">不要忘记stolz定理啊</font><h4><span id="引理-bernoulli-不等式">引理 Bernoulli 不等式</span></h4><p>对任意的$x&gt;1, x\neq 0, n\ge 2, (1+x) ^ n &gt; 1 + nx$</p><p>e.g. 2.4.4</p><p>$\lim_{n\rightarrow\infty}{1 + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n} - \ln n} = \gamma$欧拉常数，0.57721566…</p><h4><span id="定理242">定理2.4.2</span></h4><ol><li>若单调数列有一个子列收敛，则这个数列收敛</li><li>若单调数列有一个子列趋于$\infty$，则数列也趋于$\infty$</li><li>一个单调数列有么极限存在，有么趋于无穷</li><li>单调数列收敛的充要条件是数列有界</li></ol><h2><span id="25-实数连续性的基本定理">2.5 实数连续性的基本定理</span></h2><h4><span id="定理251-闭区间套定理">定理2.5.1 闭区间套定理</span></h4><p>设$I_n=[a_n,b_n]$为一列闭区间，满足：</p><ol><li>$I_1 \supset I_2 \supset \cdots \supset I_n \supset \cdots $</li><li>这些闭区间的长度满足$\lim_{n\rightarrow\infty}{|I_n|} = \lim_{n\rightarrow\infty}{b_n-a_n}=0$则存在唯一的点$\xi \in  \bigcap_{i=1}^{\infty}I_i$</li></ol><p>通常满足条件1的一列闭区间是一个闭区间套</p><h4><span id="定理252-列紧性定理">定理2.5.2 列紧性定理</span></h4><p>任何有界的无穷数列中都存在收敛的子列</p><h4><span id="定义251-基本列定义">定义2.5.1 基本列定义</span></h4><p>给定$\{a_n\}$，若满足：$\forall \epsilon &gt; 0, \exists N, s.t. \forall n,m &gt; N, |a_m - a_n| &lt; \epsilon$则称$\{a_n\}$为一个基本列（Cauchy列），这里的N仅与$\epsilon$有关</p><p>等价定义m=n+p的形式，对于一切$p\in N^*$成立</p><h4><span id="定理253-数列极限的cauchy收敛原理">定理2.5.3 数列极限的Cauchy收敛原理</span></h4><p>$\{a_n\}$收敛的充要条件是$\{a_n\}$是基本列</p><h4><span id="定义252">定义2.5.2</span></h4><p>设E是实数集，$\aleph=\{I_\lambda|\lambda\in\Delta\}$是一个开区间族，其中$\Delta$是一个指标集，如果$E\subset\bigcup_{\lambda\in\Delta}I_\lambda$则称，$\aleph$覆盖了E，或者说是一个开覆盖</p><h4><span id="定理254-heine-borel定理">定理2.5.4 Heine-Borel定理</span></h4><p>设$\aleph=\{I_\lambda|\lambda\in\Delta\}$为有限闭区间[a,b]任意一个开覆盖，则可从$\aleph=\{I_\lambda|\lambda\in\Delta\}$中选出有限个开区间构成[a,b]的覆盖</p><h2><span id="26-上极限与下极限的概念和性质">2.6 上极限与下极限的概念和性质</span></h2><h4><span id="定义261">定义2.6.1</span></h4><p>设$\{a_n\}$是一个有界数列，令</p><script type="math/tex; mode=display">\overline{a_n} = sup_{k \ge n}\{a_k\} = sup\{a_n,a_{n+1}, \cdots, \} \\\underline{a_n} = inf_{k \ge n}\{a_k\} = inf\{a_n,a_{n+1}, \cdots, \}</script><p>上数列和下数列</p><h4><span id="定义262">定义2.6.2</span></h4><p>设$\{a_n\}$是一个有界数列，则称$\lim_{n\rightarrow\infty}\overline{a_n}$为$\{a_n\}$上极限，反之下极限</p><h4><span id="定理261">定理2.6.1</span></h4><p>设$\{a_n\}$是一个有界数列，则数列$\{a_n\}$收敛充要条件是极限等于上极限等于下极限</p><h4><span id="定理262">定理2.6.2</span></h4><p>设$\{a_n\}$$\{b_n\}$是有界数列，若存在$N\in N^*,s.t. n&gt;N时 a_n\le b_n，则n&gt;N时，a_n\le b_n,\overline{a_n} \le \overline{b_n}$</p><h4><span id="定理263">定理2.6.3</span></h4><p>设$\{a_n\}$有界</p><ol><li>对任意的$M &gt; \overline{\lim_{n\rightarrow\infty}}{a_n}$，都存在$N\in N^*, s.t. n&gt; N 时 a_n&lt;M$</li><li>对任意的$m &lt; \underline{\lim_{n\rightarrow\infty}}{a_n}$，都存在$N\in N^*, s.t. n&gt; N 时 a_n&gt;m$</li></ol><h4><span id="定理264">定理2.6.4</span></h4>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp学习日志</title>
      <link href="/2023/09/23/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/23/%E7%A7%91%E7%A0%94%E7%AB%9E%E8%B5%9B/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考主教程：<a href="https://light-city.github.io/">C++那些事 (light-city.github.io)</a></p></blockquote><h1><span id="基础进阶部分">基础进阶部分</span></h1><h2><span id="const那些事">const那些事</span></h2><ol><li><p>含义：const说明的类型叫做常类型，常类型的变量或对象的值是不能被更新的</p></li><li><p>作用：</p><ol><li><p>可以定义常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li><p>类型检查</p><p>const常量与#define宏定义的常量区别： const 常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，知识简单的字符串替换，不能进行安全检查。</p><p><code>const</code>定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。</p></li><li><p>防止修改，起保护作用，加强Robustness</p></li><li><p>节省空间，避免不必要的内存分配</p><p>const只是给出了对应的内存地址，而不是像#define一样给出的立即数，const在程序运行过程中一份copy，而#define有若干个copy</p></li></ol></li><li><p>const对象默认为文件局部变量</p><font color="red">非const变量默认为extern， 要使const变量能够在其他文件中访问，必须在文件中显性指定它为extern</font></li><li><p>定义常量</p><ol><li>常量不可更改</li><li>常量必须初始化</li></ol></li><li><p>指针与const</p><ol><li><p>四种相关的const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *a;  <span class="comment">//指向const对象的指针或者说指向常量的指针</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *a; <span class="comment">//同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向类型对象的const指针，或者说常指针、const指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针</span></span><br></pre></td></tr></table></figure><p><strong>允许把非const对象的地址赋给指向const对象的指针</strong></p><p>这时无法通过该指针来修改变量的值，即使指向的是非const对象，也不能通过<code>void *</code> 指针来保存const对象的地址，必须使用从const void * 类型的指针保存const对象的地址</p></li><li><p>常指针</p><p>const指针必须初始化，且指针的值不能修改</p></li><li><p>指向常量的常指针</p></li></ol></li><li><p>函数中使用const</p><ol><li><blockquote><p>const 修饰函数返回值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> * <span class="title">func</span><span class="params">()</span> <span class="comment">// 指针所指不可变</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="type">const</span> <span class="title">func</span><span class="params">()</span> <span class="comment">//指针不可变</span></span></span><br></pre></td></tr></table></figure><ol><li><blockquote><p>const 修饰函数参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(const int var) // 传递过来的参数不可变</span><br><span class="line">void func(int *const var) //指针不可变7</span><br></pre></td></tr></table></figure></li></ol></li><li><p>类中使用const</p><ul><li><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型，如果在编写const成员函数时，不慎修改数据成员，或者调用了其他非const成员函数，编译器将指出错误，提高程序健壮性。</p></li><li><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，否能不能操作常对象</p></li><li><p>对于类中的const成员变量必须通过初始化列表进行初始化</p></li><li><p>```cpp<br>class Apple<br>{<br>private:<br> int people[100];<br>public:<br> Apple(int i);<br> const int apple_number;<br>};</p></li></ul><p>Apple::Apple(int i):apple_number(i)<br>{</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">- ```cpp</span><br><span class="line">  //apple.cpp</span><br><span class="line">  class Apple</span><br><span class="line">  &#123;</span><br><span class="line">  private:</span><br><span class="line">      int people[100];</span><br><span class="line">  public:</span><br><span class="line">      Apple(int i); </span><br><span class="line">      const int apple_number;</span><br><span class="line">      void take(int num) const;</span><br><span class="line">      int add(int num);</span><br><span class="line">      int add(int num) const;</span><br><span class="line">      int getCount() const;</span><br><span class="line">  </span><br><span class="line">  &#125;;</span><br><span class="line">  //main.cpp</span><br><span class="line">  #include&lt;iostream&gt;</span><br><span class="line">  #include&quot;apple.cpp&quot;</span><br><span class="line">  using namespace std;</span><br><span class="line">  </span><br><span class="line">  Apple::Apple(int i):apple_number(i)</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::add(int num)&#123;</span><br><span class="line">      take(num);</span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::add(int num) const&#123;</span><br><span class="line">      take(num);</span><br><span class="line">  &#125;</span><br><span class="line">  void Apple::take(int num) const</span><br><span class="line">  &#123;</span><br><span class="line">      cout&lt;&lt;&quot;take func &quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::getCount() const</span><br><span class="line">  &#123;</span><br><span class="line">      take(1);</span><br><span class="line">  //    add(); //error</span><br><span class="line">      return apple_number;</span><br><span class="line">  &#125;</span><br><span class="line">  int main()&#123;</span><br><span class="line">      Apple a(2);</span><br><span class="line">      cout&lt;&lt;a.getCount()&lt;&lt;endl;</span><br><span class="line">      a.add(10);</span><br><span class="line">      const Apple b(3);</span><br><span class="line">      b.add(100);</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  //编译： g++ -o main main.cpp apple.cpp</span><br><span class="line">  //结果</span><br><span class="line">  take func 1</span><br><span class="line">  2</span><br><span class="line">  take func 10</span><br><span class="line">  take func 100</span><br><span class="line">     </span><br></pre></td></tr></table></figure><ul><li><p>getCount()中调用的add方法由于其非const修饰，所以会导致运行报错，即const对象只能访问const成员函数</p></li><li><p>而add调用了const修饰的take，证明了非ocnst对象可以访问任意的成员函数，包括const成员函数</p></li><li><p>add的一个重载函数，也输出了两个结果，说明const对象默认调用const成员函数</p></li></ul><p>还有其他方法能够初始化const常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line"><span class="comment">// 将常量定义与static结合</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h2><span id="static-那些事">static 那些事</span></h2><p>当与不同类型一起使用时，static含义不同：</p><ul><li>静态变量：函数中的变量，类中的变量</li><li>静态类的成员：类对象和类中的函数（类的实例是类对象）</li></ul><p>具体用法：</p><h3><span id="静态变量">静态变量</span></h3><h4><span id="1-函数中的静态变量">1 函数中的静态变量</span></h4><p>当变量声明为static时，空间将在<strong>程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。这对于在C/C++或需要存储先前函数状态的任何其他应用程序非常有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// static variable </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// value is updated and </span></span><br><span class="line">    <span class="comment">// will be carried to next </span></span><br><span class="line">    <span class="comment">// function calls </span></span><br><span class="line">    count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)  </span><br><span class="line">        <span class="built_in">demo</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output： 0 1 2 3 4 </span></span><br></pre></td></tr></table></figure><p>可以看出static变量的值是通过函数调用来传递。每次调用的时候不会对该变量进行初始化。</p><h4><span id="2-类中的静态变量">2 类中的静态变量</span></h4><p>由于声明为static的变量只被初始化一次，因为他们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>，对于不同的对象，不能有相同静态变量的多个副本。因此，静态变量不能使用构造函数初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Apple</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">Apple obj1; </span><br><span class="line">Apple obj2; </span><br><span class="line">obj1.i =<span class="number">2</span>; </span><br><span class="line">obj2.i = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// prints value of i </span></span><br><span class="line">cout &lt;&lt; obj1.i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;obj2.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个无法通过编译，因为i并没有初始化。因此，类中的静态变量应由用户使用的类外的类名和范围解析运算符显示初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">class Apple </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">    static int i; </span><br><span class="line"></span><br><span class="line">    Apple() </span><br><span class="line">    &#123; </span><br><span class="line">        // Do nothing </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line">int Apple::i = 0; // 显式初始化静态变量</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    Apple obj1; </span><br><span class="line">    Apple obj2; </span><br><span class="line"></span><br><span class="line">    // 对静态变量进行赋值</span><br><span class="line">    Apple::i = 2; </span><br><span class="line"></span><br><span class="line">    // 输出静态变量的值</span><br><span class="line">    cout &lt;&lt; Apple::i &lt;&lt; endl; // 输出: 2</span><br><span class="line">    cout &lt;&lt; obj1.i &lt;&lt; endl;    // 输出: 2</span><br><span class="line">    cout &lt;&lt; obj2.i &lt;&lt; endl;    // 输出: 2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="静态成员">静态成员</span></h3><h4><span id="类对象为静态">类对象为静态</span></h4><p>就像变量一样，对象也在声明为static时具有范围，知道程序的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">Apple</span>() </span><br><span class="line">        &#123; </span><br><span class="line">            i = <span class="number">0</span>; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside Constructor\n&quot;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">Apple</span>() </span><br><span class="line">        &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside Destructor\n&quot;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        Apple obj; </span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>其中Apple()为构造函数，在对象创建时被调用，用于初始化对象的成员变量，分配资源等操作</li><li>~Apple()为析构函数，在对象被销毁时自动调用，用于清理对象使用的资源，释放内存等。</li><li>对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用</li></ul><p>如果改为了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">static</span> Apple obj; </span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>则析构函数的输出坏在main结束后调用析构函数。</p><h4><span id="类中的静态函数">类中的静态函数</span></h4><p>类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和 <code>.</code> 来调用静态用户函数。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，他们无法访问类的非静态数据成员或成员函数</p><hr><h2><span id="this-指针那些事">this 指针那些事</span></h2><p>python里的self类比到c++中就是this指针。</p><p>this 指针的用处：</p><ol><li>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(object)的结果</li><li>this作用域是在类内部，在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使没有写上this指针，编译器在编译时也是加上this的，他作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</li></ol><p>其次，使用如下：</p><ol><li>在类的非静态成员函数中返回类对象本身的时候，直接使用 <code>return *this</code></li><li>当参数与成员变量名相同时，如 <code>this-&gt;n = n</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">        BOY = <span class="number">0</span>, </span><br><span class="line">        GIRL </span><br><span class="line">    &#125;SexType;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">char</span> *n, <span class="type">int</span> a,SexType s)&#123;</span><br><span class="line">        name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name,n);</span><br><span class="line">        age=a;</span><br><span class="line">        sex=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">add_age</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        age+=a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    SexType sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">20</span>,Person::BOY)</span></span>; </span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">get_age</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">add_age</span>(<span class="number">10</span>).<span class="built_in">get_age</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在类中，与类名相同的函数是构造函数，例子中的Person(char *n, int a,SexType s)就是构造函数</li><li><code>&amp;</code>符号用于声明引用，它允许我们在不复制对象的情况下对对象进行操作。<code>p.add_age(10).get_age()</code>就是很好的例子</li><li><code>public</code>与 <code>private</code>是用于控制类成员访问权限的关键字<ul><li><code>public</code>意味着这些成员可以在类的外部和内部访问</li><li><code>private</code>的成员只能在类的内部访问</li></ul></li><li>通过断点查看，发现编译器会为我们的this指针自动加上 <code>A* const</code> 而不是 <code>A const *</code>，即指向A对象的常指针，这样限定了指针的地址无法变化。</li><li>如果是const函数，则会将this指针变为 <code>const A* const</code></li></ul><h2><span id="inline-那些事">inline 那些事</span></h2><h3><span id="类中关联">类中关联</span></h3><p>头文件中声明方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param x</span></span><br><span class="line"><span class="comment">     * @param y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">///&lt; 定义即隐式内联函数！</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">///&lt; 声明后，要想成为内联函数，必须在定义处加inline关键字。  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Foo()函数被声明在类内部，没有显示使用 <code>inline</code>关键字来修饰，这种情况下被视为隐式内联函数。</li><li>隐式内联函数与由<code>inline</code>声明的显示内联函数的区别在于编辑器是否强制内联函数的决定权。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @param y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">// 函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处加inline关键字，推荐这种写法！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::f1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">Foo</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译器对 inline 函数的处理步骤</span></span><br><span class="line"><span class="comment"> * 将 inline 函数体复制到 inline 函数调用点处；</span></span><br><span class="line"><span class="comment"> * 为所用 inline 函数中的局部变量分配内存空间；</span></span><br><span class="line"><span class="comment"> * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</span></span><br><span class="line"><span class="comment"> * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>内联能提高函数效率，但并不是所有函数都定义成内联函数！内联是以代码膨胀为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p><ul><li>如果执行函数内代码的时间相比于函数调用的开销较大，那么效率的收获会更少</li><li>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大， 消耗更多的内存空间。</li></ul><p>以下情况不宜用内联：</p><ul><li>如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高</li><li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li><li>比较复杂的函数或者某些情况下（递归函数）可能无法内联展开</li></ul><blockquote><p>GOTO 是一种在编程中用于控制程序流程的语句，允许将程序跳转到指定的位置。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string userInput;</span><br><span class="line">    </span><br><span class="line">    start:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Do you want to continue? (yes/no): &quot;</span>;</span><br><span class="line">    cin &gt;&gt; userInput;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userInput == <span class="string">&quot;yes&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Continuing...\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 执行相关操作</span></span><br><span class="line">        <span class="keyword">goto</span> start; <span class="comment">// 跳转到标签 start 处</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userInput == <span class="string">&quot;no&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Exiting...\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid input. Please enter &#x27;yes&#x27; or &#x27;no&#x27;.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> start; <span class="comment">// 如果输入不是 &#x27;yes&#x27; 或 &#x27;no&#x27;，重新询问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用GOTO容易导致程序的逻辑难以理解和维护，实际编程中，尽量少使。。。</p><h2><span id="虚函数-virtual-可以是-内联函数-inline-吗">虚函数 virtual 可以是 内联函数 inline 吗？</span></h2><blockquote><p>虚函数 virtual function </p><p>是一种特殊的成员函数，它可以在派生类中被重写（覆盖）以提供特定于派生类的实现。虚函数通过在基类中使用关键字‘virtual’来声明，而在派生类中使用相同的函数签名来重写。</p><p>虚函数的存在使得在基类指针或引用指向派生类对象时，可以根据实际指向的对象类型来调用相应的函数实现，而不是根据指针或引用的静态类型来确定调用哪个函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;obj1;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Base class</span></span><br><span class="line"></span><br><span class="line">    ptr = &amp;obj2;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>虚函数可以是内联函数，内联时可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行调用哪个代码，因此虚函数表现为多态性时不可以内联</li><li><code>inline virtual</code>唯一可以内联的时候是：编译器知道所调用的是哪个类，这只有编译器具有实际对象而不是对象的指针或引用时才会发生</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2><span id="sizeof-那些事">Sizeof 那些事</span></h2><ul><li>空类的大小为1byte</li><li>一个class中，virtual function 、成员函数、静态数据成员都是不占用类对象的存储空间</li><li>对于包含虚函数的类，不管有多少虚函数，只有一个虚指针， vptr的大小</li><li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li><li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。32位 4byte; 64bit 8byte</li><li>虚继承，继承基类的vptr</li></ul><blockquote><p>具体的代码实例先不展示，对于密码学竞赛的帮助应该不是特别大</p></blockquote><h2><span id="纯虚函数和抽象类那些事">纯虚函数和抽象类那些事</span></h2><h3><span id="纯虚函数与抽象类">纯虚函数与抽象类</span></h3><p>C++中的纯虚函数或抽象函数是我们没有实现的虚函数，我们只需声明他。通过声明中赋值0来声明纯虚函数！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供了 draw() 的具体实现</span></span><br><span class="line">        <span class="comment">// 这里是绘制一个圆的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供了 draw() 的具体实现</span></span><br><span class="line">        <span class="comment">// 这里是绘制一个正方形的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其中Shape是一个抽象类，draw()是一个纯虚函数，因此Shape不能被实例化，只能被用作派生类的基类</li><li>如果它的派生类不是抽象类，则必须提供纯虚函数的实现</li><li></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file pure_virtual.cpp</span></span><br><span class="line"><span class="comment"> * @brief 纯虚函数：没有函数体的虚函数</span></span><br><span class="line"><span class="comment"> * 抽象类：包含纯虚函数的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 1. 抽象类只能作为基类来派生新类使用</span></span><br><span class="line"><span class="comment">   * 2. 抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  A a; <span class="comment">// error 抽象类，不能创建对象</span></span><br><span class="line"></span><br><span class="line">  A *a1; <span class="comment">// ok 可以定义抽象类的指针</span></span><br><span class="line"></span><br><span class="line">  A *a2 = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// error, A是抽象类，不能创建对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="实现抽象类">实现抽象类</span></h3><p>抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。</p><p>如果一个类从抽象类派生而来，他必须实现了基类中的<strong>所有</strong>纯虚函数，才能成为非抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file abstract.cpp</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * 抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数</span></span><br><span class="line"><span class="comment"> * 如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">f</span>(); &#125;</span><br><span class="line">  <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B:f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">g</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="重要点">重要点</span></h3><ul><li>纯虚函数使一个类变成抽象类</li><li>抽象类类型的指引和引用</li><li>如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类</li><li>抽象类可以有构造函数</li><li>构造函数不能是虚函数，而析构函数可以是虚析构函数</li></ul><p>当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。如果析构函数不是虚拟的，则只能调用基类析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file derived_full.cpp</span></span><br><span class="line"><span class="comment"> * @brief 完整示例！抽象类由派生类继承实现！</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun() called&quot;</span>; &#125; <span class="comment">// 实现了fun()函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  Derived d;</span><br><span class="line">  d.<span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="vptr与vtable那些事">Vptr与vtable那些事</span></h2><h3><span id="基础理论">基础理论</span></h3><p>为了实现虚函数，C++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表时用于解决在动态/后期绑定方法的函数调用函数的查找表。虚拟表有时会使用其他名称，例如’vtable’，’虚函数表’，’虚方法表’，’调度表’</p><p>虚拟表实际上非常简单，虽然用文字描述有点复杂。</p><p>首先，每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p><p>其次，编译器还会添加一个隐藏指向基类的指针，称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。</p><p>因此，它使每个类对象的分配大一个指针的大小。这意味着vptr由派生类继承。</p><h3><span id="实现与内部结构">实现与内部结构</span></h3><p>调用图：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231009203842470.png" alt="image-20231009203842470"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file vptr1.cpp</span></span><br><span class="line"><span class="comment"> * @brief C++虚函数vptr和vtable</span></span><br><span class="line"><span class="comment"> * 编译：g++ -g -o vptr vptr1.cpp -std=c++11</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 派生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Derived::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DerivedClass::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取vptr地址与func地址,vptr指向的是一块内存，这块内存存放的是虚函数地址，这块内存就是我们所说的虚表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> * @param offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Fun <span class="title">getAddr</span><span class="params">(<span class="type">void</span>* obj,<span class="type">unsigned</span> <span class="type">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">void</span>* vptr_addr = (<span class="type">void</span> *)*(<span class="type">unsigned</span> <span class="type">long</span> *)obj;  <span class="comment">//64位操作系统，占8字节，通过*(unsigned long *)obj取出前8字节，即vptr指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vptr_addr:%p\n&quot;</span>,vptr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通过vptr指针访问virtual table，因为虚表中每个元素(虚函数指针)在64位编译器下是8个字节，因此通过*(unsigned long *)vptr_addr取出前8字节，</span></span><br><span class="line"><span class="comment">     * 后面加上偏移量就是每个函数的地址！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>* func_addr = (<span class="type">void</span> *)*((<span class="type">unsigned</span> <span class="type">long</span> *)vptr_addr+offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func_addr:%p\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="keyword">return</span> (Fun)func_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base ptr;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pt = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类实例</span></span><br><span class="line">    Base &amp;pp = ptr; <span class="comment">// 基类引用指向基类实例</span></span><br><span class="line">    Base &amp;p = d; <span class="comment">// 基类引用指向派生类实例</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象直接调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ptr.<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象调用基类实例&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pp.<span class="built_in">fun1</span>(); </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类指针指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pt-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类引用指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动查找vptr 和 vtable</span></span><br><span class="line">    Fun f1 = <span class="built_in">getAddr</span>(pt, <span class="number">0</span>);</span><br><span class="line">    (*f1)();</span><br><span class="line">    Fun f2 = <span class="built_in">getAddr</span>(pt, <span class="number">1</span>);</span><br><span class="line">    (*f2)();</span><br><span class="line">    <span class="keyword">delete</span> pt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>纯虚函数与虚函数的区别</p><ol><li>定义：<ul><li>虚函数是在基类中声明并被定义的函数，它可以在派生类中被重写以提供特定于派生类的实现</li><li>纯虚函数是在基类中声明但没有提供具体实现的函数，它以 <code>=0</code>结尾，要求派生类必须提供自己的实现</li></ul></li><li>实现：<ul><li>虚函数在基类中可以有一个默认的实现，纯虚函数没有</li></ul></li><li>基类实例化：<ul><li>虚函数对应的基类可以实例化，纯虚函数的不可以</li></ul></li><li>派生类实现：<ul><li>虚函数可以选择是否在派生类中重写</li><li>纯虚函数必须重写，否则派生类也为抽象类</li></ul></li><li>多继承<ul><li>如果一个类继承自多个含有同名虚函数的基类，他将继承所有这些虚函数，但只有一个实现会被调用，具体实现哪个取决于编译器和程序的实际实现          </li><li>纯虚函数，如果一个类继承自多个含有同名纯虚函数的基类，它必须提供所有这些纯虚函数的实现</li></ul></li></ol></blockquote><p>函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*ptr)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 声明一个函数指针 ptr，该指针指向一个接受两个整数参数并返回整数的函数</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">基类对象直接调用</span><br><span class="line">Base::fun1()</span><br><span class="line">基类引用指向派生类实例</span><br><span class="line">Base::fun1()</span><br><span class="line">基类指针指向派生类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">基类引用指向基类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x401130</span><br><span class="line">func_addr:0x400ea8</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x401130</span><br><span class="line">func_addr:0x400ed4</span><br><span class="line">DerivedClass::fun2()</span><br></pre></td></tr></table></figure><p>c++的动态多态性使通过虚函数来实现的，通过virtual函数，指向子类的基类指针可以调用子类的函数。</p><p>过程解析：首先程序识别出fun1()是个虚函数，其次程序使用pt-&gt;vptr来获取Derived的虚拟表。第三，他查找Derived虚拟表中调用哪个版本的fun1()。</p><blockquote><p>gdb调试的方式要进行加强。</p></blockquote><h2><span id="virtual那些事">virtual那些事</span></h2><h3><span id="虚函数与运行多态">虚函数与运行多态</span></h3><p>虚函数的调用取决于指向或者引用的对象的类型，而不是指针或自身的类型。</p><h3><span id="虚函数中默认参数">虚函数中默认参数</span></h3><p>默认参数是静态绑定的，虚函数是动态绑定的，默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x = <span class="number">20</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    Base* ptr1 = &amp;obj1;</span><br><span class="line">    Base* ptr2 = &amp;obj2;</span><br><span class="line"></span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Base class: 10</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived class: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>override</code> 用于显式告诉编译器，某个成员函数是意图覆盖基类中的虚函数。</p></blockquote><ol><li><p>静态函数不可以声明为虚函数，同时也不能被const volatile关键字修饰</p><ul><li>static成员函数不属于任何类对象或类实例</li></ul></li><li><p>构造函数不可以声明为虚函数，除了inline explicit之外，构造函数不允许任何关键字</p></li><li><p>析构函数可以为虚函数</p><ul><li>如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。</li></ul></li><li><p>虚函数</p><blockquote><ol><li>基类和继承类的访问控制：<ul><li>基类和继承类的访问控制可以分为 <code>public</code>、 <code>protected</code> 、<code>private</code>。这些访问修饰符决定了类的成员对于类的外部的可见性。</li><li>如果将基类声明为 <code>public</code> 继承，派生类继承了基类的 <code>public</code>成员，但这些成员在派生类中的访问权限保持不变</li><li>如果将基类声明为 <code>private</code>继承，也同样</li></ul></li><li>友元函数：<ul><li>友元函数是一个不属于类的成员函数，但他可以访问该类的私有成员。通常情况下，友元函数会在类的外部进行声明</li><li>如果在 <code>base</code>类中声明 <code>int main()</code>为友元函数，那就意味着 <code>main</code>可以访问 <code>base</code>的私有成员</li></ul></li></ol></blockquote></li><li><p>通过基类指针或者引用调用的虚函数不能被内联，实体对象</p></li></ol><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="volatile-那些事">volatile 那些事</span></h2><p>被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。这些可观测的副作用时由程序之外的因素决定的。</p><h3><span id="volatile应用">volatile应用</span></h3><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="assert-那些事">assert 那些事</span></h2><p>断言，是宏，而非函数。</p><p>assert作用是如果它的条件返回错误，则终止程序执行。</p><p>可以通过定义NDEBUG来关闭assert，但是需要在源代码的开头，include之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(<span class="type">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure><h3><span id="断言与正常错误处理">断言与正常错误处理</span></h3><p>断言主要用于检查逻辑上不可能的情况。他们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用</p><p>在代码开头加上</p><blockquote><h1><span id="define-ndebug-加上这行则-assert-不可用">define NDEBUG   // 加上这行，则 assert 不可用</span></h1></blockquote><h2><span id="位域那些事">位域那些事</span></h2><p><code>bit field</code>是一种数据结构，可以把数据以位的形式紧凑的存储，并允许程序员对此结构的位进行操作。</p><p>优点：</p><ol><li>可以是数据单元节省储存空间</li><li>bit field 可以很方便的访问一个整数值的部分内容从而简化源代码。</li></ol><p>缺点：</p><ul><li>实现以来具体的机器和系统，本质上不可移植</li></ul><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="extern-那些事">extern 那些事</span></h2><blockquote><p>允许在同一作用域中的某个函数和运算符指定多个定义，分别成为函数重载和运算符重载</p></blockquote><p>在同一个作用域中，可以声明几个功能相似的同名函数，但是这些同名函数的<strong>形式参数必须不同</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="type">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载的运算符是带有特殊名称的函数，函数名是由关键字operator和其后要重载的运算符符号构成的。重载运算符有一个返回类型和一个参数列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果是非成员函数，则需要传递两个参数。</p><h3><span id="可重载运算符">可重载运算符</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231010230712173.png" alt="image-20231010230712173"></p><h3><span id="c调用c函数">C++调用C函数</span></h3><p>引用C的头文件时，需要加 <code>extern &quot;C&quot;</code></p><p>编译的时候要注意，先通过gcc将.c文件生成中间文件.o</p><p>然后通过g++进行编译</p><h3><span id="c中调用c">C中调用C++</span></h3><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="struct-那些事">struct 那些事</span></h2><h3><span id="c中的struct">C中的struct</span></h3><ul><li>C中struct只单纯的用作数据的复合类型，结构体声明中只能够将数据成员放在其中，而函数不能</li><li>C结构体声明中不能使用C++访问修饰符，public protected private</li><li>C的结构体不能继承</li><li>若结构体的名字与函数名相同，可以正常运行且正常的调用</li></ul><h3><span id="c中的struct">C++中的struct</span></h3><ul><li>可以定义数据与函数</li><li>可以使用修饰符</li><li>使用可以不带struct</li><li>c++继承</li><li>若结构体名字与函数名相同，可以正常运行且正常的调用，定义结构体变量时只用带struct的</li></ul><ol><li>使用typedef定义结构体别名时函数与别名不能相同</li><li></li></ol><h2><span id="实现多态那些事">实现多态那些事</span></h2><ul><li>封装：使用函数指针把属性和方法封装到结构体中</li></ul><h2><span id="explicit-那些事">explicit 那些事</span></h2><p><a href="https://stackoverflow.com/questions/4600295/what-is-the-meaning-of-operator-bool-const">https://stackoverflow.com/questions/4600295/what-is-the-meaning-of-operator-bool-const</a></p><h2><span id="friend那些事">friend那些事</span></h2><h2><span id="模板那些事">模板那些事</span></h2><blockquote><p>教程：<a href="https://www.jianshu.com/p/70ca94872418">C++类模板，你看我就够了 - 简书 (jianshu.com)</a></p></blockquote><h3><span id="基础的类模板">基础的类模板</span></h3><p>类模板，可以定义相同的操作，拥有不同数据类型的成员属性。</p><p>通常使用 <code>template</code> 来声明，告诉编译器，碰到 <code>T</code> 不要报错，表示一种泛型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    Complex&lt;T&gt; <span class="keyword">operator</span>+(Complex &amp;c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a+c.a, <span class="keyword">this</span>-&gt;b+c.b)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对象的定义，必须声明模板类型，因为要分配内容</span></span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;  </span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    Complex&lt;<span class="type">int</span>&gt; c = a + b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第三周学习日志</title>
      <link href="/2023/09/22/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/22/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="第一章-绪论">第一章 绪论</span></h1><h2><span id="11-数据库系统概述">1.1 数据库系统概述</span></h2><p>数据库是一种计算机辅助管理数据的方法与技术，研究如何有效地<strong>组织和存储数据</strong>，如何高效地<strong>获取和处理数据</strong></p><h3><span id="111-数据库的4个基本概念">1.1.1 数据库的4个基本概念</span></h3><h4><span id="1-数据-data">① 数据 Data</span></h4><p>数据是数据库中存储的基本对象</p><h5><span id="definition"><strong>Definition</strong></span></h5><p>是描述事物的符号记录，是可识别的、抽象的符号</p><h5><span id="categories"><strong>Categories</strong></span></h5><ul><li><p>结构化</p><ul><li><p>可以使用关系型数据库表示和存储，表现为规范的二维表格形式的数据</p></li><li><blockquote><person><name>A</name><age>13</age></person></blockquote></li></ul></li><li><p>半结构化</p><ul><li><p>结构化数据的一种形式，并不符合关系数据模型结构，但包括相关标记来分割语义元素，并对记录和字段进行分层</p></li><li><p>自描述的结构</p></li><li><blockquote><p>XML、JSON格式数据</p></blockquote></li></ul></li><li><p>非结构化</p><ul><li>文档、图片、视频等</li></ul></li></ul><h5><span id="another-definition"><strong>Another definition</strong></span></h5><p>​    使用约定俗成的关键字，对客观事物的数量、属性、状态、位置及其相互关系进行抽象表示，以适合在特定领域中用人工或自然的方式进行保存、传递和处理。</p><h5><span id="信息">信息</span></h5><p><strong>Definition</strong></p><ul><li>具有<strong>时效性</strong>，有一定含义的，有逻辑的、经过<strong>加工处理</strong>的、对决策有价值的<strong>数据流</strong>。</li><li><strong>信息 = 数据 + 处理</strong></li></ul><h5><span id="数据与信息">数据与信息</span></h5><ul><li>数据是信息的符号表示，或称载体；</li><li>信息是数据的内涵，是数据的语义解释；</li><li><strong>数据是符号化的信息</strong></li><li><strong>信息是语义化的数据</strong></li></ul><h5><span id="知识">知识</span></h5><p><strong>Definition</strong></p><ul><li>对消息进行<strong>归纳、演绎、比较</strong>等手段进行挖掘，使其有价值的部分沉淀下来，并于现存的人类知识体系相结合，有价值的信息就转变为知识。</li><li>知识是从<strong>定量到定性</strong>的过程得以实现的、抽象的、逻辑的东西。</li><li>知识在数据与信息之上，因它更接近行动，与决策有关。</li></ul><h5><span id="数据挖掘">数据挖掘</span></h5><ul><li>从大量、不完全的、有噪声的、随机的、模糊的实际应用数据中提取有用信息和知识的过程</li><li>常用算法<ul><li>分类、聚类、回归、关联规则</li><li>异常检测、特征分析、变化和偏差分析</li></ul></li></ul><h4><span id="2-数据库">② 数据库</span></h4><p><strong>Definition</strong></p><p>长期<strong>存储在计算机内</strong>、<strong>有组织的</strong>、<strong>可共享</strong>的大量<strong>数据的集合</strong></p><p><strong>基本特征</strong></p><ul><li>数据按一定的<strong>数据模型</strong> <em>组织、描述和储存</em></li><li>可为各种<em>用户</em> <strong>共享</strong></li><li><strong>冗余度较小</strong></li><li><strong>数据独立性较高</strong></li><li>易扩展</li></ul><h4><span id="3-数据库管理系统">③ 数据库管理系统</span></h4><p><strong>Definition</strong></p><ul><li>用户与操作系统之间的一层数据管理软件</li><li>帮助用户<strong>定义、创建、维护、控制</strong>数据库访问的<em>软件系统</em></li><li>基础软件</li></ul><p><strong>用途</strong></p><ul><li>科学地<strong>组织和存储</strong>数据</li><li>高效地<strong>获取和维护</strong>数据</li></ul><p><strong>主要功能</strong></p><ul><li><strong>数据定义</strong>功能<ul><li>提供数据定义语言（DDL）</li><li>定义数据库中的数据对象</li></ul></li><li>数据<strong>组织、存储和管理</strong><ul><li><strong>分类</strong>组织、存储和管理各种数据</li><li><strong>确定</strong>组织数据的<strong>文件结构和存取方式</strong></li><li>实现数据之间的联系</li><li>提供<strong>多种存取方式提高存取效率</strong></li></ul></li><li><strong>数据操纵</strong>功能<ul><li>提供数据操纵语言（DML）</li><li>实现对数据库的基本操作：增删改查</li></ul></li><li>数据库的<strong>事务管理和运行管理</strong><ul><li>数据库在建立、运行和维护时，由<strong>DBMS统一管理和控制</strong></li><li>保证数据的<strong>安全性、完整性</strong>；支持多用户对数据的<strong>并发使用</strong></li><li>发生故障后的<strong>系统数据恢复</strong>（自动、手动）</li></ul></li><li>数据库的<strong>建立和维护功能</strong><ul><li>数据库初始化：初始数据的装载和转换</li><li>数据库备份、转储、恢复功能</li><li>数据库的重组织</li><li>性能监控等</li></ul></li><li>其他功能</li></ul><h4><span id="4-数据库系统">④ 数据库系统</span></h4><p>Database System, DBS</p><p><strong>系统构成</strong></p><ul><li>数据库</li><li>DBMS</li><li>Application</li><li>DB Administrator</li></ul><p><strong>常见管理信息系统</strong>（MIS）架构</p><ul><li>Client/Server(C/S)架构<ul><li>通常是2层架构</li><li>胖客户端</li></ul></li><li>Browser/Server(B/S)架构<ul><li>典型三层架构</li><li>瘦客户端</li></ul></li></ul><p>架构的分层目的</p><ul><li>Flexibility：灵活</li><li>Maintainability：可维护</li><li>Reusability：可重用</li><li>Scalability：可扩展性</li></ul><p>Layer：逻辑功能分层，上下层之间由接口支撑关系</p><p>Tier：Layer的物理实现，可独立物理部署，一个Tier可包括多个Layer</p><p><strong>数据库系统特点</strong></p><ol><li><strong>数据结构化</strong><ul><li><strong>数据库的整体结构化</strong>是数据库的主要特征之一</li><li><strong>数据用数据模型描述</strong>，无需应用程序定义</li></ul></li><li>数据的<strong>共享性高，冗余度低</strong>且易扩充</li><li><strong>数据独立性高</strong><ul><li>物理独立性</li><li>逻辑独立性</li><li>数据独立性由DBMS的二级映像功能保证</li></ul></li><li>数据由DBMS<strong>统一管理和控制</strong><ul><li>数据控制功能<ul><li>安全性保护</li><li>完整性检查</li><li>并发控制</li><li>数据库恢复</li></ul></li></ul></li></ol><h2><span id="12-数据模型">1.2 数据模型</span></h2><ul><li><strong>对现实世界数据特征的抽象</strong></li><li>应满足三方面要求<ul><li>能比较<strong>真实地模拟现实世界</strong></li><li>容易为人所理解</li><li>便于在<strong>计算机上实现</strong></li></ul></li><li>是数据库系统的<strong>核心和基础</strong></li></ul><h3><span id="121-两大类数据模型">1.2.1 两大类数据模型</span></h3><p>数据模型分为两类</p><ol><li><strong>概念模型</strong><ul><li>信息模型，它是按<strong>用户的观点</strong>来对数据和信息建模</li></ul></li><li><strong>逻辑模型和物理模型</strong><ul><li>逻辑模型是按<strong>计算机的观点</strong>对数据建模，建立的是具体应用的数据库结构，用于DBMS实现，但不依赖具体的数据库软件厂商和版本。主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型。</li><li>物理模型是<strong>对数据最底层的抽象</strong>，数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法。</li></ul></li></ol><p>客观对象的抽象过程-<strong>两部抽象</strong></p><ol><li>将客观对象抽象成概念模型</li><li>将概念模型转换为某一数据库管理系统支持的数据模型</li></ol><p>数据建模是业务需求理解和概念抽象的过程</p><p>抽象过程：<strong>理解-区分-命名-表达</strong></p><p>数据建模的三个层次/阶段：</p><ol><li>概念模型</li><li>逻辑建模</li><li>物理建模</li></ol><h3><span id="122-概念模型">1.2.2 概念模型</span></h3><p><strong>用途</strong></p><ul><li><strong>用于信息世界的建模</strong></li><li><strong>设计人员和用户之间交流的语言</strong></li></ul><p><strong>基本要求</strong></p><ul><li>较强的语义表达能力</li><li>反应<strong>业务</strong>逻辑，<strong>用客户的述语描述</strong></li><li>简单、清晰、<strong>易于用户理解</strong></li></ul><p>概念模型的一种表示方法：</p><ul><li>实体-联系方法<ul><li>用E-R图来描述现实世界的概念模型</li></ul></li></ul><p>基本概念</p><ol><li>实体（Entity）：可以是具体的或抽象的</li><li>属性（Attribute）：某一特性</li><li>码/键（Key）：<strong>唯一标识</strong></li><li>实体型（Entity Type）：用<strong>实体名及其属性名集合来抽象和刻画同类实体</strong></li><li>实体集（Entity Set）：同一类型<strong>实体的集合</strong></li><li>联系（Relationship）：<ul><li>现实世界中事物内部及事物之间的联系反应为class内部的联系和class之间的联系</li><li>class内部的联系通常是指attributes’ relationship</li><li>class之间的联系通常是指Entity Set Realationship</li><li>一对一、一对多、多对多</li></ul></li></ol><h3><span id="123-数据模型的组成要素">1.2.3 数据模型的组成要素</span></h3><ul><li>数据结构</li><li>数据操作</li><li>数据的完整性约束条件</li></ul><h4><span id="数据结构">数据结构</span></h4><p>数据模型的数据结构：描述数据库的组成对象，以及对象之间的联系，是对<strong>系统静态特性的描述</strong></p><h4><span id="数据操作">数据操作</span></h4><p>对数据库中各种对象的实例允许执行的操作的集合，<strong>包括操作及有关操作规则</strong></p><p>操作类型：</p><ul><li>查询 Select</li><li>更新<ul><li>插入 Insert</li><li>删除 Delete</li><li>修改 Update</li></ul></li></ul><h4><span id="数据完整性约束条件">数据完整性约束条件</span></h4><ul><li>一组完整性规则的集合</li><li>完整性规则：给定的数据模型中<strong>数据及其联系</strong>所具有的制约和依存关系</li><li>用以限定符合数据模型的数据库状态及其状态的变化，以保证数据的<strong>正确、有效和相容</strong></li></ul><p>完整性约束条件的定义：</p><p>规定必须遵守的、<strong>基本的、通用的</strong>完整性约束条件；提供定义完整性约束条件的机制，以反映<strong>具体应用</strong>所设计的数据必须遵守的特定的语义约束条件</p><h3><span id="124-常用的数据模型">1.2.4 常用的数据模型</span></h3><p>网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型。</p><h3><span id="125-层次模型">1.2.5 层次模型</span></h3><p>树形结构</p><p>结点双亲唯一、一对多的实体联系</p><h3><span id="126-网状模型">1.2.6 网状模型</span></h3><p>允许一个以上的结点无双亲、一个节点可以有多于一个的双亲</p><h3><span id="127-关系模型">1.2.7 关系模型</span></h3><p>逻辑结构是一张二维表</p><ul><li>关系 Relation 一个关系对应一张表（包括数据</li><li>元组 Tuple 一行</li><li>属性 Attribute</li><li>主键 Key</li><li>域 Domain 相同数据类型的值的集合</li><li>分量 Component 元组的一个属性值</li><li>关系模式 Relation Schema 对关系的结构描述</li></ul><p>关系必须是规范化的，满足一定的规范条件</p><ul><li>关系的每一个分量必须是一个不可分的数据项，<strong>不允许表中还有表</strong></li></ul><p>数据操作是<strong>集合</strong>操作，操作对象和操作结果都是关系</p><p>关系的完整性约束条件： </p><ol><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ol><h3><span id="13-数据库系统的结构">1.3 数据库系统的结构</span></h3><p>从<strong>数据库应用开发人员角度</strong>看，数据库系统通常采用<strong>三级模式结构</strong>，是数据库系统<strong>内部的系统结构</strong></p><p>从数据库<strong>最终用户角度</strong>来看，结构分为</p><ul><li>单用户结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-服务器</li></ul><p>模式 Schema</p><ul><li>逻辑结构和特征的描述</li><li>型的描述</li><li>反映的是数据的结构及其联系</li><li>模式相对稳定</li></ul><p>实例 Instance</p><p>反映数据库某一时刻的状态</p><h4><span id="132-三级模式结构">1.3.2 三级模式结构</span></h4><p><strong>模式</strong>（逻辑模式）</p><ul><li>全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据试图</li></ul><p><strong>一个数据库只有一个模式</strong></p><p>模式：数据库系统模式结构的中间层</p><p>模式的定义</p><ul><li>数据的<strong>逻辑结构</strong></li><li>数据之间的联系</li><li>数据有关的安全性、完整性要求</li></ul><p><strong>外模式</strong></p><ul><li>用户使用的<strong>局部数据的逻辑结构和特征的描述</strong></li><li>数据库用户的数据视图</li><li>介于应用域模式之间</li></ul><p><strong>内模式</strong></p><ul><li>数据物理结构和存储方式的描述</li><li>对用户半透明</li></ul><h4><span id="133-数据库的二级映像功能与数据独立性">1.3.3 数据库的二级映像功能与数据独立性</span></h4><ul><li>外模式/模式映像<ul><li>保证数据的逻辑独立性</li></ul></li><li>模式/内模式映像<ul><li>定义了数据全局逻辑结构与存储结构之间的对应关系</li><li>唯一</li><li>保证数据的物理独立性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理第三周学习日志</title>
      <link href="/2023/09/22/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/22/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>自然语言处理的导论</p><span id="more"></span><h2><span id="11-问题的提出">1.1 问题的提出</span></h2><ul><li>信息检索市场前景广阔</li><li>跨语言通信与信息获取</li><li>机器翻译市场需求大</li><li>舆情监测</li></ul><ol><li>如何让计算机实现自动的或人机互助的语言处理功能？</li><li>如何让计算机实现海量语言信息的自动处理、知识挖掘、有效利用？</li></ol><h2><span id="12-基本概念">1.2 基本概念</span></h2><h4><span id="def-1-1-language-语言">Def. 1-1 Language 语言</span></h4><p>人类所特有的用来表达意思、交流思想的工具，是一种特殊的社会现象，由<strong>语音</strong>、<strong>词汇</strong>和<strong>语法</strong>构成一定的系统。</p><h4><span id="def-1-2-linguistics-语言学">Def. 1-2 Linguistics 语言学</span></h4><p>对语言的科学研究。</p><p><strong>语音</strong>和<strong>文字</strong>是语言的两个基本属性</p><h4><span id="def-1-3-phonetics-语音学">Def. 1-3 Phonetics 语音学</span></h4><p> 研究人类发音特点，特别是语音发音特点，并提出各种语音描述、分类和转写方法的科学。</p><ul><li>发音语音学 (articulatory phonetics)</li><li>声学语音学 (acoustic phonetics)</li><li>听觉语音学 (auditory phonetics)</li></ul><p>综上可以看出语音学的分支非常广，那便将其视为复数的语言科学 (linguistic sciences)</p><h4><span id="def-1-4-natural-language-understanding-自然语言理解">Def. 1-4 Natural Language Understanding 自然语言理解</span></h4><p>微观上讲， 语言理解是指从自然语言到机器内部之间的一种映射；从宏观上讲，语言理解是指机器能够执行人类所期望的某些语言功能。</p><p>如何判断理解、计算机系统的智能呢？</p><ul><li>表现 act</li><li>反应 react</li><li>相互作用 interact</li><li>Turing Test</li></ul><h4><span id="def-1-5-natural-language-processing-自然语言处理">Def. 1-5 Natural Language Processing 自然语言处理</span></h4><p>研制表示语言能力 (linguistic competence) 和语言应用 (linguistic performance)的模型，建立计算框架来实现这样的语言模型，提出相应的方法来不断地完善语言模型，设计使用系统，并探讨测评技术。</p><h4><span id="def-1-6-computational-linguistics-计算语言学">Def. 1-6: Computational Linguistics 计算语言学</span></h4><p>用计算技术和概念来阐述语言学和语音学问题。</p><h4><span id="三个不同的语系">三个不同的语系</span></h4><ol><li>屈折语 fusional language / inflectional language, 用词的形态变化表示语法关系，英语、法语等</li><li>黏着语 agglutinative language 专门表示语法意义的附加成分， 日语等</li><li>孤立语/分析语 isolating / analytic language 形态变化少，语法关系靠语序和虚词表示，汉语</li></ol><h2><span id="13-nlp-的产生与发展">1.3 NLP 的产生与发展</span></h2><p>源于机器翻译 (Machine Translation, MT)</p><h2><span id="14-研究内容">1.4 研究内容</span></h2><p>按应用目标划分，广义上包括</p><ol><li>机器翻译 (Machine translation, MT)</li><li>信息检索 (Information retrieval)</li><li>自动文摘 (Automatic summarization/ Automatic abstracting)</li><li>问答系统 (Question-answering system)</li><li>信息过滤 (Information filtering)</li><li>信息抽取 (Information extraction)</li><li>文档分类 (Document categorization)</li><li>情感分类 (Sentimental classification)</li><li>文字编辑和自动校对 (Automatic proofreading)</li><li>语音教学 (Language teaching)</li><li>文字识别 (Character recognition)</li><li>语音识别 (automatic speech recognition, ASR)</li><li>文语转换/语音合成 (text-to-speech synthesis)</li><li>说话人识别/认同/验证 (speaker recognition/ identification/ verification)</li></ol><h2><span id="15-基本问题和主要困难">1.5 基本问题和主要困难</span></h2><h3><span id="基本问题一形态学问题morphology-problem">基本问题一：形态学问题(Morphology Problem)</span></h3><p>word由有意义的词素 morphemes 构成，包括屈折变化和构词法两部分</p><h3><span id="基本问题二语法学问题-syntax-problem">基本问题二：语法学问题 (Syntax Problem)</span></h3><h3><span id="基本问题三-语义学问题-semantics-problem">基本问题三： 语义学问题 (Semantics Problem)</span></h3><h3><span id="基本问题四语用学问题-pragmatics-problem">基本问题四：语用学问题 (Pragmatics Problem)</span></h3><h3><span id="基本问题五-语音学问题-phonetics-problem">基本问题五： 语音学问题 (Phonetics Problem)</span></h3><h3><span id="困难一大量歧义现象-ambiguity">困难一：大量歧义现象 (ambiguity)</span></h3><ul><li>词法歧义</li><li>词性歧义</li><li>结构歧义</li><li>语义歧义</li><li>语音歧义</li><li>多音字及韵律等歧义</li></ul><h3><span id="困难二大量未知语言现象">困难二：大量未知语言现象</span></h3><ul><li>新词、人名、地名、术语</li><li>新含义</li><li>新用法、句型</li></ul><h2><span id="16-基本研究方法">1.6 基本研究方法</span></h2><h3><span id="理性主义">理性主义</span></h3><p>语言知识来源：语言知识很大部分是由遗传决定的。</p><p>研究对象：语言知识结构</p><p>理论：基于Chomsky语言原则，通过语言所必须遵守的原则来描述语言</p><p>处理方法：特殊语句或语法现象</p><p>求解方法：基于规则的分析方法，建立符号处理系统</p><h3><span id="经验主义">经验主义</span></h3><p>语言知识来源：语言知识是通过感官输入，经过简单联想与通用化的操作而得到的</p><p>研究对象：实际的语言数据</p><p>理论：信息论</p><p>处理方法：统计</p><p>求解方法：基于大规模真实语料的计算方法</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weblog</title>
      <link href="/2023/09/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/weblog/"/>
      <url>/2023/09/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/weblog/</url>
      
        <content type="html"><![CDATA[<h2><span id="q1hexo-next-主题下博客中数学公式无法正常渲染">Q1：hexo next 主题下博客中数学公式无法正常渲染</span></h2><p>参考教程：<a href="https://blog.csdn.net/yexiaohhjk/article/details/82526604">https://blog.csdn.net/yexiaohhjk/article/details/82526604</a></p><h2><span id="q2hexo-下的分类和表签无法显示怎么解决">Q2：hexo 下的分类和表签无法显示，怎么解决？</span></h2><p>参考教程：<a href="https://www.zhihu.com/question/29017171">https://www.zhihu.com/question/29017171</a></p><h2><span id="q3-hexo-添加后台管理功能">Q3： hexo 添加后台管理功能</span></h2><p>参考教程：<a href="https://blog.csdn.net/smileyan9/article/details/86666824">https://blog.csdn.net/smileyan9/article/details/86666824</a></p><h2><span id="q4解决hexo图片无法导入问题">Q4：解决hexo图片无法导入问题</span></h2><p>参考教程：<a href="https://blog.csdn.net/weixin_42030522/article/details/123075824">解决Hexo无法显示图片的几种方案_hexo 图片-CSDN博客</a></p><h2><span id="q5解决hexo首页博客只显示摘要部分">Q5：解决hexo首页博客只显示摘要部分</span></h2><p>参考教程：<a href="https://blog.csdn.net/yueyue200830/article/details/104470646">设置hexo首页只显示部分摘要（不显示全文）_hexo 摘要-CSDN博客</a></p><h2><span id="q6-hexo-next-github-pages-访问速度优化问题">Q6： hexo + Next + Github Pages 访问速度优化问题</span></h2><p>参考教程：<a href="https://zhuanlan.zhihu.com/p/33005841">加速访问基于 Github Pages 和 Hexo 的博客 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第三周学习日志</title>
      <link href="/2023/09/21/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/21/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>现代密码学基础——形式化定义、安全系统定义</p><span id="more"></span><h2><span id="principles-of-modern-crypto">Principles of Modern Crypto</span></h2><h3><span id="a-formal-definitions">A. Formal definitions</span></h3><blockquote><p>Precise, mathematical model and definition of what security means</p></blockquote><p>Definitions are essential for the design, analysis, and usage of crypto.</p><ul><li>Design: force the designer to think about what they really want.</li><li>Analysis: enable meaningful analysis, evaluation, and comparison of schemes</li><li>Usage: understand the security guarantees, modularity, substitute.</li></ul><h3><span id="b-assumptions">B. Assumptions</span></h3><blockquote><p>Clearly stated and unambiguous</p></blockquote><p><strong>Computational assumptions</strong></p><p>Principle: any such assumptions should be made explicit</p><ul><li>validate assumptions</li><li>meaningful comparison</li><li>practical implications</li></ul><h3><span id="c-proof-of-security">C. Proof of security</span></h3><blockquote><p>Move away from design-break-patch</p></blockquote><h2><span id="defining-secure-encryption">Defining Secure Encryption</span></h2><p>Crypto definitions (generally)</p><ul><li>Security guarantee/goal</li><li>Threat model<ul><li>ciphertext-only attack</li><li>known-plaintext attack</li><li>chosen-plaintext attack</li><li>chosen-ciphertext attack</li></ul></li></ul><h2><span id="perfect-secrecy">Perfect Secrecy</span></h2><h3><span id="informal-def">Informal def.</span></h3><p>Regardless of any prior information the attacker has about the plaintext, the ciphertext should leak no additional information about the plaintext.</p><h3><span id="basic-concepts">Basic concepts</span></h3><ul><li>Random variable (r.v.)</li><li>Event</li><li>Conditional probability</li><li>Law of total probability</li><li>$\mathcal{M}$ is plaintext space, $\mathcal{K}$ is key space, $\mathcal{C}$ is ciphertext space</li></ul><h3><span id="probability-distributions">Probability distributions</span></h3><p>characterize the probability distributions over key space</p><ul><li>r.v. M and K are independent</li></ul><script type="math/tex; mode=display">\ Encryption \ scheme \ with  \ \mathcal{M}  \ and \  \mathcal{C}, if \ for \ every \ distribution \ over \mathcal{M}, \\every \ m \in \mathcal{M}, and \ every \ c \in \mathcal{C}  \ with \  Pr[C=c] > 0, \  it \ holds \ that\\ Pr[M = m | C = c] = Pr[M = m]</script><h3><span id="equivalent-def">Equivalent Def</span></h3><script type="math/tex; mode=display">Pr[M=m | C=c ] = Pr[M=m]</script><script type="math/tex; mode=display">Pr[C=c | M=m] = Pr[C=c | M = m^{'}], \ i.e. \\Pr[Enc_K(m) = c] = Pr[Enc_K(m^{'}) = c]</script><script type="math/tex; mode=display">Pr[C=c | M=m] = Pr[C=c]</script><p><a href="https://www.cnblogs.com/TheFutureIsNow/p/11527610.html">密码学基础(二) - 完美保密 - Hang3 - 博客园 (cnblogs.com)</a></p><p>Perfectly secret and perfectly indistinguishable:</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，世界！</title>
      <link href="/2023/09/21/%E9%97%B2%E8%81%8A/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81/"/>
      <url>/2023/09/21/%E9%97%B2%E8%81%8A/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>这是我的<strong>第一篇</strong>博客，听说写一个独属于自己的博客最需要的便是坚持，而我相信我能行！</p><h2><span id="本站简介">本站简介</span></h2><p>我给我的网站起的名字叫暖火，想要表达的意思是向四周传播自己的光与热，我给我的网站定位是一个学习内容记录的学习性博客，在这里我会定期更新所有在学校学习内容的整理，一方面是作为复习，另一方面也是能够造福于大家，作为经常玩盗版游戏的我来说，开源精神弥足珍贵啦，哈哈。</p><p>我的文学素养有限，专业能力也在萌芽阶段，这篇hello,world一定不会是最终稿的，哈啊，我会再慢慢修改，让他更充实一点！</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
          <category> 建站理念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊档 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
