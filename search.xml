<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自然语言处理第六周学习日志</title>
      <link href="/2023/10/13/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/13/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01-概率论基础">0x01 概率论基础</span></h2><h3><span id="二项式分布">二项式分布</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013141054803.png" alt="image-20231013141054803"></p><p>自然语言处理中，一般以句子为处理单位。假设一个句子独立于它前面的其他语句，句子的概率分布近似认为符合二项式分布。</p><h3><span id="期望">期望</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013141209244.png" alt="image-20231013141209244"></p><h3><span id="方差">方差</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013141507936.png" alt="image-20231013141507936"></p><h2><span id="0x02-信息论基础">0x02 信息论基础</span></h2><h3><span id="熵">熵</span></h3><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第六周学习日志</title>
      <link href="/2023/10/11/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/11/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>对称加密</p><span id="more"></span><h2><span id="0x01-perfect-indistinguishability">0x01 Perfect Indistinguishability</span></h2><h2><span id="0x02-security-definition-of-encryption">0x02 Security Definition of Encryption</span></h2><h3><span id="definition-34-function-negligibility">Definition 3.4 function negligibility</span></h3><ul><li>A function $f : Z^+\rightarrow Z^+ $ is <strong>polynomical</strong> if there exists <em>c</em> such that $f(n) &lt; n^C$ for large enough <em>n</em> </li></ul><h3><span id="necessity-of-relaxations">Necessity of Relaxations</span></h3><ol><li>limit the time to defend the attack from an unbounded attacker</li><li>allow a very small probability of success to </li></ol><h3><span id="defintion-37-private-key-encryption-scheme">Defintion 3.7 Private-key encryption scheme</span></h3><h2><span id="0x03-eav-secure-encryption-schemes">0x03 EAV-Secure Encryption Schemes</span></h2><h2><span id="0x04-multiple-encryptions">0x04 Multiple Encryptions</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学竞赛代码记录</title>
      <link href="/2023/10/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AB%9E%E8%B5%9B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AB%9E%E8%B5%9B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>记录emp-ot的代码情况</p><span id="more"></span><h2><span id="论文伪代码">论文伪代码</span></h2><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012105749879.png" alt="image-20231012105749879"></p><p>表一：COT函数</p><p>$\Delta$由S生成</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012105916449.png" alt="image-20231012105916449"></p><p>表二：流程图</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110027949.png" alt="image-20231012110027949"></p><p>表三：SPCOT</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110243621.png" alt="image-20231012110243621"></p><p>表四：MPCOT </p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110340328.png" alt="image-20231012110340328"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110550394.png" alt="image-20231012110550394"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110646401.png" alt="image-20231012110646401"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231012110738103.png" alt="image-20231012110738103"></p><h2><span id="0x02-修改思路">0x02 修改思路</span></h2><p>将 <code>spcot_recver</code> <code>spcot_sender</code> <code>iknp</code>  <code>base_cot</code> <code>co</code> <code>cot</code>放入TCO</p><p>将 <code>mpcot_reg</code> ``</p><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
          <category> 密码学竞赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全协议第六周学习日志</title>
      <link href="/2023/10/10/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/10/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><p>形式化分析工具 <code>Scyther</code>的安全协议实例分析</p><p>可证明安全理论</p><span id="more"></span><h2><span id="0x01-scyther-工具简介">0x01 Scyther 工具简介</span></h2><p>用于自动验证安全协议的工具</p><h2><span id="0x02-scyther-使用方法">0x02 Scyther 使用方法</span></h2><h3><span id="描述语法">描述语法</span></h3><h2><span id="0x03-scyther-应用分析实例">0x03 Scyther 应用分析实例</span></h2><h1><span id="可证明安全理论">可证明安全理论</span></h1><h2><span id="不可区分性cpa">不可区分性CPA</span></h2><p>不可区分性 indistinguishability IND</p><p>0</p><h1><span id="比特承诺">比特承诺</span></h1><h2><span id="协议简介">协议简介</span></h2><h3><span id="基本思想">基本思想</span></h3><ul><li>Alice承诺者， Bob验证者</li><li>A发送给B一个证明</li></ul><p>两个阶段：承诺阶段、打开阶段</p><p>两个安全性质：隐藏性、绑定性</p><h2><span id="常用比特承诺协议">常用比特承诺协议</span></h2><h2><span id="协议应用">协议应用</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 安全协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第六周学习日志</title>
      <link href="/2023/10/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>前言</p><p>关系数据库标准语言SQL</p><span id="more"></span><h2><span id="31-sql概述">3.1 SQL概述</span></h2><ul><li>SQL Structured Query Language<ul><li>结构化查询语言，是关系数据库的标准语言</li></ul></li><li>SQL是一个通用的、功能极强的关系数据库语言</li></ul><h3><span id="311-sql的起源和发展">3.1.1 SQL的起源和发展</span></h3><h3><span id="312-sql语言">3.1.2 SQL语言</span></h3><ol><li>综合统一<ul><li>数据定义DDL、数据操纵DML、数据控制DCL功能于一体，还有事务控制语言TCL</li><li>Data Definition Language: Create/Alter/Drop—schema定义</li><li>Data Manipulation Language: Insert/Select/Update/Delete — 数据查询及修改</li><li>Data Control Language: Grant/Revoke—权限修改</li><li>Transaction Control Language: Begin Transaction/Commit/Rollback—数据修改的原子性</li><li>可以独立完成数据库生命周期中的全部活动</li><li>可根据需要随时逐步修改模式，不影响运行</li><li>数据操作统一</li></ul></li><li>高度非过程化</li><li>面向集合的做做方法</li><li>以同一种语法结构提供多种使用方法<ul><li>SQL独立语言</li><li>SQL嵌入式语言</li><li>更多的采用数据库驱动程序API</li></ul></li><li>语言简洁<ul><li>核心功能只用9个动词<ul><li>Create、Alter、Drop</li><li>Insert、Delete、Update、Select</li><li>Grant、Revoke</li></ul></li></ul></li></ol><h3><span id="313-sql基本概念">3.1.3 SQL基本概念</span></h3><ul><li>基本表<ul><li>本身独立存在的表</li><li>SQL中一个关系对应一个基本表</li><li>一个基本表对应一个存储文件</li><li>一个表可以有若干索引</li></ul></li><li>存储文件<ul><li>逻辑结构 schema 组成了关系数据库的模式</li><li>物理结构</li><li>文件路径和文件名可由用户配置或指定</li><li></li></ul></li><li>视图<ul><li>从一个或几个基本表通过查询而导出的表</li><li></li><li>视图是虚表</li><li></li></ul></li></ul><h2><span id="32-学生-课程数据库">3.2 学生-课程数据库</span></h2><ul><li>学生-课程模式 S-T：<ul><li>学生表：Student(Sno, Sname, Ssex, Sage, Sdept)</li><li>课程表：Course(Cno,Cname,Cpno,Ccredit)</li><li>学生选课表：SC(Sno,Cno,Grade)</li></ul></li></ul><h2><span id="33-数据定义">3.3 数据定义</span></h2><h3><span id> </span></h3><ul><li>SQL 的数据定义功能<ul><li>模式定义<ul><li>定义结构和命名空间</li><li>RDBMS提供了一个层次化的数据库对象命名机制</li></ul></li><li>表定义</li><li>视图和索引的定义</li></ul></li></ul><h3><span id="331-模式的定义与删除">3.3.1 模式的定义与删除</span></h3><h4><span id="定义模式">定义模式</span></h4><p>定义模式实际上定义了一个命名空间</p><p>The schema containing object can be table, column, data type, view, stored procedures, relationships, primary key, foreign key. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>SCHEMA_NAME<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>USER_NAME<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="删除模式">删除模式</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>SHEMA_NAME<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE<span class="operator">|</span>RESTRICT<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>CASCADE: 级联</li><li>RESTRICT：限制</li></ul><h4><span id="数据库连接的基本参数">数据库连接的基本参数</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013160605003.png" alt="image-20231013160605003"></p><p>Oracle授权：</p><blockquote><p>GRANT CONNECT,RESOURCE,DBA TO <user_name></user_name></p></blockquote><h3><span id="332-基本表的定义-删除与修改">3.3.2 基本表的定义、删除与修改</span></h3><ul><li><p>定义基本表</p><blockquote><p>CREATE TABLE &lt;表名&gt;</p><p>(&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;],&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;],…,[&lt;表级约束条件&gt;])    </p></blockquote><ul><li></li></ul></li></ul><ol><li>数据类型<ul><li>域的概念：SQL用数据类型来实现</li><li>定义表的属性时，需要指明其数据类型及长度</li><li>选用哪种数据类型<ul><li>物理意义与格式</li><li>取值范围</li><li>是否允许为空</li></ul></li><li>字符串类型</li><li>日期与时间类型</li></ul></li></ol><h4><span id="修改基本表">修改基本表</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161732128.png" alt="image-20231013161732128"></p><h4><span id="删除基本表">删除基本表</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161751823.png" alt="image-20231013161751823"></p><h3><span id="333-索引的建立与删除">3.3.3 索引的建立与删除</span></h3><ul><li>建立索引的目的：加快查询速度</li><li>常见索引<ul><li>顺序文件上的索引</li><li>B+树索引</li><li>hash索引</li><li>bitmap索引</li></ul></li></ul><h4><span id="建立索引">建立索引</span></h4><ul><li>数据库管理员或表的属主可以建立索引</li><li>关系数据库管理系统自动完成维护索引</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161837333.png" alt="image-20231013161837333"></p><h4><span id="修改索引">修改索引</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161852062.png" alt="image-20231013161852062"></p><h4><span id="删除索引">删除索引</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161909044.png" alt="image-20231013161909044"></p><h3><span id="334-数据字典">3.3.4 数据字典</span></h3><p>数据字典是关系数据库管理系统内部的一组系统表，记录了数据库中所有定义信息</p><h2><span id="34-数据查询">3.4 数据查询</span></h2><ul><li>语句格式</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013161932540.png" alt="image-20231013161932540"></p><h3><span id="341-单表查询">3.4.1 单表查询</span></h3><ol><li>选择表中若干列<ul><li>使用列别名改变查询结果的列标题</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013162507827.png" alt="image-20231013162507827"></li></ul></li><li>选择表中若干元组<ul><li>消除取值重复的行：指定DISTINCT关键字</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013162632798.png" alt="image-20231013162632798"></li><li>%代表任意长度的字符串</li><li>_代表任意单个字符</li><li>MySQL/Oracle缺省的转义字符是’\’</li><li>IS NULL 不能用 = 代替</li></ul></li><li>ORDER BY 子句<ul><li>ASC：升序（缺省）</li><li>DESC：降序</li></ul></li><li>聚集函数<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013163400697.png" alt="image-20231013163400697"></li></ul></li><li>GROUP BY子句<ul><li>分组：细化聚集函数的作用对象</li><li>按指定的一列或多列值分组，值相等的为一组</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231013164746552.png" alt="image-20231013164746552"></li><li>HAVING作用于组</li></ul></li></ol><p>COUNT(*)会统计NULL的记录数量</p><h3><span id="342-连接查询">3.4.2 连接查询</span></h3><h3><span id="343-嵌套查询">3.4.3 嵌套查询</span></h3><h3><span id="344-集合查询">3.4.4 集合查询</span></h3><h3><span id="345-基于派生表的查询">3.4.5 基于派生表的查询</span></h3><h3><span id="346-select语句的一般形式">3.4.6 Select语句的一般形式</span></h3><h2><span id="35-数据更新">3.5 数据更新</span></h2><h2><span id="36-空值的处理">3.6 空值的处理</span></h2><h2><span id="37-视图">3.7 视图</span></h2><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Environment Blog</title>
      <link href="/2023/10/08/Environment-Blog/"/>
      <url>/2023/10/08/Environment-Blog/</url>
      
        <content type="html"><![CDATA[<h2><span id="q1e-release-file-for-httpsmirrorstunatsinghuaeducnubuntudistsbionic-updatesinrelease-is-not-valid-yet-invalid-for-another-6h-46min-10s-updates-for-this-repository-will-not-be-applied">Q1：E: Release file for  is not valid yet (invalid for another 6h 46min 10s). Updates for this repository will not be applied.</span></h2><p>参考教程：<a href="https://askubuntu.com/questions/1096930/sudo-apt-update-error-release-file-is-not-yet-valid">sudo apt 更新错误：“发布文件尚未生效” - 询问 Ubuntu (askubuntu.com)</a></p><h2><span id="q2e-unable-to-correct-problems-you-have-held-broken-packages">Q2：E: Unable to correct problems, you have held broken packages.</span></h2><p>当apt破损时，可能的一个原因是由于 <code>/etc/apt/source.list</code>的源不是ubuntu 20.04的</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2><p><hr><br>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 实践知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习日志</title>
      <link href="/2023/10/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>0x00 前言</p><span id="more"></span><h2><span id="0x01">0x01</span></h2><h2><span id="0x02">0x02</span></h2><h2><span id="0x03">0x03</span></h2><h2><span id="0x04">0x04</span></h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Go学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络内容安全第五周学习日志PLUS</title>
      <link href="/2023/10/05/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97PLUS/"/>
      <url>/2023/10/05/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97PLUS/</url>
      
        <content type="html"><![CDATA[<h1><span id="文本挖掘文本分类算法">文本挖掘——文本分类算法</span></h1><h2><span id="1-评价指标">1 评价指标</span></h2><p>文本自动分类的定义：在给定的分类体系下，根据文本的内容自动地确定文本关联的类别。</p><p>从数学角度来看，文本分类是一个映射的过程，它将未标明类别的文本映射到已有的类别中，该映射可以是一一、一对多的映射</p><p>文本分类基本步骤：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005135232112.png" alt="image-20231005135232112"></p><p>评价指标</p><ul><li>准确率 P precision<ul><li>正确分类样本所占的比例</li></ul></li><li>召回率 R recall<ul><li>分母是所有真正的正类测试样本</li></ul></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140046034.png" alt="image-20231005140046034"></li><li>F-Measure<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140842378.png" alt="image-20231005140842378"></li></ul></li></ul><p>所有类的总体评价 </p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140913540.png" alt="image-20231005140913540"></p><p>宏平均 Macro</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140933313.png" alt="image-20231005140933313"></p><p>微平均 Micro</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005140957431.png" alt="image-20231005140957431"></p><h2><span id="2-特征选择">2 特征选择</span></h2><p>目的：</p><ul><li>避免过拟合 over fitting ，提高分类精确度<ul><li>对训练文档适应的很好，但是对训练集之外的文档差许多，则产生了over-fitting problem</li><li>希望表现对训练集和未知文档基本一致</li></ul></li><li>通过降维，大大节省计算空间和时间</li></ul><p>特征提取的方法</p><ul><li>文档概率法 DF document frequency</li><li>信息增益法 information gain</li><li>互信息法 mutual information </li><li>开方拟合检验 the $\chi ^ 2$ test</li></ul><p><strong>DF</strong></p><p>基于DF的启发式要点：</p><ul><li>太频繁的词项没有区分度<ul><li>Term的DF大于某个阈值则去掉</li></ul></li><li>太稀有的词项独立表达的类别信息不强<ul><li>稀有词项的全局影响力不大</li><li>在训练集中，某些文档如果有某个稀有词项，他们通常也会有一些常见词项</li></ul></li><li>和通常信息获取观念有些抵触：稀有的更有代表性？这个是只获取的观念是稀有的则更有代表性吗:cry:</li></ul><p><strong>RSJ</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005211538258.png" alt="image-20231005211538258"></p><h2><span id="3-分类算法">3 分类算法</span></h2><h3><span id="31-knn分类">3.1 KNN分类</span></h3><h3><span id="32-贝叶斯分类">3.2 贝叶斯分类</span></h3><h3><span id="33-svm分类">3.3 SVM分类</span></h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络内容安全第五周学习日志</title>
      <link href="/2023/10/05/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/05/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1><span id="文本挖掘文本预处理">文本挖掘——文本预处理</span></h1><h2><span id="1-文本挖掘的背景">1 文本挖掘的背景</span></h2><p>文本挖掘与数据挖掘的区别：</p><p>文本挖掘主要针对的是非结构话或半结构化的无确定形式且缺乏机器可理解的语义；</p><p>数据挖掘主要针对的是数据库中结构化的数据，并利用关系表等存储结构来发现知识。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005065448006.png" alt="image-20231005065448006"></p><h2><span id="2-分词">2 分词</span></h2><p><strong>文本特征预处理</strong></p><p>定义：文本特征指的是关于文本的元数据</p><p>分类：</p><ul><li>描述性特征：文本的名称、日期、大小、类型等</li><li>语义性特征：文本的作者、标题、机构、内容等</li></ul><p><strong>特征抽取</strong></p><ul><li>预处理<ul><li>洗掉html的tag标签</li><li>stop words 去除， 词根还原</li><li>中文的分词、词性标注、短语识别</li><li>词频统计 <ul><li>$TF_{i,j}$特征i在文档j中出现次数，词频</li><li>$DF_i$所有文档集合中出现特征i的文档数目，文档频率</li></ul></li></ul></li><li>文本表示：向量空间模型</li><li>降维技术<ul><li>特征选择</li><li>特征重构</li></ul></li></ul><p><strong>中文特征词的粒度</strong></p><ul><li>Character： 字</li><li>Word： 词</li><li>Phrase： 短语</li><li>Concept： 概念</li><li>N-gram： N元组</li><li>某种规律性模式</li></ul><p><strong>词语标记</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005072521009.png" alt="image-20231005072521009"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005073346665.png" alt="image-20231005073346665"></p><p><strong>词语标记算法</strong></p><ul><li>输入：一段文本</li><li>输出：单词串</li><li>算法：<ol><li>对一个待分析的字符串S，从左到右进行扫描，读入当前字符(char)到候选词数组(w[i])，并将指针前移, i++</li><li>看char是否为词分隔符</li><li>T: if W is not space, 将W从起始位置到i-1位置的字符作为一个词汇单位输出，同时将S中的W部分删去，清空W，转1；如果char是词分隔符，且W是空格，将S中W部分删去，清空W，转1</li><li>F：看指针是否已经知道字符流尾部</li><li>T：将当前W从起始位置到i-1位置的字符作为一个词汇输出</li><li>F：转1</li></ol></li></ul><p><strong>词性还原</strong></p><p>屈折型语言词与变化形式：</p><ul><li>屈折变化 take -&gt; took -&gt; takes</li><li>派生变化 happy -&gt; happily</li><li>复合变化 6-year-old</li></ul><p>词性还原的目的：将上述变化还原</p><p>常见问题：</p><ul><li>半规则变化 flied -&gt; fly + ~ed</li><li>不规则变化 good -&gt; better</li><li>歧义现象 better -&gt; good + ~er or well + ~er</li></ul><p>所需知识库</p><ul><li>词典 Dict</li><li>前缀表 PrefixList</li><li>后缀表 SuffixList</li><li>有关屈折词尾变形的规则 Rules</li></ul><p>算法：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005090409133.png" alt="image-20231005090409133"></p><p>词性还原做到的程度：</p><ul><li>词干层： Impossibilities -&gt; impossibility + ies</li><li>词根层： impossibilities -&gt; im + poss + ibil + it + ies</li><li>分析成都取决与自然语言处理系统的深度<ul><li>不解决未登录词，分析到词干层</li><li>解决未登录词，分析到 词根层</li></ul></li></ul><p>汉语词法分析面临的问题：</p><ul><li>叠词、离合词、词缀<ul><li>恶心心</li><li>游泳：游了一会泳</li><li></li></ul></li><li>词语的切分歧义<ul><li>交集型歧义： 有|意见、有意|见</li><li>组合型歧义：马上、 马|上</li><li>混合型歧义：人|才能、人才|能、人|才|能</li><li></li></ul></li><li>未登录词</li></ul><p>伪歧义：歧义字段单独拿出来看有歧义，但在真实语境中仅有一种切分形式可接受。</p><p><strong>汉语分词</strong></p><p>分词的基本方法</p><ul><li>最大匹配法<ul><li>正向最大匹配法<ul><li>左至右，最长词</li></ul></li><li>逆向最大匹配法<ul><li>右至左，最长词</li></ul></li><li>双向最大匹配法<ul><li>依次正向反向，一致输出，不然采用其他方法排岐</li></ul></li><li>能发现部分交集型歧义，无法发现组合型歧义</li></ul></li><li>概率方法<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005104754401.png" alt="image-20231005104754401"></li><li>提高计算效率：根据最佳左邻词判断</li></ul></li></ul><h2><span id="3-文档模型">3 文档模型</span></h2><h3><span id="31-布尔模型">3.1 布尔模型</span></h3><p>每个词在一篇文档中是否出现，对应权值为0或1</p><h3><span id="32-词袋模型">3.2 词袋模型</span></h3><p><strong>N-gram语法模型</strong></p><p>N表示n个词语，n元语法模型通过n个词语的概率判断句子的结构。</p><p>算法思想：</p><p>将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度是N的字节片段序列。每个字节片段称为gram。对所有gram的出现频度进行统计，并且按照实现设定好的阈值进行过滤，形成关键gram列表，也就是文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。</p><p>基于马尔科夫假设，即每个词的出现只与前一个词有关，而与其他词不相关。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005110948948.png" alt="image-20231005110948948"></p><p>计算句子出现的概率时为了使首次有意义，加入一个或多个起始符$w_0=<bos>$同理句尾加入$<eos>$</eos></bos></p><h3><span id="33-向量空间模型-vsm">3.3 向量空间模型 VSM</span></h3><p>将文档表达为一个矢量，看作向量空间中的一个点。</p><p>权重计算方法：</p><ul><li>布尔权重</li><li>TFIDF型权重<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005111333178.png" alt="image-20231005111333178"></li></ul></li><li>基于熵概念的权重<ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005111407480.png" alt="image-20231005111407480"></li></ul></li></ul><h2><span id="4-文档相似度计算">4 文档相似度计算</span></h2><p>查询与文档之间的相关性</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005111615655.png" alt="image-20231005111615655"></p><p>基于VSM的相关度计算方法</p><ul><li>欧氏距离</li><li>向量内积</li><li>向量夹角余弦</li></ul><p>文本序列：</p><p><strong>序列比较</strong>：</p><ol><li>两条长度相近的序列相似找出序列的差别</li><li>一条序列是否包含另一条序列</li><li>两条序列中是否有非常相同的子序列</li><li>一条序列与另一条序列逆序相似</li></ol><p>相似度：它是两个序列的函数，其值越大，表示两个序列越相似</p><p>距离：距离越大，两个序列的相似度越小</p><p><strong>编辑距离</strong>：</p><p>用来计算从原串转换到目标串所需要的最少的插入，删除和替换的数目</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淑芬第五周学习日志</title>
      <link href="/2023/10/04/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/04/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1><span id="第三章-函数极限与连续">第三章 函数极限与连续</span></h1><h2><span id="1-函数极限的定义与基本性质">1 函数极限的定义与基本性质</span></h2><h3><span id="函数极限定义">函数极限定义</span></h3><h4><span id="函数极限存在定义">函数极限存在定义</span></h4><script type="math/tex; mode=display">U(x_0;\delta)=\{x| \ |x-x_0|<\delta \} \\U^0(x_0;\delta)=\{x| \ 0 < |x-x_0|<\delta \} \\</script><p>设$f(x)$定义在$U^0(x_0;\delta’),L$为一个实数，$\forall \epsilon&gt;0, \exists \delta(x)&lt;\delta’, 当0&lt;|x-x_0|&lt;\delta, 有|f(x)-L|&lt;\delta$</p><p>称$x\rightarrow x_0$时，$f(x)$以$L$为极限，记为$\lim_{x\rightarrow x_0}f(x) = L$</p><p>用符号语言表述为$\forall \epsilon&gt;0,\exists \delta(\epsilon)&gt;0,0 &lt; |x-x_0| &lt; \delta, |f(x)-L|&lt;\epsilon$</p><ol><li>$f(x)$在$x_0$可以无定义（毕竟是去心邻域</li><li>函数极限为局部性质，仅和$x_0$附近取值有关</li><li>$\delta(x)$随着$\epsilon$变化而变化</li></ol><h4><span id="函数极限不存在定义">函数极限不存在定义</span></h4><p>$\lim_{x\rightarrow x_0}f(x) \neq L$定义：</p><ul><li>$\exists \epsilon_0&gt;0,\forall \delta(\epsilon_0)&gt;0,\exists x’,0 &lt; |x’-x_0| &lt; \delta, |f(x’)-L|\geq \epsilon$</li></ul><p>$\lim_{x\rightarrow x_0}f(x)$不存在定义：</p><ul><li>$\forall L\in R,\exists \epsilon_0&gt;0,\forall \delta(\epsilon_0)&gt;0,\exists x’,0 &lt; |x’-x_0| &lt; \delta, |f(x’)-L|\geq \epsilon$</li></ul><h3><span id="函数极限基本性质">函数极限基本性质</span></h3><h4><span id="性质1">性质1</span></h4><p>若$\lim_{x\rightarrow x_0}f(x)$存在则极限唯一。</p><h4><span id="性质2-局部有界性">性质2 局部有界性</span></h4><p>$f(x)$定义在$U^0(x_0;\delta_1)$且$\lim_{x\rightarrow x_0}f(x) = A$，则存在邻域$U^0(x_0;\delta) \subset U^0(x_0;\delta_1),s.t. f(x)$在$U^0(x_0;\delta)$内有界</p><h4><span id="性质3-局部保序性">性质3 局部保序性</span></h4><p>设$\lim_{x\rightarrow x_0}f(x)=A,\lim_{x\rightarrow x_0}g(x)=B$则：</p><ol><li>若$A&gt;B,\exists\delta&gt;0, x\in U^0(x_0;\delta)$时$f(x)&gt;g(x)$</li><li>若$\exists\delta&gt;0,x\in U^0(x_0;\delta)$时，$f(x)\geq g(x)$，则$A\geq B$</li><li>$\lim_{x\rightarrow x_0}f(x) = A&gt;0$，则$\exists \delta&gt;0, x\in U^0(x_0;\delta):f(x)&gt;0 $</li></ol><h2><span id="2-函数极限的四则运算与夹逼定理">2 函数极限的四则运算与夹逼定理</span></h2><h3><span id="极限的四则运算性质">极限的四则运算性质</span></h3><p>设$f(x),g(x)$定义在$U^0(x_0;\delta),\lim_{x\rightarrow x_0}f(x)=A,\lim_{x\rightarrow x_0}g(x)=B$，则</p><ol><li>$\lim_{x\rightarrow x_0}[f(x) \pm g(x)] = A\pm B$</li><li>$\lim_{x\rightarrow x_0}[f(x)\cdot g(x)] = A\cdot B$</li><li>$\lim_{x\rightarrow x_0}\frac{f(x)}{g(x)} = \frac{A}{B}$，其中$B\neq 0$</li></ol><h3><span id="夹逼定理">夹逼定理</span></h3><p>如果当$x \in U^0(x_0;\delta)$时，满足：</p><ol><li>$g(x)\leq f(x)\leq h(x)$</li><li>$\lim_{x\rightarrow x_0}g(x)=A,\lim_{x\rightarrow x_0}h(x)=A$</li></ol><p>那么$\lim_{x\rightarrow x_0}f(x)=A$</p><h2><span id="3-复合函数的极限">3 复合函数的极限</span></h2><h4><span id="定理">定理</span></h4><p>设$\lim_{x\rightarrow x_0}f(x)=A,\lim_{t\rightarrow t_0}g(t)=x_0$且$U^0(t_0;\delta_1)$内$g(t)\neq x_0$，则$\lim_{t\rightarrow t_0}f(g(t))=\lim_{x\rightarrow x_0}f(x)=A$</p><ul><li>如果$f(x)$在$x=x_0$没有定义，$U^0(t_0;\delta_1)$内$g(t)\neq x_0$不能少，否则复合函数$f(g(t))$没有意义</li></ul><h3><span id="应用">应用</span></h3><p>$\lim_{x\rightarrow 0}\frac{\sin x}{x}=1$</p><hr><h2><span id="典型例题">典型例题</span></h2><h3><span id="1-有理函数极限">1 有理函数极限</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231015174735098.png" alt="image-20231015174735098"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231015174857086.png" alt="image-20231015174857086"></p><hr><h2><span id="4-海涅与柯西定理">4 海涅与柯西定理</span></h2><h3><span id="海涅定理">海涅定理</span></h3><p>设$f(x)$定义在$U^0(x_0;\delta_1)$，则$\lim_{x\rightarrow x_0}f(x)=A$的充分必要条件是$\forall \{x_n\}\subset U^o(x_0;\delta_1),\lim_{n\rightarrow\infty}x_n=x_0$都有$\lim_{n\rightarrow \infty}f(x_n)=A$</p><p>海涅原理建立了数列极限与函数极限的关系</p><p>则推出极限不存在的情况：</p><ol><li>挑出了两个数列的极限存在且不等</li><li>挑出了一个极限不存在的数列</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231015201141080.png" alt="image-20231015201141080"></p><h3><span id="柯西定理">柯西定理</span></h3><p>$f(x)$定义在$U^o(x_0;\delta^*),\lim_{x\rightarrow x_0}f(x)$存在的充要条件是：</p><p>$\forall \epsilon&gt;0,\forall x_1,x_2\in U^o(x_0;\delta^*),0&lt;|x_1-x_0|&lt;\delta,0&lt;|x_2-x_0|&lt;\delta:|f(x_1)-f(x_2)|&lt;\epsilon$</p><h2><span id="5-连续函数">5 连续函数</span></h2><h3><span id="51-连续函数定义">5.1 连续函数定义</span></h3><h4><span id="函数连续定义">函数连续定义</span></h4><p>设$f:(a,b)\rightarrow R$，若对$x_0 \in (a,b), \lim_{x\rightarrow x_0}f(x)=f(x_0)$则称$f(x)$在$x_0$处连续；</p><p>$\forall \epsilon &gt; 0, \exists \delta &gt; 0, |x-x_0| &lt; \delta: |f(x)-f(x_0)|&lt;\epsilon$</p><h4><span id="函数左右连续定义">函数左右连续定义</span></h4><p>设$f:(a,b)\rightarrow R$，若$x_0 \in (a,b), \lim_{x\rightarrow x_0^-}f(x)=f(x_0)$则称左连续；</p><p>设$f:(a,b)\rightarrow R$，若$x_0 \in (a,b), \lim_{x\rightarrow x_0^+}f(x)=f(x_0)$则称右连续。</p><h5><span id="推论">推论：</span></h5><p>$f(x)$在$x_0$处连续 $\Leftrightarrow$既左连续又右连续</p><h4><span id="连续函数性质">连续函数性质</span></h4><p>设$f:(a,b)\rightarrow R$，若对$x_0 \in (a,b), \lim_{x\rightarrow x_0}f(x)=f(x_0)$，则有</p><ol><li>局部有界性：若$f(x)$在$x_0 \in (a,b)$连续，则存在$U(x_0;\delta)\subset (a,b), \ f(x)$在$U(x_0;\delta)$有界</li><li>局部保号性：若$f(x_0)$为正，则$f(x)$在附近时也为正（负亦然</li><li>四则运算性质：$f,g$连续，则四则运算后的也连续</li><li>复合函数连续<ul><li>符合函数连续性比极限少了$t_0$处取值的限制</li><li>复合连续函数的极限是可以换位置的</li></ul></li><li>反函数连续：设$f(x)$在区间$I$上单调递增的连续函数，则$f^{-1}$在$f(I)$上也严格单调递增</li></ol><h4><span id="区间连续定义">区间连续定义</span></h4><ol><li>$f(x)$在$(a,b)$上任一点连续，则在$(a,b)$连续</li><li>$f(x)$在$(a,b)$上任一点连续，且在$x=a,x=b$右左连续则在$[a,b]$连续</li></ol><h4><span id="初等函数的连续性">初等函数的连续性</span></h4><ol><li>三角函数及反三角函数在定义域内时连续的。</li><li>对数函数、幂函数、指数函数定义域内连续</li></ol><h3><span id="52-函数间断点分类">5.2 函数间断点分类</span></h3><h4><span id="第一类间断点">第一类间断点</span></h4><p>如果$f(x)$在点$x_0$处左右极限都存在，若</p><ol><li>$f(x_0 - 0) \neq f(x_0 + 0)$ 跳跃间断点</li><li>$f(x_0 - 0) = f(x_0 + 0) \neq f(x_0)$ 可去间断点</li></ol><h4><span id="第二类间断点">第二类间断点</span></h4><p>左右极限至少有一个不存在</p><h3><span id="53-利用函数连续性求极限">5.3 利用函数连续性求极限</span></h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全协议第五周学习日志</title>
      <link href="/2023/10/04/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/04/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1><span id="电子商务安全协议">电子商务安全协议</span></h1><h2><span id="1-电子商务协议简介">1 电子商务协议简介</span></h2><p>电子商务是客户 customer， 商家 merchant ，银行 bank 和为各方所信任的第三方认证机制 CA之间的信息流、资金流、物流的交互关系。个方式通过遍及全球的、开放的、不安全的Internet联系的。</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006213550239.png" alt="image-20231006213550239"></p><p>安全隐患可以概括为三个方面：</p><ul><li>计算机系统安全<ul><li>硬件系统和软件系统的安全</li></ul></li><li>数据安全<ul><li>大量的商务数据</li></ul></li><li>交易安全<ul><li>交易在网上进行</li></ul></li></ul><p>可能存在的安全问题：</p><ul><li>假冒</li><li>交易抵赖</li><li>篡改信息</li><li>信息泄露<ul><li>盗取或解惑交易信息</li></ul></li></ul><p>参与者的安全需求：</p><ul><li>匿名性<ul><li>不可观察性：与该交易无关的参与者和系统之外的攻击者不能获取交易的有用信息</li><li>无关联性：任何人不能将支付者在交易时提交的信息关联起来。</li></ul></li><li>保密性</li><li>完整性<ul><li>信息传输和存储</li></ul></li><li>不可否认性</li><li>可认证性</li><li>有效性</li></ul><p>安全机制：</p><ul><li>数字签名技术</li><li>加密技术</li><li>数字时间戳技术</li><li>防火墙技术</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006222248094.png" alt="image-20231006222248094"></p><h2><span id="2-常见电子商务协议">2 常见电子商务协议</span></h2><h3><span id="ssl协议">SSL协议</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007082948816.png" alt="image-20231007082948816"></p><ol><li>接通阶段：用户通过登录电子商务网站，建立客户与服务器之间的连接</li><li>密码交换阶段</li><li>密码会谈阶段</li><li>检验阶段：检验密码的正确性</li><li>客户认证阶段：验证客户资料的真实性</li><li>结束阶段：客户与服务器之间开始传输数据</li></ol><p>记录协议为SSL连接提供两种服务：机密性和报文完整性</p><ol><li>机密性：SSL记录协议会协助双方产生一把共有的密钥，利用这把密钥来对SSL所传送的数据做传统式加密</li><li>消息完整性：SSL记录协议会协助双方产生另一把共有的密钥，利用这把密钥来计算出消息认证码</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007084217481.png" alt="image-20231007084217481"></p><ul><li>加密算法：DES、3DES】RC4、AES等加密算法</li><li>密钥交换：DH、RSA、ECDHE</li><li>Hash：MD5、SHA1</li></ul><p>合法性认证：握手阶段采用公钥技术进行数字认证</p><p>数据加密：采用对称密钥加密传输数据</p><p>完整性：hash</p><p>电子商务往往是用户、网站、银行三家协作完成，SSL协议并不能协调各方面的安全传输和信任关系；并且SSL不对应用层的数据进行签名，不支持完善的防抵赖功能</p><h3><span id="set协议">SET协议</span></h3><p>基于信用卡支付模式而设计的</p><p>SET协议是一个基于可信第三方认证中心的方案，基本原理时采用公钥密码体制和X.509数字证书标准，主要用于保障电子交易中支付过程和支付信息的机密性、商家和客户的合法的身份认证</p><p>核心技术：双重数字签名技术、安全数字证书技术、数字信封、数字时间戳等</p><h4><span id="系统结构">系统结构</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007085629410.png" alt="image-20231007085629410"></p><p><strong>支付网关</strong>: 银行与Internet之间专用系统，负责接收处理从商家传来的扣款信息，并通过专线送给银行；银行通过该系统将支付信息的处理结果反馈给商家</p><p><strong>收单银行</strong>：商家建立账户并处理支付卡认证和支付的金融机构</p><p><strong>发卡银行</strong>：负责为持卡人建立账户并发放支付卡的金融机构</p><h4><span id="交易流程">交易流程</span></h4><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007090238071.png" alt="image-20231007090238071"></p><p>在保留对用户信用卡认证的前提下又增加了对商家身份的认证</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007090907988.png" alt="image-20231007090907988"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091009060.png" alt="image-20231007091009060"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091017878.png" alt="image-20231007091017878"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091028915.png" alt="image-20231007091028915"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091040960.png" alt="image-20231007091040960"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091050081.png" alt="image-20231007091050081"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007091058476.png" alt="image-20231007091058476"></p><h4><span id="技术细节">技术细节</span></h4><p>双重数字签名技术：第5步，先签名后加密，再签名</p><p>数字时间戳：数字签名中加入时间戳服务</p><p>安全数字证书</p><p>数字信封：对称密码和非对称密码的串联</p><h4><span id="协议分析">协议分析</span></h4><p>满足原则：</p><ul><li>匿名性</li><li>机密性、完整性</li><li>不可否认性、身份认证</li></ul><p>复杂性：</p><ul><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007092447008.png" alt="image-20231007092447008"></li></ul><p>折中办法：用户和商家SSL、商家和银行SET</p><p>协议存在的问题：</p><ul><li>售后服务</li><li>数据处理</li><li>无法针对借记卡</li></ul><h2><span id="3-协议对比-set与ssl">3 协议对比： SET与SSL</span></h2><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007092800794.png" alt="image-20231007092800794"></p><h2><span id="4-其他电子商务协议">4 其他电子商务协议</span></h2><p>3-D Sercure协议</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 安全协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理与信息隐藏第四周学习日志</title>
      <link href="/2023/10/03/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/10/03/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="2-图像信息的基本知识">2 图像信息的基本知识</span></h1><h2><span id="22-图像数字化">2.2 图像数字化</span></h2><p>图像数字化：将代表图像的连续信号转变为离散信号</p><p><strong>采样</strong>：图像在空间上的离散化</p><p><strong>量化</strong>：对样点灰度值的离散化过程。</p><p>为了适应数字计算机的处理，必须对连续图像函数进行<strong>空间和幅值</strong>数字化</p><p><strong>均匀量化</strong>：将样本连续灰度值等间隔分层量化方式</p><p><strong>非均匀量化</strong>：不等间隔分层量化方式</p><p><strong>量化误差</strong>：以有限个离散值来近似表示无限多个连续值，量化器输出与输入之间必然存在误差</p><p>量化分层越多，量化误差越小，但编码时占用比特数越多</p><p>按人的视觉特点的非均匀量化</p><h2><span id="23-图像的噪声分析">2.3 图像的噪声分析</span></h2><h3><span id="231-噪声">2.3.1 噪声</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/噪声.png" alt="img1"></p><p>高斯噪声是应用最广的噪声模型</p><h3><span id="232-图像噪声的分类">2.3.2 图像噪声的分类</span></h3><p>根据噪声的产生原因</p><ul><li>外部噪声</li><li>内部噪声</li></ul><p>根据统计理论观点</p><ul><li>平稳噪声：不随时间变化</li><li>非平稳噪声：随</li></ul><p>根据噪声幅度分布</p><ul><li>高斯噪声</li><li>瑞利噪声</li><li>伽马噪声</li></ul><p>根据频谱形状</p><ul><li>白噪声：频谱均匀分布</li><li>1/f噪声：频谱与频率成分反比</li><li>三角噪声：与频率平方成正比的噪声</li></ul><p>根据噪声与图像的结合方式</p><ul><li>加性噪声：输出图像为S(t)+n(t)</li><li>乘性噪声：S(t)(1+n(t))</li></ul><p>为了分析处理方便，</p><ol><li>往往将乘性噪声近似认为是加性噪声</li><li>信号和噪声是互相统计独立的</li></ol><h2><span id="24-图像质量评价">2.4 图像质量评价</span></h2><h3><span id="241-概述">2.4.1 概述</span></h3><p>图像质量评价的主要方法：</p><ul><li>客观评价方法<ul><li>实现容易</li><li>可消除不确定行</li><li>不一定反应真实质量</li></ul></li><li>主观评价方法<ul><li>实现困难</li><li>受其他因素影响大</li><li>像评估的最终目标</li></ul></li></ul><h3><span id="242-图像质量的主观评价">2.4.2 图像质量的主观评价</span></h3><p>主观评价方法：</p><ol><li>由ITU制定了图像主观评价的标准</li><li>至少挑选10观察者</li><li>测试条件应尽可能与使用条件相匹配</li><li>调查</li><li>设计评分表</li><li>结果分析，MOS Mean Option Score， DMOS Differential Mean Option Score</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/DMOS.png" alt="img2"></p><p>DMOS值越大说明视频越好</p><p><strong>灰度图像的失真度量</strong></p><ol><li><p>归一化的均方误差</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/NMSE.png" alt="img3"></p></li><li><p>峰值均方误差</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/PMSE.png" alt="img4"></p></li><li><p>等效的峰值信噪比</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/PSNR.png" alt="img5"></p></li></ol><h3><span id="243-图像保真度的测量">2.4.3 图像保真度的测量</span></h3><p>保真度并与一定能够反应图像主观质量</p><p><strong>亮度的量度</strong></p><p>人的感觉亮度和亮度y基本称对数关系</p><script type="math/tex; mode=display">\Delta(L_1,L_2) = \log_B{(y+\Delta y)} - \log_B(y)</script><p><strong>彩色的量度</strong></p><p>人的彩色感觉：红、绿、蓝</p><ul><li>RGB模式：加式模式</li><li>CMYK模式：印刷彩色，减式模式，反射光</li></ul><h2><span id="25-彩色图像基本知识">2.5 彩色图像基本知识</span></h2><ol><li><p>YIQ</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/YIQ.png" alt="img6"></p></li><li><p>YUV</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/YUV.png" alt="img7"></p></li><li><p>YCbCr</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/YCbCr.png" alt="img8"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第四周学习日志</title>
      <link href="/2023/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<!--ttoc --><h1><span id="第二章-关系数据库">第二章 关系数据库</span></h1><h2><span id="21-关系数据结构及形式化定义">2.1 关系数据结构及形式化定义</span></h2><h3><span id="211-关系">2.1.1 关系</span></h3><p>单一的数据结构——关系</p><ul><li><p>现实世界的<strong>实体以及实体间的各种联系</strong>均用关系来表示</p></li><li><p>关系的组成：同一类实体型的实例集合</p></li><li><p>关系之间的联系：实体与实体之间、实体的属性之间存在某种关联关系</p></li></ul><p>逻辑结构——二维表表头（关系模式）</p><ul><li>从用户角度，关系模型中数据的逻辑结构是一张二维表的表头，描述表的组成关系</li></ul><p>建立在集合论和关系代数的基础上</p><h4><span id="1-域-domain">1. 域 Domain</span></h4><p>域是一组具有<strong>相同数据类型</strong>的<strong>值的集合</strong></p><ul><li>值的集合是有限、且不重复</li><li>集合中的元素不重复</li><li>同一数据类型</li></ul><h4><span id="2-笛卡尔积-cartesian-product">2. 笛卡尔积 Cartesian Product</span></h4><p>给定一组域$D_1,D_2,\cdots,D_n$，允许其中某些域是相同的</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231005214516139.png" alt="image-20231005214516139"></p><ul><li>所有域的所有取值的一个组合</li><li>组合结果不允许重复</li></ul><p>元组 Tuple</p><ul><li>笛卡尔积中的每一个元素叫做一个元组</li></ul><p>分量 Component</p><ul><li>笛卡尔积元素中每一个值di叫做一个分量</li></ul><p>基数 Cardinal number</p><ul><li>集合中包含的元素个数</li></ul><p>笛卡尔积表示方法</p><ul><li>表示为一张二维表</li><li>每行对应一个元组，每列对应一个域</li></ul><h4><span id="3-关系-relation">3. 关系 Relation</span></h4><h5><span id="1-关系">1 关系</span></h5><p>$D_1 \times D_2 \times \cdots \times D_n$的子集叫做在域$D_1,D_2,\cdots,D_n$上的关系，表示为$R(D_1,D_2,\cdots,D_n)$</p><ul><li>R：关系名</li><li>n：关系的目或度</li></ul><h5><span id="2-元组">2 元组</span></h5><p>关系中的每个元素是关系中的元组，通常用t表示</p><h5><span id="3-单元关系与二元关系">3 单元关系与二元关系</span></h5><p>n=1单元；n=2二元</p><h5><span id="4-关系的表示">4 关系的表示</span></h5><p>关系是一个二维表，表的每行对应一个元组，每列对应一个域</p><h5><span id="5-属性">5 属性</span></h5><p>关系中不同列可以对应相同的域</p><p>每列必须有一个名字，称为属性</p><p>n目关系必有n个属性</p><h5><span id="6-码键">6 码/键</span></h5><ul><li>候选键/码 Candidate key<ul><li>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</li></ul></li><li>全码/键 All-key<ul><li>关系模式的所有属性组是这个关系模式的候选码，称为全码</li></ul></li></ul><p>在关系模型中，候选键或候选码是某个关系的一组属性所组成的集合，它需要同时满足以下两个条件</p><ol><li>这个属性集合始终能够确保在关系中能唯一标识元组</li><li>在这个属性集合中找不出真子集额能够满足条件1</li></ol><p>满足上面第一个条件的属性集合称为超键 Super Key， 我们也可以把候选键定义为最小超键，即不含有多余属性的超键。</p><p>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，他就不具有这样的性质了，这样的属性组称为候选码。</p><ul><li><p>主码/主键</p><ul><li>若一个关系有多个候选码，选定其中一个为主码</li><li>优先选择数字类型的候选键</li></ul></li><li><p>主属性</p><ul><li>候选码的诸属性称为主属性</li><li>不包含在任何候选码中的属性称为非主属性或非码属性</li></ul></li><li><p>外键</p><ul><li>一个实体的主键被另外一个实体使用，以表达不同实体元组之间的关系</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006090213940.png" alt="image-20231006090213940"></p></li></ul><p>实体之间的关系依赖主键——外键关联实现</p><p>关系数据库支持的实体间关系类型</p><ul><li>1对1：主键与外键相同，或者一个实体的主键作为另外一个实体的外键</li><li>一对多 或者多对一：一实体的主键作为多实体的外键</li></ul><p>多对多的实体关系存在如下问题：</p><ul><li>数据冗余</li><li>自底向上遍历可能会产生多个父节点，导致具体实例的父子关系难以区分</li></ul><p>主键外键区别</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006093514629.png" alt="image-20231006093514629"></p><h5><span id="7-三类关系">7 三类关系</span></h5><ol><li>基本关系 （基本表或基表）<ul><li>实际存在的表，是实际存储数据的逻辑表示</li></ul></li><li>查询表<ul><li>查询结果对应的表</li></ul></li><li>视图表<ul><li>由基本表或其他视图导出的表，虚表，不对应实际存储的数据</li></ul></li></ol><h5><span id="8-基本关系的性质">8 基本关系的性质</span></h5><ol><li>列是同质的：列中分量来自同一域</li><li>不同的列可出自同一个域</li><li>列的顺序无所谓，列的次序可以任意交换</li><li>任意两个元组的候选码不能相同，元组相同指的是两个元组的每个分量都相同</li><li>行的顺序无所谓，行的次序可以任意交换</li><li>分量必须取原子值</li></ol><h3><span id="212-关系模式">2.1.2 关系模式</span></h3><h4><span id="1-什么是关系模式">1 什么是关系模式</span></h4><ul><li>关系模式 Relation Schema 是型 Type，是结构</li><li>关系是值 （二维表</li><li>同一关系模式下，可以有很多关系</li><li>关系模式是关系的结构，关系是关系模式在某一时刻的数据</li><li>关系模式是稳定的，关系是随时间变化的</li><li>关系模式是对关系的描述<ul><li>元组集合的结构<ul><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映像关系</li></ul></li><li>完整性约束条件</li></ul></li></ul><h4><span id="2-定义关系模式">2 定义关系模式</span></h4><p>关系模式可以形式化地表示为：$R(U,D,DOM,F)$</p><ul><li>R - 关系名</li><li>U - 组成该关系的属性名集合</li><li>D - U中元素所来自的域</li><li>DOM - 属性向域的映像集合</li><li>F - 属性间数据的依赖关系的集合</li></ul><p>通常可以简记为 $R(U) \ or \ R(A_1,A_2, \cdots, A_n)$ (A是属性名)</p><h4><span id="3-关系模式与关系">3 关系模式与关系</span></h4><p>关系模式</p><ul><li>对关系结构的描述</li><li>静态的、稳定的</li></ul><p>关系</p><ul><li>关系模式在某一时刻的状态或内容</li><li>动态的、随时间不断变化的</li></ul><p>关系模式和关系往往统称为关系</p><h3><span id="213-关系数据库">2.1.3 关系数据库</span></h3><p>在一个给定应用领域中， 所有关系的集合构成一个关系数据库</p><p>关系数据库的型与值：</p><ul><li>型：关系数据库模式，是对关系数据库结构的描述</li><li>值：关系模式在某一时刻对应的关系的集合，通常称为关系数据库RDB</li></ul><h3><span id="214-关系模型的存储结构">2.1.4 关系模型的存储结构</span></h3><p>关系数据库的物理组织</p><ul><li>有的关系数据库管理系统一个表对应一个操作系统文件，将物理数据组织交给操作系统完成</li><li>有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理</li></ul><h2><span id="22-关系操作">2.2 关系操作</span></h2><h3><span id="221-基本的关系操作">2.2.1 基本的关系操作</span></h3><ul><li>查询操作 8种 5种基本<ul><li>选择、投影、链接、除、并、差、交、笛卡尔积</li><li>选择、投影、并、差、笛卡尔积 5种基本操作</li></ul></li><li>数据更新：插入、删除、修改</li></ul><p>关系操作的特点</p><ul><li>集合操作方式：操作的对象和结果都是集合，一次一集合的方式</li></ul><h3><span id="222-关系数据库语言的分类">2.2.2 关系数据库语言的分类</span></h3><p>关系代数语言</p><ul><li>用对关系的运算来表达查询要求，对关系代数表达式求值</li><li>ISBL  Information System Base Language</li></ul><p>关系演算语言：用谓词表达查询要求（选学</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006101847955.png" alt="image-20231006101847955"></p><p>具有关系代数和关系演算双重特点的语言：SQL</p><h2><span id="23-关系的完整性">2.3 关系的完整性</span></h2><p>关系的三类完整性约束：</p><ul><li>实体完整性和参照完整性<ul><li>关系模型必须满足的完整性约束条件，关系的两个不变性，应该由关系系统自动支持</li></ul></li><li>用户定义的完整性<ul><li>具体领域中的语义约束</li></ul></li></ul><h3><span id="231-实体完整性">2.3.1 实体完整性</span></h3><h4><span id="规则21-实体完整性规则-entity-integrity">规则2.1 实体完整性规则 Entity Integrity</span></h4><ul><li>若属性A是基本关系R的主属性，则A不能取空值</li><li>NULL：不知道、不存在、无意义的值<ul><li>有空值的时候需要特殊处理</li><li>不能参与算数、比较、逻辑运算</li></ul></li></ul><p>规则说明：</p><ul><li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，具有某种唯一性标识</li><li>关系模型中以主键作为唯一性标识</li><li>诸属性不能取空值</li></ul><h3><span id="232-参照完整性">2.3.2 参照完整性</span></h3><h4><span id="1-关系间的引用">1 关系间的引用</span></h4><h4><span id="2-外键码">2 外键/码</span></h4><p>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码$K_s$相对应,则称F是R的外码</p><p>基本关系R称为参照关系</p><p>基本关系S称为被参照关系或目标关系</p><p>关系R和S 不一定是不同的关系</p><p>目标关系S的主码和参照关系的外码必须定义在同一个域上</p><p>外码不一定要与对应的主码同名</p><h4><span id="3-参照完整性规则">3 参照完整性规则</span></h4><h5><span id="规则22-参照完整性规则">规则2.2 参照完整性规则</span></h5><p>若属性F是基本关系R的外码，F与基本关系S的主码$K_s$相对应,则对于R中的每个元组在F上的值必须为：</p><ul><li>或者等于S中某个元组的主码值$K_s$</li><li>或者取空值</li></ul><p>关系数据库不支持多对多联系——数据冗余少</p><h3><span id="233-用户定义的完整性">2.3.3 用户定义的完整性</span></h3><p>针对某一具体关系数据库的约束条件</p><ul><li>数据必须满足的语义要求</li></ul><p>关系模型应提供定义和检验这类完整性的机制</p><h2><span id="24-关系代数">2.4 关系代数</span></h2><p>关系代数是一种抽象的查询语言，它用关系运算表达查询</p><p>关系代数</p><ul><li>对象、结果均为关系</li><li>运算符有两类：集合运算符、专门的关系运算符</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006105723229.png" alt="image-20231006105723229"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006105744866.png" alt="image-20231006105744866"></p><h3><span id="241-传统的集合运算">2.4.1 传统的集合运算</span></h3><h4><span id="并-union">并 Union</span></h4><ul><li>R和S<ul><li>具有相同的目n即两个关系都有n个是个也许不该</li><li>相应的属性取自同一个域</li></ul></li><li>R $\cup$ S<ul><li>仍为n目关系，由属于R或属于S的元组组成</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006110424830.png" alt="image-20231006110424830"></li><li>结果不允许重复</li></ul></li></ul><h4><span id="差-difference">差 Difference</span></h4><ul><li>R and S<ul><li>具有相同的目n</li><li>相应的属性取自同一个域</li></ul></li><li>R - S<ul><li>仍为n目关系，由属于R但不属于S的元组组成</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006110608171.png" alt="image-20231006110608171"></li></ul></li><li>语义：是…但不含…</li></ul><h4><span id="交-intersection">交 Intersection</span></h4><ul><li>R and S<ul><li>具有相同的目n</li><li>相应的属性取自同一个域</li></ul></li><li>R $\cap$ S<ul><li>仍为n目关系，由属于R且属于S的元组组成</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006110737469.png" alt="image-20231006110737469"></li></ul></li></ul><h4><span id="笛卡尔积-cartesian-product">笛卡尔积 Cartesian Product</span></h4><p>元素是元组</p><ul><li>R：n目关系，$k_1$个元组</li><li>S：m目关系，$k_2$个元组</li><li>R $\times$ S<ul><li>列： (n+m)列</li><li>行：$k_1 \times k_2$个元组</li></ul></li></ul><h3><span id="242-专门的关系运算">2.4.2 专门的关系运算</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111238808.png" alt="image-20231006111238808"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111315271.png" alt="image-20231006111315271"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111325605.png" alt="image-20231006111325605"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111605603.png" alt="image-20231006111605603"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006111853380.png" alt="image-20231006111853380"></p><h4><span id="1-选择">1 选择</span></h4><p>又称为限制或过滤</p><p>含义</p><ul><li>在关系R中选择满足给定条件的诸元组</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112403358.png" alt="image-20231006112403358"></li><li>F ：选择条件，逻辑表达式，取值为true or false<ul><li>基本形式为 X1 $\theta$ Y1</li><li>$\theta$ 为比较运算符，可以为$\le ,\ge,&gt; ,&lt; ,= or &lt;&gt;$</li></ul></li></ul><p>从行的角度的运算</p><p>优先次序：<img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112643180.png" alt="image-20231006112643180"></p><h4><span id="2-投影">2 投影</span></h4><p>从R中选择出若干属性列组成新关系</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112723318.png" alt="image-20231006112723318"></p><p>列的角度的运算</p><p>投影之后不仅取消了原关系中的某些列，还可能取消某些元组</p><h4><span id="3-连接">3 连接</span></h4><p>也成为$\theta$连接</p><ul><li>只是对单个关系进行操作，实际应用中涉及多个表的操作</li></ul><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006112845740.png" alt="image-20231006112845740"></p><ul><li>A和B：分别为R和S上度数相等界可比的属性组</li></ul><p>两种常用连接运算</p><ul><li><p>等值连接 $\theta$ 为 <code>=</code></p><ul><li>两个关系中比较的分量可以是不同的属性组</li></ul></li><li><p>自然连接 </p><ul><li>两个关系中进行比较的分量必须是相同的属性组</li><li>在结果中把重复的属性列去掉</li><li>含义<ul><li>R和S具有相同的属性组</li><li>U是R和S的全体属性集合</li></ul></li><li>同时从行与列的角度进行</li><li>操作步骤<ol><li>对两个表进行广义笛卡尔积</li><li>从广义笛卡尔积中选取在相同列上值相同的元组</li><li>去掉重复的列</li><li>根据需求做投影操作，得到最终结果</li></ol></li></ul></li></ul><p><strong>悬浮元组</strong></p><p>两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，被舍弃的元组称为悬浮元组。</p><p><strong>外连接</strong></p><p>如果把悬浮元组也保存在结果关系中，其他属性上填空值，就叫外连接</p><p>左外连接：</p><ul><li>只保留左边关系R的悬浮元组</li><li>以左边关系R为基准，右边关系S不匹配的元组为NULL</li></ul><p>右外连接相反。</p><p><code>外连接 = 自然连接 + 失配的元组</code></p><p>外连接形式：</p><ul><li>左外连接 = 自然连接 + 左侧表失配元组</li><li>右外连接 = 自然连接 + 右侧表失配元组</li><li>全外连接 = 自然连接 + 两侧表失配元组</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006152506295.png" alt="image-20231006152506295"></li></ul><h4><span id="4-除运算">4 除运算</span></h4><p>给定关系R(X, Y) S(Y, Z)，其中 X，Y，Z为属性组</p><p>R中的Y与S中的Y可以有不同的属性名，但是必须出自相同的域集。一般的有$\pi_y(S) \subseteq \pi_y(R)$成立，否则结果为空集。</p><p>R与S的除运算得到了一个新的关系P(X)，P时R中满足下列条件的元组在X上的投影：</p><ul><li>元组在X上分量值x的象集$Y_x$包含S在Y上投影的集合，记作：<img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006153143548.png" alt="image-20231006153143548"></li></ul><p>除操作是从行和列的角度进行的</p><p><strong>数学公式</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006153512116.png" alt="image-20231006153512116"></p><p>一般的有$\pi_x(S) \subseteq \pi_y(R)$成立</p><p>构造$S^{‘} = \pi_x(S) \times \pi_y(R)$</p><ul><li>用例子理解一下</li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006154328941.png" alt="image-20231006154328941"></p></li><li><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231006154135461.png" alt="image-20231006154135461"></p></li></ul><h2><span id="25-关系演算">2.5* 关系演算</span></h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全创新实验学习日志</title>
      <link href="/2023/09/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前来看网络安全创新实验中给出的例子还是很不错的，既能够初步明白怎么用，还能在具体的应用环境中实现。-20230929</p></blockquote><h2><span id="lab-2">Lab-2</span></h2><h3><span id="44-md5算法碰撞实验">4.4 MD5算法碰撞实验</span></h3><h4><span id="441-md5碰撞工具的使用">4.4.1 MD5碰撞工具的使用</span></h4><p>快速MD5碰撞生成工具来生成两个拥有相同MD5值的不同文件。这两个文件的开始部分是相同的。因此需要指定前缀：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Lab2/hashclash/ipc_workdir/</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;prefix&quot;</span> &gt; [prefix_file]</span><br><span class="line">../scripts/poc_no.sh [prefix_file]</span><br></pre></td></tr></table></figure><p>可以通过一下命令来验证文件是否内容不同而MD5值相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比较两个文件是否相同</span><br><span class="line">diff -q collision1.bin collision2.bin</span><br><span class="line">ghex -C collision1.bin</span><br><span class="line"><span class="built_in">md5sum</span> collision1.bin collision2.bin</span><br></pre></td></tr></table></figure><p>如果是64字节的倍数，则会正常处理；如果不是64的倍数，则会去除多余的部分。</p><h4><span id="442-md5特性探究">4.4.2 MD5特性探究</span></h4><p>两个相同MD5值的文件加上相同的后缀T会生成两个具有相同哈希值的文件。</p><blockquote><p>cat file1 file2 &gt; file3</p></blockquote><p>将两个文件合并到另一个文件</p><h4><span id="443-产生相同md5哈希值的两个可执行文件">4.4.3 产生相同MD5哈希值的两个可执行文件</span></h4><p>利用gcc编译文件的命令如下：</p><blockquote><p>gcc [input_file] -o [output_file]</p></blockquote><p>编译后的文件可以直接运行</p><blockquote><p>./program.out</p></blockquote><p>赋予执行权限</p><blockquote><p>chmod +x [file_name]</p></blockquote><p>验证是否满足要求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> program_col1.bin program_col2.bin</span><br><span class="line"><span class="built_in">echo</span> $(./program_col1.bin) | <span class="built_in">md5sum</span></span><br><span class="line"><span class="built_in">echo</span> $(./program_col2.bin) | <span class="built_in">md5sum</span></span><br></pre></td></tr></table></figure><p>接下来用head/tail命令来分割文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将a.out前3200byte输入到prefix文件中</span><br><span class="line"><span class="built_in">head</span> -c 3200 a.out &gt; prefix</span><br><span class="line">// a.out 后 100字节输入到suffix</span><br><span class="line"><span class="built_in">tail</span> -c 100 a.out &gt; suffix</span><br><span class="line">// a.out 从第3300字节开始至结尾的内容输入到suffix文件中</span><br><span class="line"><span class="built_in">tail</span> -c +3300 a.out &gt; suffix</span><br></pre></td></tr></table></figure><h2><span id="lab-3">Lab-3</span></h2><h3><span id="43-pki实验">4.3 PKI实验</span></h3><p>PKI利用CA将用户身份与公钥结合，解决公钥可信性问题。</p><p>CA是一个签发电子证书的可信实体。</p><h4><span id="431-建立ca">4.3.1 建立CA</span></h4><p>将<code>openssl</code>提供的配置文件<code>/usr/lib/ssl/openssl.cnf</code>拷贝进入目录，并且根据配置文件中的要求（[CA_default]）创建以下文件夹或文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir =./demoCA# dir, store all files</span><br><span class="line">certs=$dir/certs    # dir, store all certs</span><br><span class="line">crl_dir    =$dir/crl    # dir, store the list of revocation key list</span><br><span class="line">new_certs_dir    =$dir/newcerts #dir, store new certs</span><br><span class="line">database =$dir/index.txt  #file, the index file of database</span><br><span class="line">serial   =$dir/serial   #file, store relevant serial number</span><br></pre></td></tr></table></figure><p>其中，<code>index.txt</code>仅需创建一个空文件，<code>serial</code>文件创建后需要输入偶数位的16进制数字</p><p>之后CA先生成自签名证书，该证书证明CA是可信的，并称为根证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># openssl req生成自签名证书</span></span><br><span class="line">openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf</span><br><span class="line"><span class="comment"># -new 创建一个证书请求文件，若之后指定了-x509，代表创建自签名证书文件</span></span><br><span class="line"><span class="comment"># -keyout [file]  指定自动创建私钥时私钥的输出文件</span></span><br><span class="line"><span class="comment"># -out [file] 指定证书请求或自签名证书的输出文件</span></span><br><span class="line"><span class="comment"># config [file]  指定req命令的配置文件</span></span><br></pre></td></tr></table></figure><blockquote><p>自签名 SSL 证书是一种数字证书，未经公开信任的证书颁发机构 (CA) 签名。自签名证书被认为不同于传统的 CA 签名证书，因为它们是由负责与证书关联的网站或软件的公司或开发人员创建、颁发和签名的，而不是 CA。</p><p>在高层次上，这些自签名证书基于与 X.509 证书中使用的相同的加密私钥和公钥对体系结构。但是，这些数字证书没有受信任的第三方 CA 的验证。发行过程中缺乏独立验证会产生额外的风险，这就是自签名证书的问题。对于面向公众的网站和应用程序，它们被认为是不安全的。</p></blockquote><p>可以用 <code>openssl x509 -noout -text -in ca.crt</code>来查看证书信息</p><h4><span id="432-利用ca签发证书">4.3.2 利用CA签发证书</span></h4><p>网站PKILab.com，需要从CA处取得电子证书：</p><p>首先，生成自己的公私钥对 <code>openssl genrsa -aes128 -out server.key 2048</code></p><p>生成公私钥对后，同时将私钥用AES128加密存储在<code>server.key</code>文件中。</p><p>通过 <code>openssl rsa -in server.key -text</code>查看密钥信息</p><p>其次，PKILab.com需要生成证书请求文件（CSR）。该文件包含了PKILab.com的公钥，并被发送给CA，请求CA对公钥进行签名：</p><p><code>openssl req -new -key server.key -out server.csr -config openssl.cnf</code></p><p>CA收到csr请求文件后，利用自己的私钥ca.key与证书ca.crt，签名并生成server.crt:</p><p><code>openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -config openssl.cnf</code></p><h4><span id="433-验证ca签发证书的签名">4.3.3 验证CA签发证书的签名</span></h4><p>证书文件分为三部分，Data域、Signature Algorithm域、Signature Value域，Date域为证书的基本信息部分，也称作TBSCertificate（To-Be-Signed Certificate）。</p><p>寻找TBSCertificate位置的指令：<code>openssl x509 -in server.crt -inform pem -outform pem -out server.pem</code></p><p>以ASN.1格式解析PEM文件：<code>openssl asn1parse -i -in server.pem</code></p><p>根据解析信息提取TBSCertificate，保存为<code>server.tbs</code>文件：<code>openssl asn1parse -in server.pem -strparse 5 -out server.tbs</code></p><h4><span id="434-将证书用于https-web服务器">4.3.4 将证书用于HTTPS Web服务器</span></h4><p>首先，配置DNS服务。为了让虚拟机能够解析该域名，需要将<code>127.0.0.1 PKILab.com</code>填入虚拟机<code>/etc/hosts</code>文件中。</p><p>然后，基于之前生成的证书，使用指令建立一个Web简单服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将密钥与证书合成为一个文件</span><br><span class="line"><span class="built_in">cp</span> server.key server.pem</span><br><span class="line"><span class="built_in">cat</span> server.crt &gt;&gt; server.pem</span><br><span class="line">//直接将crt拼接到pem后面</span><br><span class="line">// 利用 server.pem 建立一个Web服务器</span><br><span class="line">openssl s_server -cert server.pem -www</span><br></pre></td></tr></table></figure><h2><span id="homework-1">Homework-1</span></h2><h3><span id="11-产生两个程序行为不同的可执行文件">1.1 产生两个程序行为不同的可执行文件</span></h3><h3><span id="12-建立基于apache的https网站">1.2-建立基于Apache的HTTPS网站</span></h3><p>首先需要修改Apache配置文件，<strong>指定网站文件以及网站密钥与证书的存储位置。</strong></p><p>举个栗子~</p><p>要建立一个<code>example.com</code>的网站，需要在<code>/var/www</code>文件夹中新建一个名为<code>example</code>的文件夹，并在其中新建一个<code>index_https.html</code>。</p><p>之后就到了<strong>修改配置文件</strong><code>/etc/apache2/sites-available/&lt;your web&gt;.conf</code>的时候了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:<span class="number">443</span>&gt;</span><br><span class="line"># *表示该配置适用与所有IP与<span class="number">443</span>端口的请求</span><br><span class="line"> ServerName example.com   </span><br><span class="line"> DocumentRoot /var/www/example</span><br><span class="line"> DirectoryIndex index_https.html</span><br><span class="line"></span><br><span class="line"> SSLEngine on</span><br><span class="line"> SSLCertificateFile   <span class="meta"># input the absolute path of the cert of your website </span></span><br><span class="line"> SSLCertificateKeyFile  <span class="meta"># input the absolute path of the key of your website</span></span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">SSLCipherSuite AES256-SHA # 指定加密组件</span><br></pre></td></tr></table></figure><blockquote><p> 至于网站证书应该如何生成以及密钥文件应该如何生成，请看Lab-3</p><p>AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1. Set the ‘ServerName’ directive globally to suppress this message<br>解决方案：</p><p>在/etc/apache2/apache2.cnf中添加</p><p>ServerName  your_server_name</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apachectl configtest</span><br><span class="line">sudo a2enmod ssl</span><br><span class="line">sudo a2ensite default-ssl</span><br><span class="line">sudo service apache2 start 或者 sudo service apache2 restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 实践知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第四周学习日志</title>
      <link href="/2023/09/27/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/27/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p><strong>randomness extractor</strong></p><ul><li>Ext(X,seed)</li></ul><p>One-time pad</p><ul><li>limitations<ul><li>the key is <strong>as long as</strong> the message </li><li>only secure if each key is used to encrypt a <strong>single</strong> message</li><li>Trivially broken by a known-plaintext attack</li></ul></li></ul><p>Optimality of the one-time pad</p><p><strong>Theorem</strong></p><p>if (Gen,Enc,Dec) with message space M is perfectly secret, then $|K| \ge |M|$</p><h2><span id="1-perfect-indistinguishability">1 Perfect Indistinguishability</span></h2><p>We saw other drawbacks of perfect secrecy, like the long key length and so on. If we want to do better, we need to relax the definition.</p><p>The perfect secrecy requires that <strong>absolutely no information</strong> about the plaintext is leaked, even to eavesdroppers with <strong>unlimited computational power</strong>.</p><p>However, we can allow tiny probability of failure actually, for example, security fails with  probability &gt; $2^{-60}$, this possibility is so small that we needn’t to worry about being attacked.</p><h3><span id="roadmap">Roadmap</span></h3><p>we will give an alternate definition of perfect secrecy - Using a randomized experiment</p><p>That definition has a natural relaxation.</p><h3><span id="perfect-indistinguishability">Perfect indistinguishability</span></h3><ul><li>$\Pi = (Gen, Enc, Dec)$, message space $\mathcal{M}$, an adversary $\mathcal{A}$</li><li>Define a randomized exp’t $\text{Privk}^{\text{eav}}_{\mathcal{A},\Pi}$</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007143101027.png" alt="image-20231007143101027"></li><li>Adversary $\mathcal{A}$ succeeds if b = b’, and we say the experiment evaluates to 1 in this case</li><li>$\Pi$ if perfectly indistinguishability if no $\mathcal{A}$ can guess correctly with probability any better than 0.5</li></ul><h4><span id="def-26">Def. 2.6</span></h4><p>$\Pi$ is perfectly indistinguishable if for all attackers $\mathcal{A}$, it holds that </p><script type="math/tex; mode=display">\Pr[\text{Privk}^{\text{eav}}_{\mathcal{A},\Pi}] = \frac{1}{2}</script><h2><span id="2-security-definition-of-encryption">2 Security Definition of Encryption</span></h2><p>There are two approaches to relax perfect indistinguishability: Concrete security and Asymptotic security.</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231007145801664.png" alt="image-20231007145801664"></p><p>$k \leftarrow Gen(1^\lambda)$表示输入的长度是$\lambda$</p><h3><span id="computational-indistinguishability">Computational indistinguishability</span></h3><h4><span id="concrete-security-version">concrete security version</span></h4><ul><li>$(t, \epsilon)$-indistinguishability:<ul><li>Security may fail with probability $\leq \epsilon$</li><li>Restrict attention to attackers running in time $\leq t$</li></ul></li><li>$\Pi$ is  $(t, \epsilon)$-indistinguishable if for all attackers $\mathcal{A}$ running in time at most t, it holds that $\Pr[\text{Privk}^{\text{eav}}_{\mathcal{A},\Pi}] \leq \frac{1}{2} + \epsilon$</li><li>Parameters $t,\epsilon$ are what we ultimately care about in the real world</li><li>does not lead to a clean theory<ul><li>sensitive to exact computational model</li><li>$\Pi$ can be $(t,\epsilon)$ -secure for may choices of $t,\epsilon$</li></ul></li></ul><h4><span id="asymptotic-security">asymptotic security</span></h4><ul><li>introduce security parameter n<ul><li>can view as the key length</li><li>fixed by honest parties at initialization<ul><li>allow users to tailor the security level </li></ul></li><li>known by adversary </li></ul></li><li>measure running times of all parties, the success probability of the adversary, as functions of n</li><li>asymptotic security version<ul><li>security may fail with probability negligible in n </li><li>restrict attention to attackers running in time polynomial in n</li></ul></li></ul><h5><span id="def-34-function-negligibility">Def 3.4 function negligibility</span></h5><ul><li>A function $f: Z^+ \rightarrow Z^+$ is at most polynomial if there exists c such that $f(n) &lt; n^c$ for large enough n</li><li>A function $f: Z^+ \rightarrow [0,1]$ is negligible if for every polynomial p it holds that $f(n) &lt; \frac{1}{p(n)}$ for large enough n</li></ul><h2><span id="3-eav-secure-encryption-schemes">3 EAV-Secure Encryption Schemes</span></h2><h2><span id="4-multiple-encryptions">4 Multiple Encryptions</span></h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全协议第四周学习日志</title>
      <link href="/2023/09/26/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/26/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1><span id="安全协议ban逻辑">安全协议（BAN逻辑）</span></h1><p>安全协议分析假设密码学原语是安全的</p><blockquote><p>学习目标</p><p>理解并掌握BAN逻辑的基本框架</p><p>能够基于BAN逻辑进行分析</p></blockquote><h2><span id="1-安全协议分析方法">1 安全协议分析方法</span></h2><p>安全协议分析目的：证明安全协议的证明<strong>执行过程满足安全需求定义</strong></p><p>安全协议分析活动不仅包含安全协议设计迭代过程中的安全协议分析阶段，也包含<strong>需求定义阶段</strong></p><ul><li>证明协议不安全，找返利</li><li>证明协议安全，困难</li></ul><p>有五种基本方法</p><ol><li>可证明安全理论与方法<ul><li>本质上是一种公理化研究方法</li><li>利用归约论断指出挫败方案或协议的唯一方法是破译或解决极微本原</li><li>具有明确的安全定义和计算化的语义，难以进行自动化分析</li></ul></li><li>形式化分析理论与方法<ul><li>使协议设计者通过系统分析，将注意力集中于接口、系统环境的假设、系统在不同条件下的状态、条件不满足是系统出现的情况及系统不变的属性，并通过系统验证，提供安全保证</li><li>常见三种形式化分析方法<ol><li><strong>以BAN类逻辑为代表的基于推理结构性方法</strong>，运用逻辑系统</li><li><strong>基于攻击结构性方法</strong></li><li><strong>基于证明结构性方法</strong></li></ol></li><li><strong>易于自动化分析，没有计算化的语义</strong></li></ul></li><li>混合理论与方法</li><li>零只是证明理论与方法<ul><li>证明者试图使验证者相信某个论断正确，却不想验证者提供任何有用的信息</li></ul></li><li>安全多方计算理论与方法</li></ol><h2><span id="2-ban逻辑的基本框架">2 BAN逻辑的基本框架</span></h2><p>BAN逻辑是一种分析认证协议的逻辑,是一种关于知识和信念的逻辑,包含每个主体各自维护的信念集合,以及从旧信念推导出新信念的推理规则集合</p><p>BAN逻辑旨在<strong>抽象层次上</strong>讨论认证协议的安全性</p><p>假设:</p><ol><li><p>时间假设</p><ol><li>协议分析中区分两个时间段，过去时间段和当前时间段</li><li>当前时间段开始于协议运行的开始阶段，所有在此时间之前发送的消息都认为是过去时间段发送的消息。</li><li>如果信仰在开始时成立，则在整个当前时间段都成立，而在过去时间段成立的信仰，在当前时间段不一定成立</li></ol></li><li><p>密钥假设</p><ol><li>加密系统是完善的，只有知道密钥的主体才能解读密文消息，任何不知道密钥的主体不能解读密文消息，也没有办法根据密文推导密钥。</li><li>密文块不能被篡改，也不能用几个小的密文块来拼凑成一个新的大的密文块，一个消息中的两个密文块被看作是分两次分别送达的。</li><li>密文中有足够的冗余信息，解密者可以根据解密的结果判断他是否已经正确解密</li><li>消息中有足够的冗余信息，使得主体可以判断该消息是否来源于自身。</li></ol></li><li><p>主题假设</p><ol><li>BAN逻辑还假设协议的参与主体是诚实的。</li></ol></li></ol><p><strong>重点部分:</strong></p><h3><span id="21-ban逻辑构建的语法和语义">2.1 BAN逻辑构建的语法和语义</span></h3><p>BAN逻辑是一种多类型的模态逻辑 many-sorted model logic</p><p>BAN逻辑的语义中主要包含下面三种处理对象：</p><ul><li>主体 principals</li><li>密钥 keys</li><li>公式 formula 也被称为语句或命题 statements</li></ul><p>在BAN逻辑中，</p><ul><li>A，B表示主体， S表示服务器</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004084412595.png" alt="image-20231004084412595"></li><li>$N_a,N_b,N_c$表示随机数</li><li>P、Q、R表示主体变量，K表示密钥变量，X、Y表示公式变量</li></ul><p>包含和取指一种命题连接词，用逗号表示</p><p><strong>BAN逻辑的10个基本逻辑构件</strong></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004084704488.png" alt="image-20231004084704488"></p><h3><span id="22-ban逻辑的推理规则">2.2 BAN逻辑的推理规则</span></h3><p>BAN逻辑的推理规则共19条</p><ul><li><p>消息含义规则</p><ul><li>使主体推知其他主体发送过的消息——说明消息的出处</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004093214446.png" alt="image-20231004093214446">如果P相信$K_{PQ}$使P与Q的共享密钥，并且P曾经接受包含$K_{PQ}$加密的消息X，则P相信Q发送过消息X。</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004093439495.png" alt="image-20231004093439495">如果P相信Q具有密钥公钥$K_Q$，P曾经接受过由私钥加密的X，则P相信Q发送过消息X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004093815317.png" alt="image-20231004093815317">如果P相信PQ共享秘密Y，且P曾经接收过与秘密Y合成的消息X，则P相信Q发送过消息X</li></ol></li><li><p>随机数验证规则</p><ul><li>如果消息使当前发送的，那么消息的发送者应该相信该消息</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094056781.png" alt="image-20231004094056781">如果P相信X使新鲜的，且P相信Q曾经说过X，那么P相信Q相信X</li></ol></li><li><p>管辖规则</p><ul><li>扩展了主体的推知能力</li></ul><ol><li>使主体可以在基于其他主体已有的信仰之上推知新的信仰<img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094300249.png" alt="image-20231004094300249">如果P相信Q对于消息X具有管辖权，且P相信Q相信X，那么P相信X</li></ol></li><li><p>接收消息规则</p><ul><li>定义了主体在协议运行中对消息的获取</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094434132.png" alt="image-20231004094434132">如果P曾经接受过（X，Y)，那么P曾经受到过消息X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094533512.png" alt="image-20231004094533512">如果P曾经接受过带有秘密信息Y的\<x\>，那么P曾经接受过消息X</x\></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094749112.png" alt="image-20231004094749112">如果P相信PQ具有公共密钥$k_{PQ}$，且P接受过用$k_{PQ}$加密的X，那么P接受过X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004094853674.png" alt="image-20231004094853674">如果P相信P具有密钥公钥k,且P接受过用k加密的消息X，那么P接受过消息X</li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004095021514.png" alt="image-20231004095021514">如果P相信Q具有密钥公钥k，且P接受过用私钥加密的X，那么P曾经接受过X</li></ol></li><li><p>新鲜性规则</p><ul><li>如果一个公式的一部分是新鲜的，则该公式的全部是新鲜的</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100038029.png" alt="image-20231004100038029">如果P相信X是新鲜的，则P相信消息（X，Y) 是新鲜的</li></ol></li><li><p>信仰规则</p><ul><li>反应了信念在消息的级联与分割的不同操作中的一致性以及信念在此类操作中的传递性</li></ul><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100544696.png" alt="image-20231004100544696"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100552214.png" alt="image-20231004100552214"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100603723.png" alt="image-20231004100603723"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100610283.png" alt="image-20231004100610283"></li></ol></li><li><p>密钥与秘密共享规则</p><ol><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100729020.png" alt="image-20231004100729020"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100737956.png" alt="image-20231004100737956"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100746413.png" alt="image-20231004100746413"></li><li><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004100756376.png" alt="image-20231004100756376"></li></ol></li></ul><h2><span id="3-应用ban逻辑分析协议的方法">3 应用BAN逻辑分析协议的方法</span></h2><p>基本原理：</p><ul><li>可形式化定义协议的目标，并确定协议初始时刻各参与者的知识和信任，通过协议里信息的发送和接受步骤产生新知识，运用推到规则来得到目标信任和新知识</li><li>如果得到最终的关于知识和信任的语句集里不包含所要得到的信任和知识的语句是，就表明协议存在安全缺陷</li></ul><h3><span id="31-理想化过程">3.1 理想化过程</span></h3><p>省略协议会话中的明文部分，理想化后的协议消息形式为$\{X_1\}_{K_1},\cdots,\{X_n\}_{K_n}$</p><p>指导方针：</p><ul><li>如果任何时候接收者得到了一个真实消息m后能推导出发送者必须相信X，那么m能被解释成一个公式X</li><li>现实中的随机数被转化为任意的新公式</li><li>假定在整个过程中发送这都相信这些公式： \<x\>_Y<ul><li>把Y作为一个秘密使用，仅当该秘密用作身份证明时有效</li><li>出于实用性目的，每个主体总是相信他作为消息产生的公式</li></ul></x\></li></ul><h3><span id="32-认证协议的基本假设">3.2 认证协议的基本假设</span></h3><p>描述协议运行开始时的初始条件</p><p>发送第一条消息以前的公式表示各主体在协议开始时的信条</p><ul><li>各主体之间共享了哪些密钥</li><li>哪些主体能产生新鲜的随机数</li><li>哪些主体在哪方面被信任</li></ul><h3><span id="33-ban逻辑分析协议解释">3.3 BAN逻辑分析协议解释</span></h3><p>用逻辑语言解释理想化后的协议语句</p><p>解释过程遵循以下原则：</p><ul><li>如果在P-&gt;Q:Y之前X成立，则之后X和QΔY都成立</li><li>如果根据推理规则，能从已知的X推导出Y，则X成立时Y必然成立</li><li>如果能从X得到Y，则X成立时Y也成立</li></ul><h3><span id="34-形式化协议目标">3.4 形式化协议目标</span></h3><p>一些对称密码体制的认证协议希望安全的交换会话密钥，形式化描述协议目标为：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004195834918.png" alt="image-20231004195834918"></p><p>确认对方也信任该会话密钥：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004195859976.png" alt="image-20231004195859976"></p><h3><span id="35-ban逻辑分析步骤">3.5 BAN逻辑分析步骤</span></h3><ol><li>对协议进行理想化处理，将协议的实际信息转换成BAN逻辑的公式</li><li>用逻辑语言描述协议初始状态，给出所有的基本假设</li><li>对协议进行解释，将协议会话转换为逻辑语言</li><li>用逻辑语言描述协议所需达到的目标</li><li>应用推理规则对协议进行形式化分析，从协议的开始进行退证，直至验证协议是否满足协议目标</li></ol><h2><span id="4-ban逻辑的应用实例">4 BAN逻辑的应用实例</span></h2><p>NS协议的分析</p><h2><span id="5-ban逻辑的缺陷及改进方向">5 BAN逻辑的缺陷及改进方向</span></h2><h3><span id="51-ban逻辑的缺陷">5.1 BAN逻辑的缺陷</span></h3><ol><li>BAN逻辑基于的基本假设——主题假设存在问题<ul><li>不一定总是诚实</li></ul></li><li>理想化过程存在问题<ul><li>BAN逻辑没有对协议的理想化过程提供标准的转换格式，过分依赖于分析者的直觉</li></ul></li><li>缺乏完备性</li><li>缺乏一个定义良好、确切的语义</li></ol><h3><span id="52-ban逻辑的改进方向">5.2 BAN逻辑的改进方向</span></h3><ul><li>确立一个可靠的语义</li><li>减少理想化步骤的模糊度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 安全协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络内容安全第四周学习日志</title>
      <link href="/2023/09/25/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/25/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2><span id="一-网络信息内容获取模型">一、网络信息内容获取模型</span></h2><p><del><em>PPT乱七八糟绷不住了</em></del></p><h3><span id="10-互联网信息类型">1.0 互联网信息类型</span></h3><ul><li>网络媒体形态<ul><li>广播式媒体<ul><li>新闻网站、论坛、博客</li></ul></li><li>交互式媒体<ul><li>社交媒体、搜索引擎等</li></ul></li></ul></li><li>网络媒体信息<ul><li>互联网网站公开发布的信息，用户通常可以基于通用网络浏览器获取</li></ul></li><li>网络通信信息<ul><li>实现与特定点通信或点对点通信所交互的信息</li></ul></li><li>发布信息类型<ul><li>文本</li><li>图像</li><li>音频</li><li>视频</li></ul></li><li>媒体发布方式<ul><li>匿名</li><li>身份认证</li></ul></li><li>网页形态<ul><li>静态</li><li>动态：含“？”或输入参数的URL</li></ul></li><li>信息交互协议</li><li>专业客户端软件</li></ul><h3><span id="11-网络信息内容获取模型">1.1 网络信息内容获取模型</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/网络环境下的信息内容获取模型.png" alt="img1"></p><p><strong>信息检索</strong> (Information Search， IS)是信息需求者主动搜寻所需要的信息</p><p><strong>信息推荐</strong></p><p><strong>信息交互</strong></p><p><strong>信息浏览</strong></p><h3><span id="12-网络媒体信息获取原理">1.2 网络媒体信息获取原理</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/网络信息获取流程.png" alt="img2"></p><p>网上采集算法（爬虫）</p><h3><span id="13-网络媒体信息获取的分类">1.3 网络媒体信息获取的分类</span></h3><ol><li>全网信息获取</li><li>定点信息获取</li><li>基于主题的信息获取和元搜索<ul><li>元搜索又称多搜索引擎<ul><li>搜索机制分为并行式和串行式</li></ul></li><li>高级检索功能：<ul><li>使用布尔逻辑符检索</li><li>域名过滤</li><li>等等</li></ul></li></ul></li></ol><p>信息获取的技术难点</p><ul><li>网络媒体信息：形态各异、信息类型多样</li><li>DDOS</li></ul><h2><span id="二-搜索引擎技术">二、搜索引擎技术</span></h2><ul><li>网络内容分析</li><li>网页索引</li><li>查询解析</li><li>相关性计算</li></ul><h3><span id="221-网上采集算法">2.2.1 网上采集算法</span></h3><p>爬虫</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/爬虫原理.png" alt="img3"></p><h4><span id="分类">分类</span></h4><ul><li>通用网络爬虫</li><li>聚焦网络爬虫</li><li>增量式网络爬虫</li><li>深层网络爬虫</li></ul><h4><span id="原理">原理</span></h4><ol><li>初始URL集合</li><li>信息获取</li><li>信息解析</li><li>信息判重<ol><li>URL判重</li><li>内容摘要判重</li></ol></li></ol><h4><span id="url爬取策略">URL爬取策略</span></h4><ul><li>深度优先遍历策略</li><li>广度优先遍历策略</li><li>反向链接数策略：一个网页被其他网页链接指向的数量</li><li>Partial PageRank策略</li><li>OPIC策略 online page importance computation </li><li>大站优先策略</li></ul><h3><span id="222-排级算法">2.2.2 排级算法</span></h3><h4><span id="pagerank">PageRank</span></h4><p>原理：民主表决</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/PR算法.png" alt="img4"></p><script type="math/tex; mode=display">\Pr(t) = (1-d) + d(\sum_{i=1}^{n}{\frac{\Pr(t_i)}{|t_i|}})</script><p>$\Pr(t_i)$入度; $|t_i|$出度 $d$影响因子</p><font color="red">入度为什么是概率呢？</font><p>优点：</p><ol><li>直接高效</li><li>主题集中</li></ol><p>缺点：</p><ol><li>忽略网页内容，干扰挖掘结果</li><li>结果范围窄</li><li>影响因子与网页获取数量缺乏科学性</li></ol><p>用来表现网页等级的一个标准，0-10，值越高越受欢迎</p><h4><span id="hits">HITS</span></h4><p><strong>Hub</strong>页面（枢纽页面）指向高质量链接的网页</p><p><strong>Authority</strong>页面（权威页面）相关领域高质量网页</p><p><strong>枢纽值</strong> Hub Scores = sum of all relevant Authority scores</p><p><strong>权威值</strong> Authority Scores = sum of all relevant Hub scores</p><p>基本思想：<strong>相互增强关系</strong></p><h5><span id="算法"><strong>算法</strong></span></h5><ol><li>构建根集合</li><li>扩展集合Base</li><li>计算扩展集base中所有页面的Hub值和Authority值</li><li>排序，结果输出</li></ol><p><strong>优点</strong></p><ol><li>知识范围扩大</li><li>搜索时部分地考虑了页面内容，挖掘结果科学性大大增强</li></ol><p><strong>缺点</strong></p><ol><li>效率低，实时性差</li><li>主题漂移</li><li>易被操纵者操纵结果</li><li>结构不稳定</li></ol><h3><span id="223-搜索引擎与垃圾消息关系">2.2.3 搜索引擎与垃圾消息关系</span></h3><p>垃圾信息制造手段</p><ul><li>提高排名技术 boosting<ul><li>关键字垃圾 term spamming</li><li>链接垃圾 link spamming</li></ul></li><li>隐藏技术 hiding<ul><li>隐藏Boosting技术</li><li>content hiding、 cloaking、 redirection</li></ul></li></ul><h2><span id="三-数据挖掘技术">三、数据挖掘技术</span></h2><p>数据挖掘：通过从数据库中抽取<strong>隐含的</strong>、<strong>未知的</strong>、<strong>具有潜在使用价值</strong>的过程</p><h3><span id="232-web挖掘技术">2.3.2 Web挖掘技术</span></h3><p>从大量<strong>非结构化、异构</strong>的Web信息资源中发现兴趣性的知识，包括概念、模式、规则、规律、约束及可视化等形式的非平凡过程。</p><p>挖掘过程</p><ol><li>资源发现</li><li>信息选择与预处理</li><li>综合过程</li><li>分析过程</li></ol><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004222043807.png" alt="image-20231004222043807"></p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004222027301.png" alt="image-20231004222027301"></p><h3><span id="233-web文本挖掘技术">2.3.3 Web文本挖掘技术</span></h3><p>从Web文档和Web活动中发现、抽取感兴趣的、潜在有用的模式和隐藏的信息的过程</p><p>定义：从大量文本的集合C中发现隐含的模式p。如果将C当作输入，p当作输出，那么Web文本挖掘的过程就是从输入到输出的一个映射。</p><h2><span id="四-信息推荐技术">四、信息推荐技术</span></h2><p>信息推荐与信息检索的区别：</p><p>关注点上：信息检索侧重检索结果，信息推荐侧重服务对象</p><p>主动性上：信息检索侧重用户主导，信息推荐侧重系统主导</p><h3><span id="241-信息推荐概念和形式化定义">2.4.1 信息推荐概念和形式化定义</span></h3><p>非形式化定义：利用电子商务网站向客户提供商品信息和建议，帮助用户决定应购买什么产品，模拟销售人员帮助客户完成购买过程。</p><p>信息推荐有三个组成要素：<strong>推荐候选对象、用户、推荐方法</strong></p><p>形式化定义：</p><p>设C是所有用户的集合，S是所有可以推荐给用户的商品对象的集合，效用函数u()用以计算对象s对用户c的推荐度和产品的可得性，即：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004230008763.png" alt="image-20231004230008763"></p><p>R是一定范围内的全序的非负实数，信息推荐要研究的问题就是找到推荐度R最大的那些对象$s^*$，即：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004230108996.png" alt="image-20231004230108996"></p><blockquote><p>arg   是变元（即自变量argument）的英文缩写。<br>arg min 就是使后面这个式子达到最小值时的变量的取值<br>arg max 就是使后面这个式子达到最大值时的变量的取值</p></blockquote><h3><span id="242-信息推荐算法">2.4.2 信息推荐算法</span></h3><p><strong>基于内容推荐</strong></p><p><strong>根据用户已选择的对象</strong>，推荐其他类似属性的对象作为推荐</p><ul><li><strong>对象内容特征</strong> Content(s)：以对象的文字描述为主</li><li><strong>用户的资料模型</strong> ContentBasedProfile(c)：取决于机器学习方法</li><li>u(c,s) = score(ContentBasedProfile(c), Content(s))</li></ul><p><strong>协同过滤推荐</strong></p><p>推荐<strong>相似用户</strong>所选择的对象</p><ul><li>找到与当前用户相似的其他用户</li><li>计算对象s对于用户的效用值</li><li>利用效用值对所有s进行排序或加权操作，找到$s^*$</li></ul><p><strong>启发式方式</strong>：使用与新用户c相似的用户c’对一个对象的评价来预测效用</p><p>基于模型的方法：利用用户c对众多对象的评分来学习一个c的模型，然后使用概率方法对新的对象s的推荐效用进行预测</p><p>组合推荐：前/中/后融合组合推荐</p><p>后融合：结果层次上的融合</p><p>中融合：以一种推荐方法做框架，融合另一种推荐方法</p><p>前融合：直接融合</p><h2><span id="五-信息还原技术">五、信息还原技术</span></h2><h3><span id="251-电脑还原技术">2.5.1 电脑还原技术</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231004231537426.png" alt="image-20231004231537426"></p><h3><span id="252-网页还原技术">2.5.2 网页还原技术</span></h3><ul><li>数据包捕获技术——网卡接收方式为混杂方式</li><li>协议还原技术<ul><li>数据包捕获、重组、存储、分发</li></ul></li><li>网页内容还原技术</li></ul><h3><span id="253-多媒体信息还原技术">2.5.3 多媒体信息还原技术</span></h3><ul><li>基于解码器</li><li>基于封装</li><li>基于远程线程注入</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络内容安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工科数学分析第二章——数列极限</title>
      <link href="/2023/09/23/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/23/%E6%B7%91%E8%8A%AC%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1><span id="第2章-数列极限">第2章 数列极限</span></h1><blockquote><p>为了避免形式主义的情况，这里主要记录一些容易以文字形式呈现或公式呈现不是特别困难的一些式子</p></blockquote><h2><span id="21-数列的极限">2.1 数列的极限</span></h2><h3><span id="211数列极限的定义">2.1.1数列极限的定义</span></h3><p>数列就是按照正整数编号的一列实数:</p><script type="math/tex; mode=display">a_1,a_2,\cdots,a_n,\cdots</script><p>通常记为$\{a_n\}_{n \geq 1}$或简记为$\{a_n\}$，其中$a_n$称为数列的通项</p><h4><span id="定义211">定义2.1.1</span></h4><p>设$\{a_n\}$是一个数列，a是一个给定的师叔，如果对任意给定的$\epsilon &gt; 0$，总存在一个正整数N，使得当$n&gt;N$时，$\left\vert a_n - a \right\vert &lt; \epsilon$，则称$\{a_n\}$收敛于a，或者称a为数列的极限，记为$\lim_{n \rightarrow \infty}{a_n = a}$</p><p>当数列有极限时，则称数列收敛，否则发散。</p><p><strong>e.g.</strong></p><p>设$a&gt;1$是给定的正数，证明$lim_{n \rightarrow \infty}{\frac{n}{a^n}} = 0$</p><p>由二项式定理证明指数表示成多项式的最高次幂高于任意的多项式</p><h3><span id="212极限定义的否定形式">2.1.2极限定义的否定形式</span></h3><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}{a_n \neq a} \Leftrightarrow \exists \epsilon_0 > 0, s.t. \forall N \in N^*, \exists n_0 > N, \left\vert {a_{n_0} - a}\right\vert \ge \epsilon_0</script><h2><span id="22-数列极限的性质和运算">2.2 数列极限的性质和运算</span></h2><h4><span id="定理221-极限唯一性">定理2.2.1 极限唯一性</span></h4><p>收敛数列的极限是唯一的</p><h4><span id="定义221">定义2.2.1</span></h4><p>给定$\{a_n\}$，如果存在一个实数A，s.t.对所有的n都有$a_n \le  A (a_n \ge A)$，则称此数列有上界(下界)，A称为该数列的一个上界（下界），如果该数列既有上界又有下界，则称该数列有界</p><h4><span id="定理222-有界性">定理2.2.2 有界性</span></h4><p>收敛数列都是有界的</p><h4><span id="定理223-保序性">定理2.2.3 保序性</span></h4><ol><li>设$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b}$，若$a&gt;b$，则$\exists N \in N^*, s.t. n&gt;N时, a_n&gt;b_n$</li><li>若$a_n\ge b_n(n=1,2,\cdots),\lim_{n\rightarrow\infty}{a_n}=a,\lim_{n\rightarrow\infty}{b_n=b}$，则$a\ge b$</li></ol><p><strong>推论（保号性）-简记</strong></p><ol><li>若a&gt;0,则$a_n &gt; 0$</li><li>若$a_n &gt; 0$,则a&gt;0</li></ol><h4><span id="定义222">定义2.2.2</span></h4><p>设$\{a_n\}$是一个数列，任给正整数列$n_1 &lt; n_2 &lt; n_3 &lt; \cdots$，称数列$a_{n_1},a_{n_2},a_{n_3},\cdots$为$\{a_n\}$的一个子列，记为$\{a_{n_k}\}$</p><h4><span id="定理224-数列极限与子列极限的一致性">定理2.2.4 数列极限与子列极限的一致性</span></h4><p>若$\{a_n\}$的极限为a，则他的任意子列极限也为a。</p><h4><span id="定理225-数列极限的四则运算">定理2.2.5 数列极限的四则运算</span></h4><ol><li>若$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b}$，则数列$\{a_n \pm b_n\}$收敛，极限为$a \pm b$</li><li>若$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b}$，则数列$\{a_n b_n\}$收敛，极限为ab</li><li>若$\lim_{n\rightarrow\infty}{a_n=a},\lim_{n\rightarrow\infty}{b_n=b\neq0}$，则数列$\{\frac{a_n}{b_n}\}$收敛，极限为$\frac{a}{b}$</li></ol><h4><span id="定理226-夹逼定理">定理2.2.6 夹逼定理</span></h4><p>假设数列$\{a_n\}$、$\{b_n\}$、$\{c_n\}$，满足$a_n\le b_n \le c_n$，且$\lim_{n\rightarrow\infty}{a_n=c_n=a}$则$b_n$极限也为a</p><h2><span id="23-无穷小和无穷大">2.3 无穷小和无穷大</span></h2><h3><span id="231-无穷小">2.3.1 无穷小</span></h3><h4><span id="定义231-无穷小数列">定义2.3.1 无穷小数列</span></h4><p>若数列$\{a_n\}$的极限为0，则成这个数列为无穷小数列，简称无穷小</p><h4><span id="定理231">定理2.3.1</span></h4><ol><li>数列$\{a_n\}$为无穷小的充要条件是$\{|a_n|\}$是无穷小</li><li>两个无穷小数列的和或差依旧是无穷小数列</li><li>设$\{a_n\}$为无穷小，$\{c_n\}$为有界数列，则$\{a_nc_n\}$为无穷小数列</li><li>设$0\le a_n \le b_n$若$\{b_n\}$为无穷小，则$\{a_n\}$也为无穷小</li><li>$\lim_{n\rightarrow\infty}{a_n=a} \Leftrightarrow \{a_n -a \}无穷小$</li></ol><h3><span id="232-无穷大">2.3.2 无穷大</span></h3><h4><span id="定义232">定义2.3.2</span></h4><p>设$\{a_n\}$是一个数列，如果对任意给定的整数M，总存在正整数N，使得当$n&gt;N$时，有$|a_n| &gt; M$，则称$\{a_n\}$无穷大，记为$\lim_{n\rightarrow\infty}{a_n =  \infty}$</p><h4><span id="性质231">性质2.3.1</span></h4><ol><li>$\{a_n\}$无穷大，则$\{a_n\}$无界</li><li>任何无界数列都有无穷大的子列</li><li>若$\{a_n\}$极限为正无穷，$\{b_n\}$极限为正无穷，则它们的和数列或奇数列也为无穷数列</li></ol><h4><span id="性质232">性质2.3.2</span></h4><p>$\{a_n\}$无穷大 等价于 $\{\frac{1}{a_n}\}$无穷小</p><h3><span id="232-stolz定理">2.3.2 Stolz定理</span></h3><h4><span id="定理232-fracinftyinfty">定理2.3.2 $\frac{\infty}{\infty}$</span></h4><p>设$\{b_n\}$是严格递增趋于正无穷的数列，如果</p><script type="math/tex; mode=display">\lim_{n\rarr\infty} \frac{a_n - a_{n-1}}{b_n-b_{n-1}} = A</script><p>则$\lim_{n\rightarrow\infty}\frac{a_n}{b_n}=A$</p><h4><span id="定理233-frac00">定理2.3.3 $\frac{0}{0}$</span></h4><p>设$\{b_n\}$ $\{a_n\}$都是无穷小的数列且$\{b_n\}$严格单调，如果</p><script type="math/tex; mode=display">\lim_{n\rarr\infty} \frac{a_n - a_{n-1}}{b_n-b_{n-1}} = A</script><p>则$\lim_{n\rightarrow\infty}\frac{a_n}{b_n}=A$</p><h2><span id="24-单调数列的极限及其应用">2.4 单调数列的极限及其应用</span></h2><h4><span id="定义241-单调数列">定义2.4.1 单调数列</span></h4><p>$a_n \le a_{n+1}$单调递增，$a_n &lt; a_{n+1}$ 严格单调</p><h4><span id="定理241-单调有界定理">定理2.4.1 单调有界定理</span></h4><p>若$\{a_n\}$单调递增且有上界，则数列收敛，递减类似</p><p>e.g. 2.4.3</p><font color="red">不要忘记stolz定理啊</font><h4><span id="引理-bernoulli-不等式">引理 Bernoulli 不等式</span></h4><p>对任意的$x&gt;1, x\neq 0, n\ge 2, (1+x) ^ n &gt; 1 + nx$</p><p>e.g. 2.4.4</p><p>$\lim_{n\rightarrow\infty}{1 + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n} - \ln n} = \gamma$欧拉常数，0.57721566…</p><h4><span id="定理242">定理2.4.2</span></h4><ol><li>若单调数列有一个子列收敛，则这个数列收敛</li><li>若单调数列有一个子列趋于$\infty$，则数列也趋于$\infty$</li><li>一个单调数列有么极限存在，有么趋于无穷</li><li>单调数列收敛的充要条件是数列有界</li></ol><h2><span id="25-实数连续性的基本定理">2.5 实数连续性的基本定理</span></h2><h4><span id="定理251-闭区间套定理">定理2.5.1 闭区间套定理</span></h4><p>设$I_n=[a_n,b_n]$为一列闭区间，满足：</p><ol><li>$I_1 \supset I_2 \supset \cdots \supset I_n \supset \cdots $</li><li>这些闭区间的长度满足$\lim_{n\rightarrow\infty}{|I_n|} = \lim_{n\rightarrow\infty}{b_n-a_n}=0$则存在唯一的点$\xi \in  \bigcap_{i=1}^{\infty}I_i$</li></ol><p>通常满足条件1的一列闭区间是一个闭区间套</p><h4><span id="定理252-列紧性定理">定理2.5.2 列紧性定理</span></h4><p>任何有界的无穷数列中都存在收敛的子列</p><h4><span id="定义251-基本列定义">定义2.5.1 基本列定义</span></h4><p>给定$\{a_n\}$，若满足：$\forall \epsilon &gt; 0, \exists N, s.t. \forall n,m &gt; N, |a_m - a_n| &lt; \epsilon$则称$\{a_n\}$为一个基本列（Cauchy列），这里的N仅与$\epsilon$有关</p><p>等价定义m=n+p的形式，对于一切$p\in N^*$成立</p><h4><span id="定理253-数列极限的cauchy收敛原理">定理2.5.3 数列极限的Cauchy收敛原理</span></h4><p>$\{a_n\}$收敛的充要条件是$\{a_n\}$是基本列</p><h4><span id="定义252">定义2.5.2</span></h4><p>设E是实数集，$\aleph=\{I_\lambda|\lambda\in\Delta\}$是一个开区间族，其中$\Delta$是一个指标集，如果$E\subset\bigcup_{\lambda\in\Delta}I_\lambda$则称，$\aleph$覆盖了E，或者说是一个开覆盖</p><h4><span id="定理254-heine-borel定理">定理2.5.4 Heine-Borel定理</span></h4><p>设$\aleph=\{I_\lambda|\lambda\in\Delta\}$为有限闭区间[a,b]任意一个开覆盖，则可从$\aleph=\{I_\lambda|\lambda\in\Delta\}$中选出有限个开区间构成[a,b]的覆盖</p><h2><span id="26-上极限与下极限的概念和性质">2.6 上极限与下极限的概念和性质</span></h2><h4><span id="定义261">定义2.6.1</span></h4><p>设$\{a_n\}$是一个有界数列，令</p><script type="math/tex; mode=display">\overline{a_n} = sup_{k \ge n}\{a_k\} = sup\{a_n,a_{n+1}, \cdots, \} \\\underline{a_n} = inf_{k \ge n}\{a_k\} = inf\{a_n,a_{n+1}, \cdots, \}</script><p>上数列和下数列</p><h4><span id="定义262">定义2.6.2</span></h4><p>设$\{a_n\}$是一个有界数列，则称$\lim_{n\rightarrow\infty}\overline{a_n}$为$\{a_n\}$上极限，反之下极限</p><h4><span id="定理261">定理2.6.1</span></h4><p>设$\{a_n\}$是一个有界数列，则数列$\{a_n\}$收敛充要条件是极限等于上极限等于下极限</p><h4><span id="定理262">定理2.6.2</span></h4><p>设$\{a_n\}$$\{b_n\}$是有界数列，若存在$N\in N^*,s.t. n&gt;N时 a_n\le b_n，则n&gt;N时，a_n\le b_n,\overline{a_n} \le \overline{b_n}$</p><h4><span id="定理263">定理2.6.3</span></h4><p>设$\{a_n\}$有界</p><ol><li>对任意的$M &gt; \overline{\lim_{n\rightarrow\infty}}{a_n}$，都存在$N\in N^*, s.t. n&gt; N 时 a_n&lt;M$</li><li>对任意的$m &lt; \underline{\lim_{n\rightarrow\infty}}{a_n}$，都存在$N\in N^*, s.t. n&gt; N 时 a_n&gt;m$</li></ol><h4><span id="定理264">定理2.6.4</span></h4>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp学习日志</title>
      <link href="/2023/09/23/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/23/cpp%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考主教程：<a href="https://light-city.github.io/">C++那些事 (light-city.github.io)</a></p></blockquote><h1><span id="基础进阶部分">基础进阶部分</span></h1><h2><span id="const那些事">const那些事</span></h2><ol><li><p>含义：const说明的类型叫做常类型，常类型的变量或对象的值是不能被更新的</p></li><li><p>作用：</p><ol><li><p>可以定义常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li><p>类型检查</p><p>const常量与#define宏定义的常量区别： const 常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，知识简单的字符串替换，不能进行安全检查。</p><p><code>const</code>定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。</p></li><li><p>防止修改，起保护作用，加强Robustness</p></li><li><p>节省空间，避免不必要的内存分配</p><p>const只是给出了对应的内存地址，而不是像#define一样给出的立即数，const在程序运行过程中一份copy，而#define有若干个copy</p></li></ol></li><li><p>const对象默认为文件局部变量</p><font color="red">非const变量默认为extern， 要使const变量能够在其他文件中访问，必须在文件中显性指定它为extern</font></li><li><p>定义常量</p><ol><li>常量不可更改</li><li>常量必须初始化</li></ol></li><li><p>指针与const</p><ol><li><p>四种相关的const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *a;  <span class="comment">//指向const对象的指针或者说指向常量的指针</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *a; <span class="comment">//同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向类型对象的const指针，或者说常指针、const指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针</span></span><br></pre></td></tr></table></figure><p><strong>允许把非const对象的地址赋给指向const对象的指针</strong></p><p>这时无法通过该指针来修改变量的值，即使指向的是非const对象，也不能通过<code>void *</code> 指针来保存const对象的地址，必须使用从const void * 类型的指针保存const对象的地址</p></li><li><p>常指针</p><p>const指针必须初始化，且指针的值不能修改</p></li><li><p>指向常量的常指针</p></li></ol></li><li><p>函数中使用const</p><ol><li><blockquote><p>const 修饰函数返回值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> * <span class="title">func</span><span class="params">()</span> <span class="comment">// 指针所指不可变</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="type">const</span> <span class="title">func</span><span class="params">()</span> <span class="comment">//指针不可变</span></span></span><br></pre></td></tr></table></figure><ol><li><blockquote><p>const 修饰函数参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(const int var) // 传递过来的参数不可变</span><br><span class="line">void func(int *const var) //指针不可变7</span><br></pre></td></tr></table></figure></li></ol></li><li><p>类中使用const</p><ul><li><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型，如果在编写const成员函数时，不慎修改数据成员，或者调用了其他非const成员函数，编译器将指出错误，提高程序健壮性。</p></li><li><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，否能不能操作常对象</p></li><li><p>对于类中的const成员变量必须通过初始化列表进行初始化</p></li><li><p>```cpp<br>class Apple<br>{<br>private:<br> int people[100];<br>public:<br> Apple(int i);<br> const int apple_number;<br>};</p></li></ul><p>Apple::Apple(int i):apple_number(i)<br>{</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">- ```cpp</span><br><span class="line">  //apple.cpp</span><br><span class="line">  class Apple</span><br><span class="line">  &#123;</span><br><span class="line">  private:</span><br><span class="line">      int people[100];</span><br><span class="line">  public:</span><br><span class="line">      Apple(int i); </span><br><span class="line">      const int apple_number;</span><br><span class="line">      void take(int num) const;</span><br><span class="line">      int add(int num);</span><br><span class="line">      int add(int num) const;</span><br><span class="line">      int getCount() const;</span><br><span class="line">  </span><br><span class="line">  &#125;;</span><br><span class="line">  //main.cpp</span><br><span class="line">  #include&lt;iostream&gt;</span><br><span class="line">  #include&quot;apple.cpp&quot;</span><br><span class="line">  using namespace std;</span><br><span class="line">  </span><br><span class="line">  Apple::Apple(int i):apple_number(i)</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::add(int num)&#123;</span><br><span class="line">      take(num);</span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::add(int num) const&#123;</span><br><span class="line">      take(num);</span><br><span class="line">  &#125;</span><br><span class="line">  void Apple::take(int num) const</span><br><span class="line">  &#123;</span><br><span class="line">      cout&lt;&lt;&quot;take func &quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  int Apple::getCount() const</span><br><span class="line">  &#123;</span><br><span class="line">      take(1);</span><br><span class="line">  //    add(); //error</span><br><span class="line">      return apple_number;</span><br><span class="line">  &#125;</span><br><span class="line">  int main()&#123;</span><br><span class="line">      Apple a(2);</span><br><span class="line">      cout&lt;&lt;a.getCount()&lt;&lt;endl;</span><br><span class="line">      a.add(10);</span><br><span class="line">      const Apple b(3);</span><br><span class="line">      b.add(100);</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  //编译： g++ -o main main.cpp apple.cpp</span><br><span class="line">  //结果</span><br><span class="line">  take func 1</span><br><span class="line">  2</span><br><span class="line">  take func 10</span><br><span class="line">  take func 100</span><br><span class="line">     </span><br></pre></td></tr></table></figure><ul><li><p>getCount()中调用的add方法由于其非const修饰，所以会导致运行报错，即const对象只能访问const成员函数</p></li><li><p>而add调用了const修饰的take，证明了非ocnst对象可以访问任意的成员函数，包括const成员函数</p></li><li><p>add的一个重载函数，也输出了两个结果，说明const对象默认调用const成员函数</p></li></ul><p>还有其他方法能够初始化const常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line"><span class="comment">// 将常量定义与static结合</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h2><span id="static-那些事">static 那些事</span></h2><p>当与不同类型一起使用时，static含义不同：</p><ul><li>静态变量：函数中的变量，类中的变量</li><li>静态类的成员：类对象和类中的函数（类的实例是类对象）</li></ul><p>具体用法：</p><h3><span id="静态变量">静态变量</span></h3><h4><span id="1-函数中的静态变量">1 函数中的静态变量</span></h4><p>当变量声明为static时，空间将在<strong>程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。这对于在C/C++或需要存储先前函数状态的任何其他应用程序非常有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// static variable </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// value is updated and </span></span><br><span class="line">    <span class="comment">// will be carried to next </span></span><br><span class="line">    <span class="comment">// function calls </span></span><br><span class="line">    count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)  </span><br><span class="line">        <span class="built_in">demo</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output： 0 1 2 3 4 </span></span><br></pre></td></tr></table></figure><p>可以看出static变量的值是通过函数调用来传递。每次调用的时候不会对该变量进行初始化。</p><h4><span id="2-类中的静态变量">2 类中的静态变量</span></h4><p>由于声明为static的变量只被初始化一次，因为他们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>，对于不同的对象，不能有相同静态变量的多个副本。因此，静态变量不能使用构造函数初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Apple</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">Apple obj1; </span><br><span class="line">Apple obj2; </span><br><span class="line">obj1.i =<span class="number">2</span>; </span><br><span class="line">obj2.i = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// prints value of i </span></span><br><span class="line">cout &lt;&lt; obj1.i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;obj2.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个无法通过编译，因为i并没有初始化。因此，类中的静态变量应由用户使用的类外的类名和范围解析运算符显示初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">class Apple </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">    static int i; </span><br><span class="line"></span><br><span class="line">    Apple() </span><br><span class="line">    &#123; </span><br><span class="line">        // Do nothing </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line">int Apple::i = 0; // 显式初始化静态变量</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    Apple obj1; </span><br><span class="line">    Apple obj2; </span><br><span class="line"></span><br><span class="line">    // 对静态变量进行赋值</span><br><span class="line">    Apple::i = 2; </span><br><span class="line"></span><br><span class="line">    // 输出静态变量的值</span><br><span class="line">    cout &lt;&lt; Apple::i &lt;&lt; endl; // 输出: 2</span><br><span class="line">    cout &lt;&lt; obj1.i &lt;&lt; endl;    // 输出: 2</span><br><span class="line">    cout &lt;&lt; obj2.i &lt;&lt; endl;    // 输出: 2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="静态成员">静态成员</span></h3><h4><span id="类对象为静态">类对象为静态</span></h4><p>就像变量一样，对象也在声明为static时具有范围，知道程序的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">Apple</span>() </span><br><span class="line">        &#123; </span><br><span class="line">            i = <span class="number">0</span>; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside Constructor\n&quot;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">Apple</span>() </span><br><span class="line">        &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside Destructor\n&quot;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        Apple obj; </span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>其中Apple()为构造函数，在对象创建时被调用，用于初始化对象的成员变量，分配资源等操作</li><li>~Apple()为析构函数，在对象被销毁时自动调用，用于清理对象使用的资源，释放内存等。</li><li>对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用</li></ul><p>如果改为了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">static</span> Apple obj; </span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>则析构函数的输出坏在main结束后调用析构函数。</p><h4><span id="类中的静态函数">类中的静态函数</span></h4><p>类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和 <code>.</code> 来调用静态用户函数。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，他们无法访问类的非静态数据成员或成员函数</p><hr><h2><span id="this-指针那些事">this 指针那些事</span></h2><p>python里的self类比到c++中就是this指针。</p><p>this 指针的用处：</p><ol><li>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(object)的结果</li><li>this作用域是在类内部，在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使没有写上this指针，编译器在编译时也是加上this的，他作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</li></ol><p>其次，使用如下：</p><ol><li>在类的非静态成员函数中返回类对象本身的时候，直接使用 <code>return *this</code></li><li>当参数与成员变量名相同时，如 <code>this-&gt;n = n</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">        BOY = <span class="number">0</span>, </span><br><span class="line">        GIRL </span><br><span class="line">    &#125;SexType;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">char</span> *n, <span class="type">int</span> a,SexType s)&#123;</span><br><span class="line">        name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name,n);</span><br><span class="line">        age=a;</span><br><span class="line">        sex=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">add_age</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        age+=a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    SexType sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">20</span>,Person::BOY)</span></span>; </span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">get_age</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">add_age</span>(<span class="number">10</span>).<span class="built_in">get_age</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在类中，与类名相同的函数是构造函数，例子中的Person(char *n, int a,SexType s)就是构造函数</li><li><code>&amp;</code>符号用于声明引用，它允许我们在不复制对象的情况下对对象进行操作。<code>p.add_age(10).get_age()</code>就是很好的例子</li><li><code>public</code>与 <code>private</code>是用于控制类成员访问权限的关键字<ul><li><code>public</code>意味着这些成员可以在类的外部和内部访问</li><li><code>private</code>的成员只能在类的内部访问</li></ul></li><li>通过断点查看，发现编译器会为我们的this指针自动加上 <code>A* const</code> 而不是 <code>A const *</code>，即指向A对象的常指针，这样限定了指针的地址无法变化。</li><li>如果是const函数，则会将this指针变为 <code>const A* const</code></li></ul><h2><span id="inline-那些事">inline 那些事</span></h2><h3><span id="类中关联">类中关联</span></h3><p>头文件中声明方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param x</span></span><br><span class="line"><span class="comment">     * @param y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">///&lt; 定义即隐式内联函数！</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">///&lt; 声明后，要想成为内联函数，必须在定义处加inline关键字。  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Foo()函数被声明在类内部，没有显示使用 <code>inline</code>关键字来修饰，这种情况下被视为隐式内联函数。</li><li>隐式内联函数与由<code>inline</code>声明的显示内联函数的区别在于编辑器是否强制内联函数的决定权。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @param y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">// 函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处加inline关键字，推荐这种写法！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::f1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">Foo</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译器对 inline 函数的处理步骤</span></span><br><span class="line"><span class="comment"> * 将 inline 函数体复制到 inline 函数调用点处；</span></span><br><span class="line"><span class="comment"> * 为所用 inline 函数中的局部变量分配内存空间；</span></span><br><span class="line"><span class="comment"> * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</span></span><br><span class="line"><span class="comment"> * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>内联能提高函数效率，但并不是所有函数都定义成内联函数！内联是以代码膨胀为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p><ul><li>如果执行函数内代码的时间相比于函数调用的开销较大，那么效率的收获会更少</li><li>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大， 消耗更多的内存空间。</li></ul><p>以下情况不宜用内联：</p><ul><li>如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高</li><li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li><li>比较复杂的函数或者某些情况下（递归函数）可能无法内联展开</li></ul><blockquote><p>GOTO 是一种在编程中用于控制程序流程的语句，允许将程序跳转到指定的位置。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string userInput;</span><br><span class="line">    </span><br><span class="line">    start:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Do you want to continue? (yes/no): &quot;</span>;</span><br><span class="line">    cin &gt;&gt; userInput;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userInput == <span class="string">&quot;yes&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Continuing...\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 执行相关操作</span></span><br><span class="line">        <span class="keyword">goto</span> start; <span class="comment">// 跳转到标签 start 处</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userInput == <span class="string">&quot;no&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Exiting...\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid input. Please enter &#x27;yes&#x27; or &#x27;no&#x27;.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> start; <span class="comment">// 如果输入不是 &#x27;yes&#x27; 或 &#x27;no&#x27;，重新询问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用GOTO容易导致程序的逻辑难以理解和维护，实际编程中，尽量少使。。。</p><h2><span id="虚函数-virtual-可以是-内联函数-inline-吗">虚函数 virtual 可以是 内联函数 inline 吗？</span></h2><blockquote><p>虚函数 virtual function </p><p>是一种特殊的成员函数，它可以在派生类中被重写（覆盖）以提供特定于派生类的实现。虚函数通过在基类中使用关键字‘virtual’来声明，而在派生类中使用相同的函数签名来重写。</p><p>虚函数的存在使得在基类指针或引用指向派生类对象时，可以根据实际指向的对象类型来调用相应的函数实现，而不是根据指针或引用的静态类型来确定调用哪个函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;obj1;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Base class</span></span><br><span class="line"></span><br><span class="line">    ptr = &amp;obj2;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>虚函数可以是内联函数，内联时可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行调用哪个代码，因此虚函数表现为多态性时不可以内联</li><li><code>inline virtual</code>唯一可以内联的时候是：编译器知道所调用的是哪个类，这只有编译器具有实际对象而不是对象的指针或引用时才会发生</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2><span id="sizeof-那些事">Sizeof 那些事</span></h2><ul><li>空类的大小为1byte</li><li>一个class中，virtual function 、成员函数、静态数据成员都是不占用类对象的存储空间</li><li>对于包含虚函数的类，不管有多少虚函数，只有一个虚指针， vptr的大小</li><li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li><li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。32位 4byte; 64bit 8byte</li><li>虚继承，继承基类的vptr</li></ul><blockquote><p>具体的代码实例先不展示，对于密码学竞赛的帮助应该不是特别大</p></blockquote><h2><span id="纯虚函数和抽象类那些事">纯虚函数和抽象类那些事</span></h2><h3><span id="纯虚函数与抽象类">纯虚函数与抽象类</span></h3><p>C++中的纯虚函数或抽象函数是我们没有实现的虚函数，我们只需声明他。通过声明中赋值0来声明纯虚函数！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供了 draw() 的具体实现</span></span><br><span class="line">        <span class="comment">// 这里是绘制一个圆的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供了 draw() 的具体实现</span></span><br><span class="line">        <span class="comment">// 这里是绘制一个正方形的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其中Shape是一个抽象类，draw()是一个纯虚函数，因此Shape不能被实例化，只能被用作派生类的基类</li><li>如果它的派生类不是抽象类，则必须提供纯虚函数的实现</li><li></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file pure_virtual.cpp</span></span><br><span class="line"><span class="comment"> * @brief 纯虚函数：没有函数体的虚函数</span></span><br><span class="line"><span class="comment"> * 抽象类：包含纯虚函数的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 1. 抽象类只能作为基类来派生新类使用</span></span><br><span class="line"><span class="comment">   * 2. 抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  A a; <span class="comment">// error 抽象类，不能创建对象</span></span><br><span class="line"></span><br><span class="line">  A *a1; <span class="comment">// ok 可以定义抽象类的指针</span></span><br><span class="line"></span><br><span class="line">  A *a2 = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// error, A是抽象类，不能创建对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="实现抽象类">实现抽象类</span></h3><p>抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。</p><p>如果一个类从抽象类派生而来，他必须实现了基类中的<strong>所有</strong>纯虚函数，才能成为非抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file abstract.cpp</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * 抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数</span></span><br><span class="line"><span class="comment"> * 如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">f</span>(); &#125;</span><br><span class="line">  <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B:f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">g</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="重要点">重要点</span></h3><ul><li>纯虚函数使一个类变成抽象类</li><li>抽象类类型的指引和引用</li><li>如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类</li><li>抽象类可以有构造函数</li><li>构造函数不能是虚函数，而析构函数可以是虚析构函数</li></ul><p>当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。如果析构函数不是虚拟的，则只能调用基类析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file derived_full.cpp</span></span><br><span class="line"><span class="comment"> * @brief 完整示例！抽象类由派生类继承实现！</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun() called&quot;</span>; &#125; <span class="comment">// 实现了fun()函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  Derived d;</span><br><span class="line">  d.<span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="vptr与vtable那些事">Vptr与vtable那些事</span></h2><h3><span id="基础理论">基础理论</span></h3><p>为了实现虚函数，C++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表时用于解决在动态/后期绑定方法的函数调用函数的查找表。虚拟表有时会使用其他名称，例如’vtable’，’虚函数表’，’虚方法表’，’调度表’</p><p>虚拟表实际上非常简单，虽然用文字描述有点复杂。</p><p>首先，每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p><p>其次，编译器还会添加一个隐藏指向基类的指针，称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。</p><p>因此，它使每个类对象的分配大一个指针的大小。这意味着vptr由派生类继承。</p><h3><span id="实现与内部结构">实现与内部结构</span></h3><p>调用图：</p><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231009203842470.png" alt="image-20231009203842470"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file vptr1.cpp</span></span><br><span class="line"><span class="comment"> * @brief C++虚函数vptr和vtable</span></span><br><span class="line"><span class="comment"> * 编译：g++ -g -o vptr vptr1.cpp -std=c++11</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 派生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Derived::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DerivedClass::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取vptr地址与func地址,vptr指向的是一块内存，这块内存存放的是虚函数地址，这块内存就是我们所说的虚表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> * @param offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Fun <span class="title">getAddr</span><span class="params">(<span class="type">void</span>* obj,<span class="type">unsigned</span> <span class="type">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">void</span>* vptr_addr = (<span class="type">void</span> *)*(<span class="type">unsigned</span> <span class="type">long</span> *)obj;  <span class="comment">//64位操作系统，占8字节，通过*(unsigned long *)obj取出前8字节，即vptr指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vptr_addr:%p\n&quot;</span>,vptr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通过vptr指针访问virtual table，因为虚表中每个元素(虚函数指针)在64位编译器下是8个字节，因此通过*(unsigned long *)vptr_addr取出前8字节，</span></span><br><span class="line"><span class="comment">     * 后面加上偏移量就是每个函数的地址！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>* func_addr = (<span class="type">void</span> *)*((<span class="type">unsigned</span> <span class="type">long</span> *)vptr_addr+offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func_addr:%p\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="keyword">return</span> (Fun)func_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base ptr;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pt = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类实例</span></span><br><span class="line">    Base &amp;pp = ptr; <span class="comment">// 基类引用指向基类实例</span></span><br><span class="line">    Base &amp;p = d; <span class="comment">// 基类引用指向派生类实例</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象直接调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ptr.<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象调用基类实例&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pp.<span class="built_in">fun1</span>(); </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类指针指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pt-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类引用指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动查找vptr 和 vtable</span></span><br><span class="line">    Fun f1 = <span class="built_in">getAddr</span>(pt, <span class="number">0</span>);</span><br><span class="line">    (*f1)();</span><br><span class="line">    Fun f2 = <span class="built_in">getAddr</span>(pt, <span class="number">1</span>);</span><br><span class="line">    (*f2)();</span><br><span class="line">    <span class="keyword">delete</span> pt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>纯虚函数与虚函数的区别</p><ol><li>定义：<ul><li>虚函数是在基类中声明并被定义的函数，它可以在派生类中被重写以提供特定于派生类的实现</li><li>纯虚函数是在基类中声明但没有提供具体实现的函数，它以 <code>=0</code>结尾，要求派生类必须提供自己的实现</li></ul></li><li>实现：<ul><li>虚函数在基类中可以有一个默认的实现，纯虚函数没有</li></ul></li><li>基类实例化：<ul><li>虚函数对应的基类可以实例化，纯虚函数的不可以</li></ul></li><li>派生类实现：<ul><li>虚函数可以选择是否在派生类中重写</li><li>纯虚函数必须重写，否则派生类也为抽象类</li></ul></li><li>多继承<ul><li>如果一个类继承自多个含有同名虚函数的基类，他将继承所有这些虚函数，但只有一个实现会被调用，具体实现哪个取决于编译器和程序的实际实现          </li><li>纯虚函数，如果一个类继承自多个含有同名纯虚函数的基类，它必须提供所有这些纯虚函数的实现</li></ul></li></ol></blockquote><p>函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*ptr)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 声明一个函数指针 ptr，该指针指向一个接受两个整数参数并返回整数的函数</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">基类对象直接调用</span><br><span class="line">Base::fun1()</span><br><span class="line">基类引用指向派生类实例</span><br><span class="line">Base::fun1()</span><br><span class="line">基类指针指向派生类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">基类引用指向基类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x401130</span><br><span class="line">func_addr:0x400ea8</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x401130</span><br><span class="line">func_addr:0x400ed4</span><br><span class="line">DerivedClass::fun2()</span><br></pre></td></tr></table></figure><p>c++的动态多态性使通过虚函数来实现的，通过virtual函数，指向子类的基类指针可以调用子类的函数。</p><p>过程解析：首先程序识别出fun1()是个虚函数，其次程序使用pt-&gt;vptr来获取Derived的虚拟表。第三，他查找Derived虚拟表中调用哪个版本的fun1()。</p><blockquote><p>gdb调试的方式要进行加强。</p></blockquote><h2><span id="virtual那些事">virtual那些事</span></h2><h3><span id="虚函数与运行多态">虚函数与运行多态</span></h3><p>虚函数的调用取决于指向或者引用的对象的类型，而不是指针或自身的类型。</p><h3><span id="虚函数中默认参数">虚函数中默认参数</span></h3><p>默认参数是静态绑定的，虚函数是动态绑定的，默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> x = <span class="number">20</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj1;</span><br><span class="line">    Derived obj2;</span><br><span class="line"></span><br><span class="line">    Base* ptr1 = &amp;obj1;</span><br><span class="line">    Base* ptr2 = &amp;obj2;</span><br><span class="line"></span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Base class: 10</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出: Derived class: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>override</code> 用于显式告诉编译器，某个成员函数是意图覆盖基类中的虚函数。</p></blockquote><ol><li><p>静态函数不可以声明为虚函数，同时也不能被const volatile关键字修饰</p><ul><li>static成员函数不属于任何类对象或类实例</li></ul></li><li><p>构造函数不可以声明为虚函数，除了inline explicit之外，构造函数不允许任何关键字</p></li><li><p>析构函数可以为虚函数</p><ul><li>如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。</li></ul></li><li><p>虚函数</p><blockquote><ol><li>基类和继承类的访问控制：<ul><li>基类和继承类的访问控制可以分为 <code>public</code>、 <code>protected</code> 、<code>private</code>。这些访问修饰符决定了类的成员对于类的外部的可见性。</li><li>如果将基类声明为 <code>public</code> 继承，派生类继承了基类的 <code>public</code>成员，但这些成员在派生类中的访问权限保持不变</li><li>如果将基类声明为 <code>private</code>继承，也同样</li></ul></li><li>友元函数：<ul><li>友元函数是一个不属于类的成员函数，但他可以访问该类的私有成员。通常情况下，友元函数会在类的外部进行声明</li><li>如果在 <code>base</code>类中声明 <code>int main()</code>为友元函数，那就意味着 <code>main</code>可以访问 <code>base</code>的私有成员</li></ul></li></ol></blockquote></li><li><p>通过基类指针或者引用调用的虚函数不能被内联，实体对象</p></li></ol><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="volatile-那些事">volatile 那些事</span></h2><p>被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。这些可观测的副作用时由程序之外的因素决定的。</p><h3><span id="volatile应用">volatile应用</span></h3><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="assert-那些事">assert 那些事</span></h2><p>断言，是宏，而非函数。</p><p>assert作用是如果它的条件返回错误，则终止程序执行。</p><p>可以通过定义NDEBUG来关闭assert，但是需要在源代码的开头，include之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(<span class="type">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure><h3><span id="断言与正常错误处理">断言与正常错误处理</span></h3><p>断言主要用于检查逻辑上不可能的情况。他们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用</p><p>在代码开头加上</p><blockquote><h1><span id="define-ndebug-加上这行则-assert-不可用">define NDEBUG   // 加上这行，则 assert 不可用</span></h1></blockquote><h2><span id="位域那些事">位域那些事</span></h2><p><code>bit field</code>是一种数据结构，可以把数据以位的形式紧凑的存储，并允许程序员对此结构的位进行操作。</p><p>优点：</p><ol><li>可以是数据单元节省储存空间</li><li>bit field 可以很方便的访问一个整数值的部分内容从而简化源代码。</li></ol><p>缺点：</p><ul><li>实现以来具体的机器和系统，本质上不可移植</li></ul><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="extern-那些事">extern 那些事</span></h2><blockquote><p>允许在同一作用域中的某个函数和运算符指定多个定义，分别成为函数重载和运算符重载</p></blockquote><p>在同一个作用域中，可以声明几个功能相似的同名函数，但是这些同名函数的<strong>形式参数必须不同</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="type">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载的运算符是带有特殊名称的函数，函数名是由关键字operator和其后要重载的运算符符号构成的。重载运算符有一个返回类型和一个参数列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;);</span><br></pre></td></tr></table></figure><p>大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果是非成员函数，则需要传递两个参数。</p><h3><span id="可重载运算符">可重载运算符</span></h3><p><img src="http://warmfire-store.oss-cn-beijing.aliyuncs.com//img/image-20231010230712173.png" alt="image-20231010230712173"></p><h3><span id="c调用c函数">C++调用C函数</span></h3><p>引用C的头文件时，需要加 <code>extern &quot;C&quot;</code></p><p>编译的时候要注意，先通过gcc将.c文件生成中间文件.o</p><p>然后通过g++进行编译</p><h3><span id="c中调用c">C中调用C++</span></h3><h4><span id="未完待续">未完待续</span></h4><hr><h2><span id="struct-那些事">struct 那些事</span></h2><h3><span id="c中的struct">C中的struct</span></h3><ul><li>C中struct只单纯的用作数据的复合类型，结构体声明中只能够将数据成员放在其中，而函数不能</li><li>C结构体声明中不能使用C++访问修饰符，public protected private</li><li>C的结构体不能继承</li><li>若结构体的名字与函数名相同，可以正常运行且正常的调用</li></ul><h3><span id="c中的struct">C++中的struct</span></h3><ul><li>可以定义数据与函数</li><li>可以使用修饰符</li><li>使用可以不带struct</li><li>c++继承</li><li>若结构体名字与函数名相同，可以正常运行且正常的调用，定义结构体变量时只用带struct的</li></ul><ol><li>使用typedef定义结构体别名时函数与别名不能相同</li><li></li></ol><h2><span id="实现多态那些事">实现多态那些事</span></h2><ul><li>封装：使用函数指针把属性和方法封装到结构体中</li></ul><h2><span id="explicit-那些事">explicit 那些事</span></h2><p><a href="https://stackoverflow.com/questions/4600295/what-is-the-meaning-of-operator-bool-const">https://stackoverflow.com/questions/4600295/what-is-the-meaning-of-operator-bool-const</a></p><h2><span id="friend那些事">friend那些事</span></h2><h2><span id="模板那些事">模板那些事</span></h2><blockquote><p>教程：<a href="https://www.jianshu.com/p/70ca94872418">C++类模板，你看我就够了 - 简书 (jianshu.com)</a></p></blockquote><h3><span id="基础的类模板">基础的类模板</span></h3><p>类模板，可以定义相同的操作，拥有不同数据类型的成员属性。</p><p>通常使用 <code>template</code> 来声明，告诉编译器，碰到 <code>T</code> 不要报错，表示一种泛型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    Complex&lt;T&gt; <span class="keyword">operator</span>+(Complex &amp;c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a+c.a, <span class="keyword">this</span>-&gt;b+c.b)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对象的定义，必须声明模板类型，因为要分配内容</span></span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;  </span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    Complex&lt;<span class="type">int</span>&gt; c = a + b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库第三周学习日志</title>
      <link href="/2023/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="第一章-绪论">第一章 绪论</span></h1><h2><span id="11-数据库系统概述">1.1 数据库系统概述</span></h2><p>数据库是一种计算机辅助管理数据的方法与技术，研究如何有效地<strong>组织和存储数据</strong>，如何高效地<strong>获取和处理数据</strong></p><h3><span id="111-数据库的4个基本概念">1.1.1 数据库的4个基本概念</span></h3><h4><span id="1-数据-data">① 数据 Data</span></h4><p>数据是数据库中存储的基本对象</p><h5><span id="definition"><strong>Definition</strong></span></h5><p>是描述事物的符号记录，是可识别的、抽象的符号</p><h5><span id="categories"><strong>Categories</strong></span></h5><ul><li><p>结构化</p><ul><li><p>可以使用关系型数据库表示和存储，表现为规范的二维表格形式的数据</p></li><li><blockquote><person><name>A</name><age>13</age></person></blockquote></li></ul></li><li><p>半结构化</p><ul><li><p>结构化数据的一种形式，并不符合关系数据模型结构，但包括相关标记来分割语义元素，并对记录和字段进行分层</p></li><li><p>自描述的结构</p></li><li><blockquote><p>XML、JSON格式数据</p></blockquote></li></ul></li><li><p>非结构化</p><ul><li>文档、图片、视频等</li></ul></li></ul><h5><span id="another-definition"><strong>Another definition</strong></span></h5><p>​    使用约定俗成的关键字，对客观事物的数量、属性、状态、位置及其相互关系进行抽象表示，以适合在特定领域中用人工或自然的方式进行保存、传递和处理。</p><h5><span id="信息">信息</span></h5><p><strong>Definition</strong></p><ul><li>具有<strong>时效性</strong>，有一定含义的，有逻辑的、经过<strong>加工处理</strong>的、对决策有价值的<strong>数据流</strong>。</li><li><strong>信息 = 数据 + 处理</strong></li></ul><h5><span id="数据与信息">数据与信息</span></h5><ul><li>数据是信息的符号表示，或称载体；</li><li>信息是数据的内涵，是数据的语义解释；</li><li><strong>数据是符号化的信息</strong></li><li><strong>信息是语义化的数据</strong></li></ul><h5><span id="知识">知识</span></h5><p><strong>Definition</strong></p><ul><li>对消息进行<strong>归纳、演绎、比较</strong>等手段进行挖掘，使其有价值的部分沉淀下来，并于现存的人类知识体系相结合，有价值的信息就转变为知识。</li><li>知识是从<strong>定量到定性</strong>的过程得以实现的、抽象的、逻辑的东西。</li><li>知识在数据与信息之上，因它更接近行动，与决策有关。</li></ul><h5><span id="数据挖掘">数据挖掘</span></h5><ul><li>从大量、不完全的、有噪声的、随机的、模糊的实际应用数据中提取有用信息和知识的过程</li><li>常用算法<ul><li>分类、聚类、回归、关联规则</li><li>异常检测、特征分析、变化和偏差分析</li></ul></li></ul><h4><span id="2-数据库">② 数据库</span></h4><p><strong>Definition</strong></p><p>长期<strong>存储在计算机内</strong>、<strong>有组织的</strong>、<strong>可共享</strong>的大量<strong>数据的集合</strong></p><p><strong>基本特征</strong></p><ul><li>数据按一定的<strong>数据模型</strong> <em>组织、描述和储存</em></li><li>可为各种<em>用户</em> <strong>共享</strong></li><li><strong>冗余度较小</strong></li><li><strong>数据独立性较高</strong></li><li>易扩展</li></ul><h4><span id="3-数据库管理系统">③ 数据库管理系统</span></h4><p><strong>Definition</strong></p><ul><li>用户与操作系统之间的一层数据管理软件</li><li>帮助用户<strong>定义、创建、维护、控制</strong>数据库访问的<em>软件系统</em></li><li>基础软件</li></ul><p><strong>用途</strong></p><ul><li>科学地<strong>组织和存储</strong>数据</li><li>高效地<strong>获取和维护</strong>数据</li></ul><p><strong>主要功能</strong></p><ul><li><strong>数据定义</strong>功能<ul><li>提供数据定义语言（DDL）</li><li>定义数据库中的数据对象</li></ul></li><li>数据<strong>组织、存储和管理</strong><ul><li><strong>分类</strong>组织、存储和管理各种数据</li><li><strong>确定</strong>组织数据的<strong>文件结构和存取方式</strong></li><li>实现数据之间的联系</li><li>提供<strong>多种存取方式提高存取效率</strong></li></ul></li><li><strong>数据操纵</strong>功能<ul><li>提供数据操纵语言（DML）</li><li>实现对数据库的基本操作：增删改查</li></ul></li><li>数据库的<strong>事务管理和运行管理</strong><ul><li>数据库在建立、运行和维护时，由<strong>DBMS统一管理和控制</strong></li><li>保证数据的<strong>安全性、完整性</strong>；支持多用户对数据的<strong>并发使用</strong></li><li>发生故障后的<strong>系统数据恢复</strong>（自动、手动）</li></ul></li><li>数据库的<strong>建立和维护功能</strong><ul><li>数据库初始化：初始数据的装载和转换</li><li>数据库备份、转储、恢复功能</li><li>数据库的重组织</li><li>性能监控等</li></ul></li><li>其他功能</li></ul><h4><span id="4-数据库系统">④ 数据库系统</span></h4><p>Database System, DBS</p><p><strong>系统构成</strong></p><ul><li>数据库</li><li>DBMS</li><li>Application</li><li>DB Administrator</li></ul><p><strong>常见管理信息系统</strong>（MIS）架构</p><ul><li>Client/Server(C/S)架构<ul><li>通常是2层架构</li><li>胖客户端</li></ul></li><li>Browser/Server(B/S)架构<ul><li>典型三层架构</li><li>瘦客户端</li></ul></li></ul><p>架构的分层目的</p><ul><li>Flexibility：灵活</li><li>Maintainability：可维护</li><li>Reusability：可重用</li><li>Scalability：可扩展性</li></ul><p>Layer：逻辑功能分层，上下层之间由接口支撑关系</p><p>Tier：Layer的物理实现，可独立物理部署，一个Tier可包括多个Layer</p><p><strong>数据库系统特点</strong></p><ol><li><strong>数据结构化</strong><ul><li><strong>数据库的整体结构化</strong>是数据库的主要特征之一</li><li><strong>数据用数据模型描述</strong>，无需应用程序定义</li></ul></li><li>数据的<strong>共享性高，冗余度低</strong>且易扩充</li><li><strong>数据独立性高</strong><ul><li>物理独立性</li><li>逻辑独立性</li><li>数据独立性由DBMS的二级映像功能保证</li></ul></li><li>数据由DBMS<strong>统一管理和控制</strong><ul><li>数据控制功能<ul><li>安全性保护</li><li>完整性检查</li><li>并发控制</li><li>数据库恢复</li></ul></li></ul></li></ol><h2><span id="12-数据模型">1.2 数据模型</span></h2><ul><li><strong>对现实世界数据特征的抽象</strong></li><li>应满足三方面要求<ul><li>能比较<strong>真实地模拟现实世界</strong></li><li>容易为人所理解</li><li>便于在<strong>计算机上实现</strong></li></ul></li><li>是数据库系统的<strong>核心和基础</strong></li></ul><h3><span id="121-两大类数据模型">1.2.1 两大类数据模型</span></h3><p>数据模型分为两类</p><ol><li><strong>概念模型</strong><ul><li>信息模型，它是按<strong>用户的观点</strong>来对数据和信息建模</li></ul></li><li><strong>逻辑模型和物理模型</strong><ul><li>逻辑模型是按<strong>计算机的观点</strong>对数据建模，建立的是具体应用的数据库结构，用于DBMS实现，但不依赖具体的数据库软件厂商和版本。主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型。</li><li>物理模型是<strong>对数据最底层的抽象</strong>，数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法。</li></ul></li></ol><p>客观对象的抽象过程-<strong>两部抽象</strong></p><ol><li>将客观对象抽象成概念模型</li><li>将概念模型转换为某一数据库管理系统支持的数据模型</li></ol><p>数据建模是业务需求理解和概念抽象的过程</p><p>抽象过程：<strong>理解-区分-命名-表达</strong></p><p>数据建模的三个层次/阶段：</p><ol><li>概念模型</li><li>逻辑建模</li><li>物理建模</li></ol><h3><span id="122-概念模型">1.2.2 概念模型</span></h3><p><strong>用途</strong></p><ul><li><strong>用于信息世界的建模</strong></li><li><strong>设计人员和用户之间交流的语言</strong></li></ul><p><strong>基本要求</strong></p><ul><li>较强的语义表达能力</li><li>反应<strong>业务</strong>逻辑，<strong>用客户的述语描述</strong></li><li>简单、清晰、<strong>易于用户理解</strong></li></ul><p>概念模型的一种表示方法：</p><ul><li>实体-联系方法<ul><li>用E-R图来描述现实世界的概念模型</li></ul></li></ul><p>基本概念</p><ol><li>实体（Entity）：可以是具体的或抽象的</li><li>属性（Attribute）：某一特性</li><li>码/键（Key）：<strong>唯一标识</strong></li><li>实体型（Entity Type）：用<strong>实体名及其属性名集合来抽象和刻画同类实体</strong></li><li>实体集（Entity Set）：同一类型<strong>实体的集合</strong></li><li>联系（Relationship）：<ul><li>现实世界中事物内部及事物之间的联系反应为class内部的联系和class之间的联系</li><li>class内部的联系通常是指attributes’ relationship</li><li>class之间的联系通常是指Entity Set Realationship</li><li>一对一、一对多、多对多</li></ul></li></ol><h3><span id="123-数据模型的组成要素">1.2.3 数据模型的组成要素</span></h3><ul><li>数据结构</li><li>数据操作</li><li>数据的完整性约束条件</li></ul><h4><span id="数据结构">数据结构</span></h4><p>数据模型的数据结构：描述数据库的组成对象，以及对象之间的联系，是对<strong>系统静态特性的描述</strong></p><h4><span id="数据操作">数据操作</span></h4><p>对数据库中各种对象的实例允许执行的操作的集合，<strong>包括操作及有关操作规则</strong></p><p>操作类型：</p><ul><li>查询 Select</li><li>更新<ul><li>插入 Insert</li><li>删除 Delete</li><li>修改 Update</li></ul></li></ul><h4><span id="数据完整性约束条件">数据完整性约束条件</span></h4><ul><li>一组完整性规则的集合</li><li>完整性规则：给定的数据模型中<strong>数据及其联系</strong>所具有的制约和依存关系</li><li>用以限定符合数据模型的数据库状态及其状态的变化，以保证数据的<strong>正确、有效和相容</strong></li></ul><p>完整性约束条件的定义：</p><p>规定必须遵守的、<strong>基本的、通用的</strong>完整性约束条件；提供定义完整性约束条件的机制，以反映<strong>具体应用</strong>所设计的数据必须遵守的特定的语义约束条件</p><h3><span id="124-常用的数据模型">1.2.4 常用的数据模型</span></h3><p>网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型。</p><h3><span id="125-层次模型">1.2.5 层次模型</span></h3><p>树形结构</p><p>结点双亲唯一、一对多的实体联系</p><h3><span id="126-网状模型">1.2.6 网状模型</span></h3><p>允许一个以上的结点无双亲、一个节点可以有多于一个的双亲</p><h3><span id="127-关系模型">1.2.7 关系模型</span></h3><p>逻辑结构是一张二维表</p><ul><li>关系 Relation 一个关系对应一张表（包括数据</li><li>元组 Tuple 一行</li><li>属性 Attribute</li><li>主键 Key</li><li>域 Domain 相同数据类型的值的集合</li><li>分量 Component 元组的一个属性值</li><li>关系模式 Relation Schema 对关系的结构描述</li></ul><p>关系必须是规范化的，满足一定的规范条件</p><ul><li>关系的每一个分量必须是一个不可分的数据项，<strong>不允许表中还有表</strong></li></ul><p>数据操作是<strong>集合</strong>操作，操作对象和操作结果都是关系</p><p>关系的完整性约束条件： </p><ol><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ol><h3><span id="13-数据库系统的结构">1.3 数据库系统的结构</span></h3><p>从<strong>数据库应用开发人员角度</strong>看，数据库系统通常采用<strong>三级模式结构</strong>，是数据库系统<strong>内部的系统结构</strong></p><p>从数据库<strong>最终用户角度</strong>来看，结构分为</p><ul><li>单用户结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-服务器</li></ul><p>模式 Schema</p><ul><li>逻辑结构和特征的描述</li><li>型的描述</li><li>反映的是数据的结构及其联系</li><li>模式相对稳定</li></ul><p>实例 Instance</p><p>反映数据库某一时刻的状态</p><h4><span id="132-三级模式结构">1.3.2 三级模式结构</span></h4><p><strong>模式</strong>（逻辑模式）</p><ul><li>全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据试图</li></ul><p><strong>一个数据库只有一个模式</strong></p><p>模式：数据库系统模式结构的中间层</p><p>模式的定义</p><ul><li>数据的<strong>逻辑结构</strong></li><li>数据之间的联系</li><li>数据有关的安全性、完整性要求</li></ul><p><strong>外模式</strong></p><ul><li>用户使用的<strong>局部数据的逻辑结构和特征的描述</strong></li><li>数据库用户的数据视图</li><li>介于应用域模式之间</li></ul><p><strong>内模式</strong></p><ul><li>数据物理结构和存储方式的描述</li><li>对用户半透明</li></ul><h4><span id="133-数据库的二级映像功能与数据独立性">1.3.3 数据库的二级映像功能与数据独立性</span></h4><ul><li>外模式/模式映像<ul><li>保证数据的逻辑独立性</li></ul></li><li>模式/内模式映像<ul><li>定义了数据全局逻辑结构与存储结构之间的对应关系</li><li>唯一</li><li>保证数据的物理独立性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理第三周学习日志</title>
      <link href="/2023/09/22/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/22/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2><span id="11-问题的提出">1.1 问题的提出</span></h2><ul><li>信息检索市场前景广阔</li><li>跨语言通信与信息获取</li><li>机器翻译市场需求大</li><li>舆情监测</li></ul><ol><li>如何让计算机实现自动的或人机互助的语言处理功能？</li><li>如何让计算机实现海量语言信息的自动处理、知识挖掘、有效利用？</li></ol><h2><span id="12-基本概念">1.2 基本概念</span></h2><h4><span id="def-1-1-language-语言">Def. 1-1 Language 语言</span></h4><p>人类所特有的用来表达意思、交流思想的工具，是一种特殊的社会现象，由<strong>语音</strong>、<strong>词汇</strong>和<strong>语法</strong>构成一定的系统。</p><h4><span id="def-1-2-linguistics-语言学">Def. 1-2 Linguistics 语言学</span></h4><p>对语言的科学研究。</p><p><strong>语音</strong>和<strong>文字</strong>是语言的两个基本属性</p><h4><span id="def-1-3-phonetics-语音学">Def. 1-3 Phonetics 语音学</span></h4><p> 研究人类发音特点，特别是语音发音特点，并提出各种语音描述、分类和转写方法的科学。</p><ul><li>发音语音学 (articulatory phonetics)</li><li>声学语音学 (acoustic phonetics)</li><li>听觉语音学 (auditory phonetics)</li></ul><p>综上可以看出语音学的分支非常广，那便将其视为复数的语言科学 (linguistic sciences)</p><h4><span id="def-1-4-natural-language-understanding-自然语言理解">Def. 1-4 Natural Language Understanding 自然语言理解</span></h4><p>微观上讲， 语言理解是指从自然语言到机器内部之间的一种映射；从宏观上讲，语言理解是指机器能够执行人类所期望的某些语言功能。</p><p>如何判断理解、计算机系统的智能呢？</p><ul><li>表现 act</li><li>反应 react</li><li>相互作用 interact</li><li>Turing Test</li></ul><h4><span id="def-1-5-natural-language-processing-自然语言处理">Def. 1-5 Natural Language Processing 自然语言处理</span></h4><p>研制表示语言能力 (linguistic competence) 和语言应用 (linguistic performance)的模型，建立计算框架来实现这样的语言模型，提出相应的方法来不断地完善语言模型，设计使用系统，并探讨测评技术。</p><h4><span id="def-1-6-computational-linguistics-计算语言学">Def. 1-6: Computational Linguistics 计算语言学</span></h4><p>用计算技术和概念来阐述语言学和语音学问题。</p><h4><span id="三个不同的语系">三个不同的语系</span></h4><ol><li>屈折语 fusional language / inflectional language, 用词的形态变化表示语法关系，英语、法语等</li><li>黏着语 agglutinative language 专门表示语法意义的附加成分， 日语等</li><li>孤立语/分析语 isolating / analytic language 形态变化少，语法关系靠语序和虚词表示，汉语</li></ol><h2><span id="13-nlp-的产生与发展">1.3 NLP 的产生与发展</span></h2><p>源于机器翻译 (Machine Translation, MT)</p><h2><span id="14-研究内容">1.4 研究内容</span></h2><p>按应用目标划分，广义上包括</p><ol><li>机器翻译 (Machine translation, MT)</li><li>信息检索 (Information retrieval)</li><li>自动文摘 (Automatic summarization/ Automatic abstracting)</li><li>问答系统 (Question-answering system)</li><li>信息过滤 (Information filtering)</li><li>信息抽取 (Information extraction)</li><li>文档分类 (Document categorization)</li><li>情感分类 (Sentimental classification)</li><li>文字编辑和自动校对 (Automatic proofreading)</li><li>语音教学 (Language teaching)</li><li>文字识别 (Character recognition)</li><li>语音识别 (automatic speech recognition, ASR)</li><li>文语转换/语音合成 (text-to-speech synthesis)</li><li>说话人识别/认同/验证 (speaker recognition/ identification/ verification)</li></ol><h2><span id="15-基本问题和主要困难">1.5 基本问题和主要困难</span></h2><h3><span id="基本问题一形态学问题morphology-problem">基本问题一：形态学问题(Morphology Problem)</span></h3><p>word由有意义的词素 morphemes 构成，包括屈折变化和构词法两部分</p><h3><span id="基本问题二语法学问题-syntax-problem">基本问题二：语法学问题 (Syntax Problem)</span></h3><h3><span id="基本问题三-语义学问题-semantics-problem">基本问题三： 语义学问题 (Semantics Problem)</span></h3><h3><span id="基本问题四语用学问题-pragmatics-problem">基本问题四：语用学问题 (Pragmatics Problem)</span></h3><h3><span id="基本问题五-语音学问题-phonetics-problem">基本问题五： 语音学问题 (Phonetics Problem)</span></h3><h3><span id="困难一大量歧义现象-ambiguity">困难一：大量歧义现象 (ambiguity)</span></h3><ul><li>词法歧义</li><li>词性歧义</li><li>结构歧义</li><li>语义歧义</li><li>语音歧义</li><li>多音字及韵律等歧义</li></ul><h3><span id="困难二大量未知语言现象">困难二：大量未知语言现象</span></h3><ul><li>新词、人名、地名、术语</li><li>新含义</li><li>新用法、句型</li></ul><h2><span id="16-基本研究方法">1.6 基本研究方法</span></h2><h3><span id="理性主义">理性主义</span></h3><p>语言知识来源：语言知识很大部分是由遗传决定的。</p><p>研究对象：语言知识结构</p><p>理论：基于Chomsky语言原则，通过语言所必须遵守的原则来描述语言</p><p>处理方法：特殊语句或语法现象</p><p>求解方法：基于规则的分析方法，建立符号处理系统</p><h3><span id="经验主义">经验主义</span></h3><p>语言知识来源：语言知识是通过感官输入，经过简单联想与通用化的操作而得到的</p><p>研究对象：实际的语言数据</p><p>理论：信息论</p><p>处理方法：统计</p><p>求解方法：基于大规模真实语料的计算方法</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weblog</title>
      <link href="/2023/09/22/weblog/"/>
      <url>/2023/09/22/weblog/</url>
      
        <content type="html"><![CDATA[<h2><span id="q1hexo-next-主题下博客中数学公式无法正常渲染">Q1：hexo next 主题下博客中数学公式无法正常渲染</span></h2><p>参考教程：<a href="https://blog.csdn.net/yexiaohhjk/article/details/82526604">https://blog.csdn.net/yexiaohhjk/article/details/82526604</a></p><h2><span id="q2hexo-下的分类和表签无法显示怎么解决">Q2：hexo 下的分类和表签无法显示，怎么解决？</span></h2><p>参考教程：<a href="https://www.zhihu.com/question/29017171">https://www.zhihu.com/question/29017171</a></p><h2><span id="q3-hexo-添加后台管理功能">Q3： hexo 添加后台管理功能</span></h2><p>参考教程：<a href="https://blog.csdn.net/smileyan9/article/details/86666824">https://blog.csdn.net/smileyan9/article/details/86666824</a></p><h2><span id="q4解决hexo图片无法导入问题">Q4：解决hexo图片无法导入问题</span></h2><p>参考教程：<a href="https://blog.csdn.net/weixin_42030522/article/details/123075824">解决Hexo无法显示图片的几种方案_hexo 图片-CSDN博客</a></p><h2><span id="q5解决hexo首页博客只显示摘要部分">Q5：解决hexo首页博客只显示摘要部分</span></h2><p>参考教程：<a href="https://blog.csdn.net/yueyue200830/article/details/104470646">设置hexo首页只显示部分摘要（不显示全文）_hexo 摘要-CSDN博客</a></p><h2><span id="q6-hexo-next-github-pages-访问速度优化问题">Q6： hexo + Next + Github Pages 访问速度优化问题</span></h2><p>参考教程：<a href="https://zhuanlan.zhihu.com/p/33005841">加速访问基于 Github Pages 和 Hexo 的博客 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可证明安全第三周学习日志</title>
      <link href="/2023/09/21/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2023/09/21/%E5%8F%AF%E8%AF%81%E6%98%8E%E5%AE%89%E5%85%A8%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2><span id="principles-of-modern-crypto">Principles of Modern Crypto</span></h2><h3><span id="a-formal-definitions">A. Formal definitions</span></h3><blockquote><p>Precise, mathematical model and definition of what security means</p></blockquote><p>Definitions are essential for the design, analysis, and usage of crypto.</p><ul><li>Design: force the designer to think about what they really want.</li><li>Analysis: enable meaningful analysis, evaluation, and comparison of schemes</li><li>Usage: understand the security guarantees, modularity, substitute.</li></ul><h3><span id="b-assumptions">B. Assumptions</span></h3><blockquote><p>Clearly stated and unambiguous</p></blockquote><p><strong>Computational assumptions</strong></p><p>Principle: any such assumptions should be made explicit</p><ul><li>validate assumptions</li><li>meaningful comparison</li><li>practical implications</li></ul><h3><span id="c-proof-of-security">C. Proof of security</span></h3><blockquote><p>Move away from design-break-patch</p></blockquote><h2><span id="defining-secure-encryption">Defining Secure Encryption</span></h2><p>Crypto definitions (generally)</p><ul><li>Security guarantee/goal</li><li>Threat model<ul><li>ciphertext-only attack</li><li>known-plaintext attack</li><li>chosen-plaintext attack</li><li>chosen-ciphertext attack</li></ul></li></ul><h2><span id="perfect-secrecy">Perfect Secrecy</span></h2><h3><span id="informal-def">Informal def.</span></h3><p>Regardless of any prior information the attacker has about the plaintext, the ciphertext should leak no additional information about the plaintext.</p><h3><span id="basic-concepts">Basic concepts</span></h3><ul><li>Random variable (r.v.)</li><li>Event</li><li>Conditional probability</li><li>Law of total probability</li><li>$\mathcal{M}$ is plaintext space, $\mathcal{K}$ is key space, $\mathcal{C}$ is ciphertext space</li></ul><h3><span id="probability-distributions">Probability distributions</span></h3><p>characterize the probability distributions over key space</p><ul><li>r.v. M and K are independent</li></ul><script type="math/tex; mode=display">\ Encryption \ scheme \ with  \ \mathcal{M}  \ and \  \mathcal{C}, if \ for \ every \ distribution \ over \mathcal{M}, \\every \ m \in \mathcal{M}, and \ every \ c \in \mathcal{C}  \ with \  Pr[C=c] > 0, \  it \ holds \ that\\ Pr[M = m | C = c] = Pr[M = m]</script><h3><span id="equivalent-def">Equivalent Def</span></h3><script type="math/tex; mode=display">Pr[M=m | C=c ] = Pr[M=m]</script><script type="math/tex; mode=display">Pr[C=c | M=m] = Pr[C=c | M = m^{'}], \ i.e. \\Pr[Enc_K(m) = c] = Pr[Enc_K(m^{'}) = c]</script><script type="math/tex; mode=display">Pr[C=c | M=m] = Pr[C=c]</script><p><a href="https://www.cnblogs.com/TheFutureIsNow/p/11527610.html">密码学基础(二) - 完美保密 - Hang3 - 博客园 (cnblogs.com)</a></p><p>Perfectly secret and perfectly indistinguishable:</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 可证明安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，世界！</title>
      <link href="/2023/09/21/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81/"/>
      <url>/2023/09/21/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>这是我的<strong>第一篇</strong>博客，听说写一个独属于自己的博客最需要的便是坚持，而我相信我能行！</p><h2><span id="本站简介">本站简介</span></h2><p>我给我的网站起的名字叫暖火，想要表达的意思是向四周传播自己的光与热，我给我的网站定位是一个学习内容记录的学习性博客，在这里我会定期更新所有在学校学习内容的整理，一方面是作为复习，另一方面也是能够造福于大家，作为经常玩盗版游戏的我来说，开源精神弥足珍贵啦，哈哈。</p><p>我的文学素养有限，专业能力也在萌芽阶段，这篇hello,world一定不会是最终稿的，哈啊，我会再慢慢修改，让他更充实一点！</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
          <category> 建站理念 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
